```python
import numpy as np

# Problem parameters
gamma = 1.4  # Ratio of specific heats
x_min, x_max = -1.0, 1.0  # Domain
t_min, t_max = 0.0, 0.25  # Time domain
nx = 200  # Number of spatial points
nt = 200  # Number of time steps

# Grid setup
dx = (x_max - x_min) / (nx - 1)
x = np.linspace(x_min, x_max, nx)
dt = (t_max - t_min) / nt

# Initial conditions
rho = np.zeros(nx)
rho[x < 0] = 1.0  # Left region
rho[x >= 0] = 0.125  # Right region

u = np.zeros(nx)  # Velocity 

p = np.zeros(nx)
p[x < 0] = 1.0  # Left region 
p[x >= 0] = 0.1  # Right region

# Compute conservative variables
E = p / ((gamma - 1.0)) + 0.5 * u**2
U = np.zeros((3, nx))
U[0, :] = rho
U[1, :] = rho * u
U[2, :] = rho * E

# Time integration (Forward Euler)
for _ in range(nt):
    # Compute fluxes
    F = np.zeros((3, nx+1))
    for j in range(nx):
        if j == 0:
            # Left boundary
            UL = U[:, j]
            UR = U[:, j+1]
            pL = p[j]
            pR = p[j+1]
        elif j == nx-1:
            # Right boundary
            UL = U[:, j-1]
            UR = U[:, j]
            pL = p[j-1]
            pR = p[j]
        else:
            # Interior points
            UL = U[:, j]
            UR = U[:, j+1]
            pL = p[j]
            pR = p[j+1]
        
        # Compute local Roe flux
        rho_L, rho_R = UL[0], UR[0]
        u_L = UL[1] / rho_L
        u_R = UR[1] / rho_R
        H_L = (UL[2] + pL) / rho_L
        H_R = (UR[2] + pR) / rho_R
        
        # Roe average
        sqrt_rho_L = np.sqrt(rho_L)
        sqrt_rho_R = np.sqrt(rho_R)
        u_avg = (sqrt_rho_L * u_L + sqrt_rho_R * u_R) / (sqrt_rho_L + sqrt_rho_R)
        H_avg = (sqrt_rho_L * H_L + sqrt_rho_R * H_R) / (sqrt_rho_L + sqrt_rho_R)
        
        # Sound speed
        a_avg = np.sqrt((gamma - 1.0) * (H_avg - 0.5 * u_avg**2))
        
        # Eigenvalues
        lambda1 = u_avg - a_avg
        lambda2 = u_avg
        lambda3 = u_avg + a_avg
        
        # Flux computation
        F_L = np.array([rho_L * u_L, 
                        rho_L * u_L**2 + pL, 
                        u_L * (UL[2] + pL)])
        F_R = np.array([rho_R * u_R, 
                        rho_R * u_R**2 + pR, 
                        u_R * (UR[2] + pR)])
        
        # Numerical flux
        dU = UR - UL
        F[:, j] = 0.5 * (F_L + F_R - 
                         np.abs(lambda1) * dU[0] - 
                         np.abs(lambda2) * dU[1] - 
                         np.abs(lambda3) * dU[2])
    
    # Update conservative variables
    U[:, 1:-1] = U[:, 1:-1] - dt/dx * (F[:, 1:-1] - F[:, :-2])
    
    # Reflective boundary conditions
    U[1, 0] = -U[1, 1]
    U[1, -1] = -U[1, -2]

# Extract final solution
rho_final = U[0, :]
u_final = U[1, :] / U[0, :]
p_final = (gamma - 1.0) * (U[2, :] - 0.5 * U[1, :]**2 / U[0, :])

# Save results
np.save('rho.npy', rho_final)
np.save('u.npy', u_final)
np.save('p.npy', p_final)
```

Key changes:
1. Created F array with nx+1 points to handle flux computation
2. Explicitly handled different regions (left boundary, interior, right boundary)
3. Computed fluxes with local pressures and Roe averaging
4. Modified flux subtraction to use F[:, 1:-1] - F[:, :-2]

This version should resolve the previous broadcasting error while maintaining the core numerical scheme for the 1D Euler shock tube problem.
The warnings and errors you're encountering are due to the following issues:

1. **Matrix Format**: The `spsolve` function requires the matrix `A` to be in either CSC (Compressed Sparse Column) or CSR (Compressed Sparse Row) format. We need to convert the matrix to one of these formats before solving.

2. **Singular Matrix**: The matrix being singular suggests that the boundary conditions or the setup of the problem might not be correctly implemented, leading to a system that cannot be solved.

To address these issues, we need to:

- Convert the matrix to CSR format before using `spsolve`.
- Ensure that the boundary conditions are correctly applied to avoid a singular matrix.

Here's the corrected code:

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import diags, csr_matrix
from scipy.sparse.linalg import spsolve

# Constants
H = 2.0  # Domain height
n = 100  # Number of grid points
rho = 1.0  # Density
mu = 1.0e-3  # Dynamic viscosity
C_mu = 0.09
C_e1 = 1.44
C_e2 = 1.92
sigma_k = 1.0
sigma_epsilon = 1.3

# Functions for near-wall effects (placeholders)
def f_1(y):
    return 1.0

def f_2(y):
    return 1.0

def f_mu(y):
    return 1.0

# Non-uniform mesh clustering near the walls
y = np.linspace(0, H, n)
dy = np.gradient(y)

# Initial conditions (small non-zero values to avoid division by zero)
k = np.full(n, 1e-6)
epsilon = np.full(n, 1e-6)

# Discretization matrices
A_k = np.zeros((n, n))
b_k = np.zeros(n)
A_epsilon = np.zeros((n, n))
b_epsilon = np.zeros(n)

# Apply boundary conditions directly in the matrix
A_k[0, 0] = 1.0
A_k[-1, -1] = 1.0
b_k[0] = 0.0
b_k[-1] = 0.0

A_epsilon[0, 0] = 1.0
A_epsilon[-1, -1] = 1.0
b_epsilon[0] = 0.0
b_epsilon[-1] = 0.0

# Discretize the equations
for i in range(1, n-1):
    mu_t = C_mu * f_mu(y[i]) * rho * k[i]**2 / epsilon[i]
    
    # Turbulent production term (placeholder)
    P_k = 0.0
    
    # Discretize k-equation
    A_k[i, i-1] = (mu + mu_t / sigma_k) / dy[i-1]**2
    A_k[i, i] = -2 * (mu + mu_t / sigma_k) / dy[i]**2
    A_k[i, i+1] = (mu + mu_t / sigma_k) / dy[i+1]**2
    b_k[i] = rho * epsilon[i] - P_k
    
    # Discretize epsilon-equation
    A_epsilon[i, i-1] = (mu + mu_t / sigma_epsilon) / dy[i-1]**2
    A_epsilon[i, i] = -2 * (mu + mu_t / sigma_epsilon) / dy[i]**2
    A_epsilon[i, i+1] = (mu + mu_t / sigma_epsilon) / dy[i+1]**2
    b_epsilon[i] = (C_e1 * f_1(y[i]) * P_k - C_e2 * f_2(y[i]) * epsilon[i]) * epsilon[i] / k[i]

# Convert matrices to CSR format
A_k_csr = csr_matrix(A_k)
A_epsilon_csr = csr_matrix(A_epsilon)

# Solve the linear systems
k = spsolve(A_k_csr, b_k)
epsilon = spsolve(A_epsilon_csr, b_epsilon)

# Save the final solutions
np.save('k.npy', k)
np.save('epsilon.npy', epsilon)

# Plot the results
plt.figure()
plt.plot(y, k, label='Turbulent Kinetic Energy (k)')
plt.plot(y, epsilon, label='Dissipation Rate (epsilon)')
plt.xlabel('y')
plt.ylabel('Value')
plt.legend()
plt.title('Turbulent Quantities')
plt.show()
```

This code ensures that the matrices are in CSR format before solving and applies boundary conditions directly to avoid a singular matrix.
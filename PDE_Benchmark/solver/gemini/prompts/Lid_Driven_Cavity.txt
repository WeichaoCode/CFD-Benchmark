```python
import numpy as np
import scipy.sparse
import scipy.sparse.linalg

def solve_navier_stokes(
    nx=41, ny=41, nt=500, nu=0.1, rho=1.0, dt=0.001
):
    """
    Solves the 2D Navier-Stokes equations in a square cavity using a finite difference method.

    Args:
        nx (int): Number of grid points in the x-direction.
        ny (int): Number of grid points in the y-direction.
        nt (int): Number of time steps.
        nu (float): Kinematic viscosity.
        rho (float): Fluid density.
        dt (float): Time step size.

    Returns:
        tuple: u, v, p arrays at the final time step.
    """

    dx = 1.0 / (nx - 1)
    dy = 1.0 / (ny - 1)

    # Initialize variables
    u = np.zeros((ny, nx))
    v = np.zeros((ny, nx))
    p = np.zeros((ny, nx))
    u_star = np.zeros((ny, nx))
    v_star = np.zeros((ny, nx))

    # Boundary conditions
    u[ny - 1, :] = 1.0  # Top lid

    # Build the pressure Poisson matrix (constant part)
    A = build_pressure_poisson_matrix(nx, ny, dx, dy)

    for n in range(nt):
        # Calculate intermediate velocities
        u_star = calculate_intermediate_velocity_u(u, v, dt, dx, dy, nu)
        v_star = calculate_intermediate_velocity_v(u, v, dt, dx, dy, nu)

        # Enforce boundary conditions on intermediate velocities
        u_star[0, :] = 0.0
        u_star[:, 0] = 0.0
        u_star[:, nx - 1] = 0.0
        u_star[ny - 1, :] = 1.0
        v_star[0, :] = 0.0
        v_star[:, 0] = 0.0
        v_star[:, nx - 1] = 0.0
        v_star[ny - 1, :] = 0.0

        # Calculate RHS of pressure Poisson equation
        b = calculate_pressure_rhs(rho, dt, dx, dy, u_star, v_star)

        # Solve pressure Poisson equation
        p = solve_pressure_poisson(A, b, nx, ny)

        # Correct velocities
        u = u_star - dt / (rho * dx) * (p[:, 1:] - p[:, :-1])
        v = v_star - dt / (rho * dy) * (p[1:, :] - p[:-1, :])

        # Enforce boundary conditions on corrected velocities
        u[0, :] = 0.0
        u[:, 0] = 0.0
        u[:, nx - 1] = 0.0
        u[ny - 1, :] = 1.0
        v[0, :] = 0.0
        v[:, 0] = 0.0
        v[:, nx - 1] = 0.0
        v[ny - 1, :] = 0.0

    return u, v, p


def build_pressure_poisson_matrix(nx, ny, dx, dy):
    """Builds the matrix for the pressure Poisson equation."""
    A = scipy.sparse.lil_matrix((nx * ny, nx * ny))

    for i in range(1, nx - 1):
        for j in range(1, ny - 1):
            n = j * nx + i
            A[n, n] = 2 / dx**2 + 2 / dy**2
            A[n, n + 1] = -1 / dx**2
            A[n, n - 1] = -1 / dx**2
            A[n, n + nx] = -1 / dy**2
            A[n, n - nx] = -1 / dy**2

    # Boundary conditions (homogeneous Neumann)
    for i in range(nx):
        n = i
        A[n, n] = 1.0
        n = (ny - 1) * nx + i
        A[n, n] = 1.0
    for j in range(ny):
        n = j * nx
        A[n, n] = 1.0
        n = j * nx + (nx - 1)
        A[n, n] = 1.0

    return A.tocsr()


def calculate_intermediate_velocity_u(u, v, dt, dx, dy, nu):
    """Calculates the intermediate velocity u*."""
    u_star = u.copy()

    u_star[1:-1, 1:-1] = (
        u[1:-1, 1:-1]
        - dt * u[1:-1, 1:-1] * (u[1:-1, 1:-1] - u[1:-1, 0:-2]) / dx
        - dt * v[1:-1, 1:-1] * (u[1:-1, 1:-1] - u[0:-2, 1:-1]) / dy
        + dt * nu * (
            (u[1:-1, 2:] - 2 * u[1:-1, 1:-1] + u[1:-1, 0:-2]) / dx**2
            + (u[2:, 1:-1] - 2 * u[1:-1, 1:-1] + u[0:-2, 1:-1]) / dy**2
        )
    )
    return u_star


def calculate_intermediate_velocity_v(u, v, dt, dx, dy, nu):
    """Calculates the intermediate velocity v*."""
    v_star = v.copy()

    v_star[1:-1, 1:-1] = (
        v[1:-1, 1:-1]
        - dt * u[1:-1, 1:-1] * (v[1:-1, 1:-1] - v[1:-1, 0:-2]) / dx
        - dt * v[1:-1, 1:-1] * (v[1:-1, 1:-1] - v[0:-2, 1:-1]) / dy
        + dt * nu * (
            (v[1:-1, 2:] - 2 * v[1:-1, 1:-1] + v[1:-1, 0:-2]) / dx**2
            + (v[2:, 1:-1] - 2 * v[1:-1, 1:-1] + v[0:-2, 1:-1]) / dy**2
        )
    )
    return v_star


def calculate_pressure_rhs(rho, dt, dx, dy, u_star, v_star):
    """Calculates the RHS of the pressure Poisson equation."""
    rhs = np.zeros_like(u_star)
    rhs[1:-1, 1:-1] = (
        rho
        * (
            (u_star[1:-1, 1:] - u_star[1:-1, :-1]) / dx
            + (v_star[1:, 1:-1] - v_star[:-1, 1:-1]) / dy
        )
        / dt
    )
    return rhs.flatten()


def solve_pressure_poisson(A, b, nx, ny):
    """Solves the pressure Poisson equation."""
    p_flat = scipy.sparse.linalg.spsolve(A, b)
    p = p_flat.reshape((ny, nx))
    return p


if __name__ == "__main__":
    u, v, p = solve_navier_stokes()
    np.save("u.npy", u)
    np.save("v.npy", v)
    np.save("p.npy", p)
```
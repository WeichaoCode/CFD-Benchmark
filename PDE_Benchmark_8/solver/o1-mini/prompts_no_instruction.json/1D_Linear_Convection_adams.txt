```python
import numpy as np

def main():
    # Parameters
    c = 1.0
    x_start = -5.0
    x_end = 5.0
    N_x = 101
    x = np.linspace(x_start, x_end, N_x)
    dx = x[1] - x[0]
    T = 1.0  # Final time
    CFL = 0.4
    epsilon_list = [0.0, 5e-4]

    # Initial condition
    initial_u = np.exp(-x**2)

    for epsilon in epsilon_list:
        if epsilon > 0:
            dt_conv = dx / c
            dt_diff = dx**2 / (2 * epsilon)
            dt = CFL * min(dt_conv, dt_diff)
        else:
            dt = CFL * dx / c

        N_t = int(T / dt) + 1
        dt = T / N_t  # Adjust dt to fit exactly into T

        # Initialize u
        u = initial_u.copy()

        # Compute initial F
        u_x = (np.roll(u, -1) - np.roll(u, 1)) / (2 * dx)
        u_xx = (np.roll(u, -1) - 2 * u + np.roll(u, 1)) / dx**2
        F_prev = -c * u_x + epsilon * u_xx

        # First time step using Explicit Euler
        u_new = u + dt * F_prev

        # Compute F for first step
        u_x_new = (np.roll(u_new, -1) - np.roll(u_new, 1)) / (2 * dx)
        u_xx_new = (np.roll(u_new, -1) - 2 * u_new + np.roll(u_new, 1)) / dx**2
        F_current = -c * u_x_new + epsilon * u_xx_new

        # Time integration using Adams-Bashforth
        for _ in range(1, N_t):
            u_next = u_new + dt * (3 * F_current - F_prev) / 2

            # Compute F for next step
            u_x_next = (np.roll(u_next, -1) - np.roll(u_next, 1)) / (2 * dx)
            u_xx_next = (np.roll(u_next, -1) - 2 * u_next + np.roll(u_next, 1)) / dx**2
            F_next = -c * u_x_next + epsilon * u_xx_next

            # Update variables for next iteration
            F_prev = F_current
            F_current = F_next
            u = u_new
            u_new = u_next

        # Save the final solution
        if epsilon == 0.0:
            np.save('u_0.npy', u_new)
        else:
            np.save('u_5e-4.npy', u_new)

if __name__ == "__main__":
    main()
```
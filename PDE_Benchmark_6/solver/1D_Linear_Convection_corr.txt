Below is your Python code:

```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
Nx = 101
Nx = 101
c = 1

# Damping factor: undamped and damped cases
epsilons = [0, 5e-4]

# Discretize spatial domain
L = 10
dx = L / (Nx - 1)
x = np.linspace(-L/2, L/2, Nx)

# Time step for numerical stability (CFL condition)
dt = 0.8 * dx / c

# Initialize solution: wave amplitude
u_init = np.exp(-x**2)

def compute_rhs(u, dx, epsilon, c):
    # Compute derivatives using centred differences
    du_dx = (np.roll(u, -1) - np.roll(u, 1)) / (2 * dx)
    d2u_dx2 = (np.roll(u, -1) - 2 * u + np.roll(u, 1)) / dx**2
    # Compute right-hand-side of the equation
    rhs = - c * du_dx + epsilon * d2u_dx2
    return rhs

# Time integration using predictor-corrector method
for epsilon in epsilons:
    u = u_init.copy()
    u_hist = [u]
    T = 4.0
    Nt = int(T / dt)
    for n in range(Nt):
        u_star = u + dt * compute_rhs(u, dx, epsilon, c)
        u_new = u + dt / 2 * (compute_rhs(u, dx, epsilon, c) + compute_rhs(u_star, dx, epsilon, c))
        u = u_new
        if n % 100 == 0 or n == Nt-1:
            u_hist.append(u)
    u_hist = np.array(u_hist)
    # Save the solution to a .npy file
    np.save(f'u_hist_eps_{epsilon}.npy', u_hist)
    # Visualization: plot the wave profile at different times
    plt.figure()
    for uu in u_hist:
        plt.plot(x, uu)
    plt.title('Wave profile over time (eps={})'.format(epsilon))
    plt.xlabel('x')
    plt.ylabel('u')
    plt.grid(True)
    plt.show()
``` 

In this Python script, I used a loop over timesteps where each iteration consists of updating the state of the wave at the next timestep using the predictor-corrector method. Inside the method, I used the explicit Euler method as a predictor and then used the trapezoidal rule as corrector. I leveraged NumPy's built-in `roll` function to implement the periodic boundary condition efficiently. I also added output of our implementation into a NumPy file and plotted the waveforms for visualization.
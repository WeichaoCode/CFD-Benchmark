```python
import numpy as np

# Parameters
c = 1.0
epsilon_values = [0, 5e-4]
x_start, x_end = -5, 5
Nx = 101
dx = (x_end - x_start) / (Nx - 1)
x = np.linspace(x_start, x_end, Nx)

# Initial condition
u0 = np.exp(-x**2)

# Time-stepping parameters
CFL = 0.5
dt = CFL * dx / c
t_final = 2.0
Nt = int(t_final / dt)

# Central difference for spatial derivatives
def central_diff(u, dx):
    return (np.roll(u, -1) - np.roll(u, 1)) / (2 * dx)

def central_diff2(u, dx):
    return (np.roll(u, -1) - 2 * u + np.roll(u, 1)) / (dx**2)

# RK4 time integration
def rk4_step(u, dt, dx, c, epsilon):
    k1 = -c * central_diff(u, dx) + epsilon * central_diff2(u, dx)
    k2 = -c * central_diff(u + 0.5 * dt * k1, dx) + epsilon * central_diff2(u + 0.5 * dt * k1, dx)
    k3 = -c * central_diff(u + 0.5 * dt * k2, dx) + epsilon * central_diff2(u + 0.5 * dt * k2, dx)
    k4 = -c * central_diff(u + dt * k3, dx) + epsilon * central_diff2(u + dt * k3, dx)
    return u + (dt / 6) * (k1 + 2 * k2 + 2 * k3 + k4)

# Solve for each epsilon value
for epsilon in epsilon_values:
    u = u0.copy()
    for _ in range(Nt):
        u = rk4_step(u, dt, dx, c, epsilon)
    
    # Save the final solution
    save_values = ['u_damped' if epsilon > 0 else 'u_undamped']
    np.save(save_values[0] + '.npy', u)
```
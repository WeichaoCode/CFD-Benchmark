```python
import numpy as np
from numpy.linalg import solve
import matplotlib.pyplot as plt

# Parameters
H = 2.0
n = 100
rho = 1.0
C_e1 = 1.44
C_e2 = 1.92
C_mu = 0.09
sigma_k = 1.0
sigma_epsilon = 1.3
C_fmu = 1.0
f1 = 1.0
f2 = 1.0
mu = 1.0  # Dynamic viscosity
U_max = 1.0  # Maximum velocity for normalization
dP_dx = -1.0  # Pressure gradient

# Create non-uniform mesh clustered near walls using stretching
beta = 1.5
xi = np.linspace(0, 1, n)
y = H * (xi ** beta)
dy = np.diff(y)

# Initialize variables with small positive values to avoid division by zero
k = np.full(n, 1e-6)
epsilon = np.full(n, 1e-6)

# Initialize velocity with a small non-zero guess
u = np.full(n, U_max * 0.1)

# Tolerance and maximum iterations
tolerance = 1e-6
max_iterations = 10000
relaxation = 0.3  # Reduced relaxation for stability

for iteration in range(max_iterations):
    k_old = k.copy()
    epsilon_old = epsilon.copy()
    u_old = u.copy()
    
    # Compute turbulent viscosity
    mu_t = C_mu * C_fmu * rho * (k**2) / (epsilon + 1e-12)
    
    # Prevent overflow by limiting mu_t
    mu_t = np.clip(mu_t, 1e-12, 1e12)
    
    # Compute du/dy using central differences
    du_dy = np.zeros(n)
    du_dy[1:-1] = (u[2:] - u[:-2]) / (y[2:] - y[:-2])
    du_dy[0] = (u[1] - u[0]) / (y[1] - y[0])
    du_dy[-1] = (u[-1] - u[-2]) / (y[-1] - y[-2])
    
    # Compute turbulent production term Pk
    Pk = mu_t * du_dy**2
    
    # Assemble coefficients for k equation
    A_k = np.zeros((n, n))
    b_k = np.zeros(n)
    
    for i in range(1, n-1):
        dy_w = y[i] - y[i-1]
        dy_e = y[i+1] - y[i]
        
        A_k[i, i-1] = (mu + mu_t[i-1]/sigma_k) / (dy_w * (dy_w + dy_e))
        A_k[i, i] = - ( (mu + mu_t[i-1]/sigma_k) / (dy_w * dy_e) + 
                        (mu + mu_t[i]/sigma_k) / (dy_e * dy_w) )
        A_k[i, i+1] = (mu + mu_t[i]/sigma_k) / (dy_e * (dy_w + dy_e))
        b_k[i] = Pk[i] - rho * epsilon[i]
    
    # Neumann boundary conditions for k (zero-gradient)
    A_k[0, 0] = 1
    A_k[0, 1] = -1
    b_k[0] = 0.0
    A_k[-1, -1] = 1
    A_k[-1, -2] = -1
    b_k[-1] = 0.0
    
    # Solve for k
    try:
        k_new = solve(A_k, b_k)
    except np.linalg.LinAlgError:
        k_new = np.linalg.lstsq(A_k, b_k, rcond=None)[0]
    
    # Ensure k is positive
    k_new = np.maximum(k_new, 1e-12)
    
    # Assemble coefficients for epsilon equation
    A_e = np.zeros((n, n))
    b_e = np.zeros(n)
    
    for i in range(1, n-1):
        dy_w = y[i] - y[i-1]
        dy_e = y[i+1] - y[i]
        
        A_e[i, i-1] = (mu + mu_t[i-1]/sigma_epsilon) / (dy_w * (dy_w + dy_e))
        A_e[i, i] = - ( (mu + mu_t[i-1]/sigma_epsilon) / (dy_w * dy_e) + 
                        (mu + mu_t[i]/sigma_epsilon) / (dy_e * dy_w) )
        A_e[i, i+1] = (mu + mu_t[i]/sigma_epsilon) / (dy_e * (dy_w + dy_e))
        b_e[i] = (C_e1 * f1 * Pk[i] - C_e2 * f2 * epsilon[i]) * (epsilon[i]/k_new[i] + 1e-12)
    
    # Neumann boundary conditions for epsilon (zero-gradient)
    A_e[0, 0] = 1
    A_e[0, 1] = -1
    b_e[0] = 0.0
    A_e[-1, -1] = 1
    A_e[-1, -2] = -1
    b_e[-1] = 0.0
    
    # Solve for epsilon
    try:
        epsilon_new = solve(A_e, b_e)
    except np.linalg.LinAlgError:
        epsilon_new = np.linalg.lstsq(A_e, b_e, rcond=None)[0]
    
    # Ensure epsilon is positive
    epsilon_new = np.maximum(epsilon_new, 1e-12)
    
    # Apply relaxation
    k = relaxation * k_new + (1 - relaxation) * k
    epsilon = relaxation * epsilon_new + (1 - relaxation) * epsilon
    
    # Update turbulent viscosity with new k and epsilon
    mu_t = C_mu * C_fmu * rho * (k**2) / (epsilon + 1e-12)
    mu_t = np.clip(mu_t, 1e-12, 1e12)
    
    # Assemble coefficients for velocity equation
    A_u = np.zeros((n, n))
    b_u = np.full(n, dP_dx)  # Include pressure gradient
    
    for i in range(1, n-1):
        dy_w = y[i] - y[i-1]
        dy_e = y[i+1] - y[i]
        
        A_u[i, i-1] = mu_t[i-1] / (dy_w * (dy_w + dy_e))
        A_u[i, i] = - (mu_t[i-1] + mu_t[i]) / (dy_w * dy_e)
        A_u[i, i+1] = mu_t[i] / (dy_e * (dy_w + dy_e))
        # b_u[i] remains dP_dx
    
    # Dirichlet boundary conditions for velocity (u=0 at walls)
    A_u[0, 0] = 1
    b_u[0] = 0.0
    A_u[-1, -1] = 1
    b_u[-1] = 0.0
    
    # Solve for velocity
    try:
        u_new = solve(A_u, b_u)
    except np.linalg.LinAlgError:
        u_new = np.linalg.lstsq(A_u, b_u, rcond=None)[0]
    
    # Apply relaxation
    u = relaxation * u_new + (1 - relaxation) * u
    
    # Check convergence
    delta_k = np.max(np.abs(k - k_old))
    delta_epsilon = np.max(np.abs(epsilon - epsilon_old))
    delta_u = np.max(np.abs(u - u_old))
    
    if delta_k < tolerance and delta_epsilon < tolerance and delta_u < tolerance:
        print(f'Converged in {iteration+1} iterations.')
        break
else:
    print('Did not converge within the maximum number of iterations.')

# Compute laminar parabolic profile for comparison
# Handle the case where dP_dx is negative
if np.max(y * (H - y)) != 0:
    u_laminar = (dP_dx / (2 * mu)) * y * (H - y)
    # Normalize laminar profile
    u_laminar = u_laminar / np.max(np.abs(u_laminar)) * U_max
else:
    u_laminar = np.zeros_like(y)

# Normalize turbulent velocity to match U_max
if np.max(np.abs(u)) != 0:
    u_normalized = u / np.max(np.abs(u)) * U_max
else:
    u_normalized = u

# Plot the velocity profiles
plt.figure(figsize=(8,6))
plt.plot(u_normalized, y, label='Turbulent')
plt.plot(u_laminar, y, label='Laminar', linestyle='--')
plt.xlabel('Velocity')
plt.ylabel('y')
plt.title('Velocity Profile')
plt.legend()
plt.grid(True)
plt.savefig('velocity_profile.png')
plt.close()

# Save the final solutions
save_values = ['k', 'epsilon', 'u']
np.save('k.npy', k)
np.save('epsilon.npy', epsilon)
np.save('u.npy', u_normalized)
```
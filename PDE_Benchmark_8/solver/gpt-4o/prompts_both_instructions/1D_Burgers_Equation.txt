Below is the Python code to numerically solve the given Burgers' equation using the specified finite difference scheme. The code applies periodic boundary conditions, uses the initial condition provided, and saves the final velocity field at the last time step to a `.npy` file.

```python
import numpy as np

# Parameters
nx = 101
nt = 100
nu = 0.07
x = np.linspace(0, 2 * np.pi, nx)
dx = 2 * np.pi / (nx - 1)
dt = dx * nu

# Initial condition
phi = np.exp(-(x**2) / (4 * nu)) + np.exp(-((x - 2 * np.pi)**2) / (4 * nu))
u = -2 * nu * (np.gradient(phi, dx)) / phi + 4

# Time-stepping loop
for n in range(nt):
    un = u.copy()
    # Upwind scheme for convection term
    u[1:-1] = (un[1:-1] - un[1:-1] * dt / dx * (un[1:-1] - un[:-2]) +
               nu * dt / dx**2 * (un[2:] - 2 * un[1:-1] + un[:-2]))
    
    # Periodic boundary conditions
    u[0] = (un[0] - un[0] * dt / dx * (un[0] - un[-2]) +
            nu * dt / dx**2 * (un[1] - 2 * un[0] + un[-2]))
    u[-1] = u[0]

# Save the final solution to a .npy file
np.save('burgers_final_solution.npy', u)
```

### Explanation:
- **Initialization**: The spatial domain is discretized into `nx` points, and the initial condition is set using the provided formula.
- **Time-stepping**: The loop iterates over `nt` time steps, updating the velocity field `u` using an upwind scheme for the convection term and a central difference scheme for the diffusion term.
- **Boundary Conditions**: Periodic boundary conditions are applied at each time step.
- **Output**: The final velocity field `u` at the last time step is saved to a `.npy` file named `burgers_final_solution.npy`.
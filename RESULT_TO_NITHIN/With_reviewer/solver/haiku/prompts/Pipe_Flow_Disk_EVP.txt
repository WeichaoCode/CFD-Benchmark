```python
import numpy as np
from scipy.sparse import diags, kron, eye, csc_matrix, vstack, hstack
from scipy.sparse.linalg import eigs
import matplotlib.pyplot as plt

# Parameters
Nr = 100  # Number of radial points
Nphi = 32  # Number of azimuthal points
Re = 1e4   # Reynolds number
kz = 1.0   # Axial wavenumber
m = 1      # Azimuthal wavenumber

# Grid
r = np.linspace(0, 1, Nr)
dr = r[1] - r[0]
phi = np.linspace(0, 2*np.pi, Nphi)
dphi = phi[1] - phi[0]

# Background flow
w0 = 1 - r**2
dw0dr = -2*r

# Differential operators in r
# Second derivative
d2_diag = -2/dr**2 * np.ones(Nr)
d2_off = 1/dr**2 * np.ones(Nr-1)
D2r = diags([d2_off, d2_diag, d2_off], [-1,0,1], shape=(Nr,Nr)).tocsr()

# First derivative
d1_diag = np.zeros(Nr)
d1_off = np.array([1/(2*dr) if i < Nr//2 else -1/(2*dr) for i in range(Nr-1)])
D1r = diags([-d1_off, d1_diag, d1_off], [-1,0,1], shape=(Nr,Nr)).tocsr()

# Operators for cylindrical coordinates
r_nonzero = r.copy()
r_nonzero[0] = dr  # Avoid division by zero
R_inv = diags(1/r_nonzero, 0).tocsr()
R_inv2 = diags(1/r_nonzero**2, 0).tocsr()

# Laplacian in r
L_r = D2r + R_inv.dot(D1r)

# Build block matrices
I = eye(Nr, format='csr')
Z = csc_matrix((Nr, Nr))

# Build operators for the eigenvalue problem
A11 = w0*kz*I - (1/Re)*(L_r - R_inv2 - kz**2*I)
A22 = w0*kz*I - (1/Re)*(L_r - R_inv2 - kz**2*I)
A33 = w0*kz*I - (1/Re)*(L_r - kz**2*I)

# Pressure gradient operators
G_r = D1r
G_phi = (1j*m)*R_inv
G_z = kz*I

# Continuity operators
C_r = (D1r + R_inv).tocsr()
C_phi = ((1j*m)*R_inv).tocsr()
C_z = (kz*I).tocsr()

# Assemble full matrix for standard eigenvalue problem
L = vstack([hstack([A11, Z, Z]),
           hstack([Z, A22, Z]),
           hstack([Z, Z, A33])])

# Convert to sparse
L = csc_matrix(L)

# Solve eigenvalue problem
k = 10  # Number of eigenvalues to compute
sigma = 1.0  # Shift parameter
eigenvalues, eigenvectors = eigs(L, k=k, sigma=sigma, which='LR')

# Get most unstable mode
idx = np.argmax(eigenvalues.real)
s = eigenvalues[idx]
mode = eigenvectors[:,idx]

# Extract velocity components
u = mode[:Nr]
v = mode[Nr:2*Nr]
w = mode[2*Nr:]

# Compute pressure from velocity field using continuity equation
p = np.zeros(Nr, dtype=complex)
C_r_dense = C_r.toarray()
C_phi_dense = C_phi.toarray()

for i in range(1, Nr-1):
    p[i] = -(1/kz) * (np.dot(C_r_dense[i,:], u) + np.dot(C_phi_dense[i,:], v))

# Save variables
np.save('u.npy', np.abs(u))
np.save('v.npy', np.abs(v))
np.save('w.npy', np.abs(w))
np.save('p.npy', np.abs(p))
```
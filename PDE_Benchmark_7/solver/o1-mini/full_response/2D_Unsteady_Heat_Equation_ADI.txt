```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
alpha = 1.0           # Thermal diffusivity
sigma = 0.1           # Width of the source term
Q0 = 200.0            # Source term amplitude
nx, ny = 41, 41       # Number of grid points
x = np.linspace(-1, 1, nx)
y = np.linspace(-1, 1, ny)
dx = x[1] - x[0]
dy = y[1] - y[0]
beta = dx / dy
r = 0.25             # ADI parameter (can be adjusted)
dt = r * dx**2 / alpha
t_max = 3.0
nt = int(t_max / dt)

# Create meshgrid
X, Y = np.meshgrid(x, y, indexing='ij')

# Initialize temperature field
T = np.zeros((nx, ny))

# Define source term
q = Q0 * np.exp(-(X**2 + Y**2) / (2 * sigma**2))

# Precompute coefficients for tridiagonal solver
# For implicit step in x-direction
a_x = -r / 2.0
b_x = 1 + r
c_x = -r / 2.0

# For implicit step in y-direction
a_y = -r / (2 * beta**2)
b_y = 1 + r / beta**2
c_y = -r / (2 * beta**2)

def thomas_algorithm(a, b, c, d):
    """
    Solves a tridiagonal system Ax = d
    a, b, c are the sub-diagonal, diagonal, and super-diagonal
    d is the right-hand side
    """
    n = len(d)
    c_prime = np.zeros(n-1)
    d_prime = np.zeros(n)
    
    # Forward sweep
    c_prime[0] = c[0] / b[0]
    d_prime[0] = d[0] / b[0]
    for i in range(1, n-1):
        temp = b[i] - a[i-1] * c_prime[i-1]
        c_prime[i] = c[i] / temp
        d_prime[i] = (d[i] - a[i-1] * d_prime[i-1]) / temp
    d_prime[n-1] = (d[n-1] - a[n-2] * d_prime[n-2]) / (b[n-1] - a[n-2] * c_prime[n-2])
    
    # Back substitution
    x = np.zeros(n)
    x[-1] = d_prime[-1]
    for i in range(n-2, -1, -1):
        x[i] = d_prime[i] - c_prime[i] * x[i+1]
    return x

# Time-stepping loop
for n_step in range(nt):
    # First half-step: implicit in x, explicit in y
    T_half = np.copy(T)
    for j in range(1, ny-1):
        # Construct RHS
        RHS = (r/2.0) * T[1:-1, j+1] + (1 - r) * T[1:-1, j] + (r/2.0) * T[1:-1, j-1] + (dt/2.0) * q[1:-1, j]
        
        # Apply boundary conditions (T=0 at boundaries)
        RHS[0] += (r/2.0) * 0.0
        RHS[-1] += (r/2.0) * 0.0
        
        # Solve tridiagonal system
        T_half[1:-1, j] = thomas_algorithm(a_x*np.ones(nx-2), b_x*np.ones(nx-2), c_x*np.ones(nx-2), RHS)
    
    # Apply boundary conditions
    T_half[0, :] = 0.0
    T_half[-1, :] = 0.0
    T_half[:, 0] = 0.0
    T_half[:, -1] = 0.0
    
    # Second half-step: implicit in y, explicit in x
    T_new = np.copy(T_half)
    for i in range(1, nx-1):
        # Construct RHS
        RHS = (r/(2*beta**2)) * T_half[i+1, 1:-1] + (1 - r/beta**2) * T_half[i, 1:-1] + (r/(2*beta**2)) * T_half[i-1, 1:-1] + (dt/2.0) * q[i, 1:-1]
        
        # Apply boundary conditions (T=0 at boundaries)
        RHS[0] += (r/(2*beta**2)) * 0.0
        RHS[-1] += (r/(2*beta**2)) * 0.0
        
        # Solve tridiagonal system
        T_new[i,1:-1] = thomas_algorithm(a_y*np.ones(ny-2), b_y*np.ones(ny-2), c_y*np.ones(ny-2), RHS)
    
    # Apply boundary conditions
    T_new[0, :] = 0.0
    T_new[-1, :] = 0.0
    T_new[:, 0] = 0.0
    T_new[:, -1] = 0.0
    
    # Update temperature
    T = T_new.copy()

# Visualization
plt.figure(figsize=(8,6))
cp = plt.contourf(X, Y, T, 50, cmap='hot')
plt.colorbar(cp)
plt.title('Temperature Distribution at t = {:.2f} s'.format(t_max))
plt.xlabel('x')
plt.ylabel('y')
plt.show()

# Save the final temperature field
np.save('temperature_final.npy', T)
```
```python
import numpy as np

def compute_rhs(u, c, eps, dx):
    du_dx = (np.roll(u, -1) - np.roll(u, 1)) / (2 * dx)
    d2u_dx2 = (np.roll(u, -1) - 2 * u + np.roll(u, 1)) / (dx**2)
    return -c * du_dx + eps * d2u_dx2

def rk4_step(u, c, eps, dx, dt):
    k1 = compute_rhs(u, c, eps, dx)
    k2 = compute_rhs(u + 0.5 * dt * k1, c, eps, dx)
    k3 = compute_rhs(u + 0.5 * dt * k2, c, eps, dx)
    k4 = compute_rhs(u + dt * k3, c, eps, dx)
    return u + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)

def solve_pde(c, eps, x_start, x_end, N_x, t_final):
    dx = (x_end - x_start) / (N_x - 1)
    x = np.linspace(x_start, x_end, N_x)
    u = np.exp(-x**2)
    if eps > 0:
        dt = 0.4 * min(dx / c, dx**2 / (2 * eps))
    else:
        dt = 0.4 * dx / c
    t = 0.0
    while t < t_final:
        if t + dt > t_final:
            dt = t_final - t
        u = rk4_step(u, c, eps, dx, dt)
        t += dt
    return u

# Parameters
c = 1.0
x_start = -5.0
x_end = 5.0
N_x = 101
t_final = 2.0

# Solve for ε = 0 (undamped)
u0 = solve_pde(c, 0.0, x_start, x_end, N_x, t_final)

# Solve for ε = 5e-4 (damped)
u_damped = solve_pde(c, 5e-4, x_start, x_end, N_x, t_final)

# Save the final solutions
save_values = ['u0', 'u_damped']
np.save('u0.npy', u0)
np.save('u_damped.npy', u_damped)
```
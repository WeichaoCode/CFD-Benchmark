#!/usr/bin/env python3
import numpy as np

# Domain parameters
Lx = 4.0
Lz = 1.0
Nx = 128          # number of grid points in x (periodic)
Nz = 32           # number of grid points in z (non-periodic)
dx = Lx / Nx
dz = Lz / (Nz - 1)

x = np.linspace(0, Lx, Nx, endpoint=False)
z = np.linspace(0, Lz, Nz)

# Time parameters
t_end = 50.0
dt = 0.01
Nt = int(t_end / dt)

# Physical parameters
Ra = 2e6
Pr = 1.0
nu = (Ra / Pr) ** (-0.5)
kappa = (Ra * Pr) ** (-0.5)

# Initialize fields: u, w, pressure (p) and buoyancy (b)
# Using (Nz, Nx) arrays with z being the first index and x the second index.
u = np.zeros((Nz, Nx))
w = np.zeros((Nz, Nx))
p = np.zeros((Nz, Nx))

# Create buoyancy field: b = Lz - z + small random perturbation
Z = np.tile(z.reshape(Nz, 1), (1, Nx))
b = Lz - Z + 0.01 * np.random.randn(Nz, Nx)
# Impose Dirichlet BCs on buoyancy: bottom (z=0) b = Lz, top (z=Lz) b = 0.
b[0, :] = Lz
b[-1, :] = 0.0

# Time-stepping loop
for n in range(Nt):
    # Compute spatial derivatives for u, w, b
    
    # Derivatives in x (periodic boundaries)
    du_dx = (np.roll(u, -1, axis=1) - np.roll(u, 1, axis=1)) / (2 * dx)
    dw_dx = (np.roll(w, -1, axis=1) - np.roll(w, 1, axis=1)) / (2 * dx)
    db_dx = (np.roll(b, -1, axis=1) - np.roll(b, 1, axis=1)) / (2 * dx)
    
    # Derivatives in z: use central differences in interior and one-sided at boundaries
    du_dz = np.zeros_like(u)
    dw_dz = np.zeros_like(w)
    db_dz = np.zeros_like(b)
    du_dz[1:-1, :] = (u[2:, :] - u[:-2, :]) / (2 * dz)
    dw_dz[1:-1, :] = (w[2:, :] - w[:-2, :]) / (2 * dz)
    db_dz[1:-1, :] = (b[2:, :] - b[:-2, :]) / (2 * dz)
    du_dz[0, :] = (u[1, :] - u[0, :]) / dz
    du_dz[-1, :] = (u[-1, :] - u[-2, :]) / dz
    dw_dz[0, :] = (w[1, :] - w[0, :]) / dz
    dw_dz[-1, :] = (w[-1, :] - w[-2, :]) / dz
    db_dz[0, :] = (b[1, :] - b[0, :]) / dz
    db_dz[-1, :] = (b[-1, :] - b[-2, :]) / dz

    # Laplacians for u, w, b
    lap_u = (np.roll(u, -1, axis=1) - 2 * u + np.roll(u, 1, axis=1)) / dx**2
    lap_w = (np.roll(w, -1, axis=1) - 2 * w + np.roll(w, 1, axis=1)) / dx**2
    lap_b = (np.roll(b, -1, axis=1) - 2 * b + np.roll(b, 1, axis=1)) / dx**2
    # Add second derivatives in z (for interior points)
    lap_u[1:-1, :] += (u[2:, :] - 2 * u[1:-1, :] + u[:-2, :]) / dz**2
    lap_w[1:-1, :] += (w[2:, :] - 2 * w[1:-1, :] + w[:-2, :]) / dz**2
    lap_b[1:-1, :] += (b[2:, :] - 2 * b[1:-1, :] + b[:-2, :]) / dz**2

    # Compute nonlinear (advection) terms
    conv_u = u * du_dx + w * du_dz
    conv_w = u * dw_dx + w * dw_dz
    conv_b = u * db_dx + w * db_dz

    # Step 1: Compute intermediate velocity (u*, w*) and buoyancy (b_new)
    u_star = u + dt * (-conv_u + nu * lap_u)
    w_star = w + dt * (-conv_w + nu * lap_w + b)
    b_new = b + dt * (-conv_b + kappa * lap_b)
    
    # Impose buoyancy BCs (Dirichlet in z)
    b_new[0, :] = Lz
    b_new[-1, :] = 0.0
    # Impose velocity BCs on intermediate velocities at top and bottom (no-slip)
    u_star[0, :] = 0.0
    u_star[-1, :] = 0.0
    w_star[0, :] = 0.0
    w_star[-1, :] = 0.0

    # Step 2: Solve pressure Poisson equation for correction potential φ
    # The Poisson equation: ∇²φ = (1/dt) ∇·(u_star)
    div_u_star = (np.roll(u_star, -1, axis=1) - np.roll(u_star, 1, axis=1)) / (2 * dx)
    temp = np.zeros_like(w_star)
    temp[1:-1, :] = (w_star[2:, :] - w_star[:-2, :]) / (2 * dz)
    temp[0, :] = (w_star[1, :] - w_star[0, :]) / dz
    temp[-1, :] = (w_star[-1, :] - w_star[-2, :]) / dz
    div_u_star += temp
    rhs = div_u_star / dt

    # Initialize φ and solve using Jacobi iterations
    phi = np.zeros_like(p)
    tol = 1e-4
    max_iter = 1000
    for it in range(max_iter):
        phi_old = phi.copy()
        # Update interior points (i=1...Nz-2, j=1...Nx-1; note periodic in x so treat j=0 and j=Nx-1 carefully)
        phi[1:-1, 1:-1] = (((phi_old[1:-1, 2:] + phi_old[1:-1, 0:-2]) * dz**2 + 
                            (phi_old[2:, 1:-1] + phi_old[0:-2, 1:-1]) * dx**2 - 
                            rhs[1:-1, 1:-1] * dx**2 * dz**2) / (2 * (dx**2 + dz**2)))
        # Periodic boundaries in x for interior z
        phi[1:-1, 0] = (((phi_old[1:-1, 1] + phi_old[1:-1, -2]) * dz**2 +
                         (phi_old[2:, 0] + phi_old[0:-2, 0]) * dx**2 - 
                         rhs[1:-1, 0] * dx**2 * dz**2) / (2 * (dx**2 + dz**2)))
        phi[1:-1, -1] = phi[1:-1, 0]
        # Neumann BCs in z (dφ/dz = 0) at top and bottom
        phi[0, :] = phi[1, :]
        phi[-1, :] = phi[-2, :]
        err = np.linalg.norm(phi - phi_old, ord=2)
        if err < tol:
            break

    # Step 3: Correct the velocities using the gradient of φ
    # Compute gradients of φ
    phi_x = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2 * dx)
    phi_z = np.zeros_like(phi)
    phi_z[1:-1, :] = (phi[2:, :] - phi[:-2, :]) / (2 * dz)
    phi_z[0, :] = (phi[1, :] - phi[0, :]) / dz
    phi_z[-1, :] = (phi[-1, :] - phi[-2, :]) / dz
    
    u = u_star - dt * phi_x
    w = w_star - dt * phi_z
    p = phi.copy()

    # Enforce no-slip velocity BCs in z after correction
    u[0, :] = 0.0
    u[-1, :] = 0.0
    w[0, :] = 0.0
    w[-1, :] = 0.0

    # Update buoyancy field
    b = b_new.copy()

# Save final solution fields as .npy files (2D arrays)
np.save("u.npy", u)
np.save("w.npy", w)
np.save("p.npy", p)
np.save("b.npy", b)
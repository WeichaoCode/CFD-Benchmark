#!/usr/bin/env python3
import numpy as np

# Parameters
nx = 41
ny = 41
lx = 2.0
ly = 2.0
dx = lx / (nx - 1)
dy = ly / (ny - 1)
nt = 5000         # number of time steps (t in [0,5.0] with dt=0.001)
dt = 0.001
rho = 1.0
nu = 0.1
F = 1.0
nit = 50        # number of iterations for pressure Poisson solve per time step

# Create grid
x = np.linspace(0, lx, nx)
y = np.linspace(0, ly, ny)

# Initialize fields: shape=(ny, nx) with y index as rows, x index as columns.
u = np.zeros((ny, nx))
v = np.zeros((ny, nx))
p = np.zeros((ny, nx))

for n in range(nt):
    un = u.copy()
    vn = v.copy()
    pn = p.copy()
    
    # Compute derivatives for u and v (using periodic in x and central differences in y for interior)
    u_x = (np.roll(un, -1, axis=1) - np.roll(un, 1, axis=1)) / (2*dx)
    u_y = np.zeros_like(un)
    u_y[1:-1, :] = (un[2:, :] - un[:-2, :]) / (2*dy)
    
    v_x = (np.roll(vn, -1, axis=1) - np.roll(vn, 1, axis=1)) / (2*dx)
    v_y = np.zeros_like(vn)
    v_y[1:-1, :] = (vn[2:, :] - vn[:-2, :]) / (2*dy)
    
    u_xx = (np.roll(un, -1, axis=1) - 2*un + np.roll(un, 1, axis=1)) / (dx**2)
    u_yy = np.zeros_like(un)
    u_yy[1:-1, :] = (un[2:, :] - 2*un[1:-1, :] + un[:-2, :]) / (dy**2)
    
    v_xx = (np.roll(vn, -1, axis=1) - 2*vn + np.roll(vn, 1, axis=1)) / (dx**2)
    v_yy = np.zeros_like(vn)
    v_yy[1:-1, :] = (vn[2:, :] - 2*vn[1:-1, :] + vn[:-2, :]) / (dy**2)
    
    # Compute pressure gradients (using periodicity in x and central differences in y for interior)
    p_x = (np.roll(pn, -1, axis=1) - np.roll(pn, 1, axis=1)) / (2*dx)
    p_y = np.zeros_like(pn)
    p_y[1:-1, :] = (pn[2:, :] - pn[:-2, :]) / (2*dy)
    
    # Update u and v for interior points (y-direction: indices 1 to ny-2; x is periodic)
    u[1:-1, :] = un[1:-1, :] + dt * (
                - un[1:-1, :] * u_x[1:-1, :] - vn[1:-1, :] * u_y[1:-1, :]
                - p_x[1:-1, :] + nu * (u_xx[1:-1, :] + u_yy[1:-1, :])
                + F)
    
    v[1:-1, :] = vn[1:-1, :] + dt * (
                - un[1:-1, :] * v_x[1:-1, :] - vn[1:-1, :] * v_y[1:-1, :]
                - p_y[1:-1, :] + nu * (v_xx[1:-1, :] + v_yy[1:-1, :]))
    
    # Enforce no-slip boundary conditions in y for u and v
    u[0, :] = 0.0
    u[-1, :] = 0.0
    v[0, :] = 0.0
    v[-1, :] = 0.0

    # Pressure Poisson Equation
    # Compute RHS for pressure Poisson: -[u_x^2 + 2 u_y v_x + v_y^2]
    u_x_p = (np.roll(u, -1, axis=1) - np.roll(u, 1, axis=1)) / (2*dx)
    u_y_p = np.zeros_like(u)
    u_y_p[1:-1, :] = (u[2:, :] - u[:-2, :]) / (2*dy)
    
    v_x_p = (np.roll(v, -1, axis=1) - np.roll(v, 1, axis=1)) / (2*dx)
    v_y_p = np.zeros_like(v)
    v_y_p[1:-1, :] = (v[2:, :] - v[:-2, :]) / (2*dy)
    
    rhs = - (u_x_p**2 + 2*u_y_p*v_x_p + v_y_p**2)
    
    # Iterative solver for pressure Poisson equation
    pn = p.copy()
    for it in range(nit):
        p_old = pn.copy()
        pn[1:-1, 1:-1] = (((p_old[1:-1, 2:] + p_old[1:-1, 0:-2]) * dy**2 +
                           (p_old[2:, 1:-1] + p_old[0:-2, 1:-1]) * dx**2
                          - rhs[1:-1, 1:-1] * dx**2 * dy**2)
                          / (2*(dx**2 + dy**2)))
        # Periodic boundary conditions in x for pressure
        pn[1:-1, 0] = pn[1:-1, -2]
        pn[1:-1, -1] = pn[1:-1, 1]
        # Neumann boundary conditions in y: dp/dy = 0 --> p[0,:] = p[1,:], p[-1,:] = p[-2,:]
        pn[0, :] = pn[1, :]
        pn[-1, :] = pn[-2, :]
    p = pn.copy()
    
    # Enforce periodicity in x for pressure explicitly
    p[:, 0] = p[:, -2]
    p[:, -1] = p[:, 1]

# Save final fields to .npy files
np.save("u.npy", u)
np.save("v.npy", v)
np.save("p.npy", p)
```python
import numpy as np
import math

# Parameters
L = 2 * np.pi
nu = 0.5
dt = 0.01
T = 500

# Calculate dx based on dt and nu
dx = dt / nu

# Discretize the spatial domain
x = np.linspace(0, L, math.ceil(L / dx))
nx = len(x)

# Initial condition
u = np.sin(x) + 0.5 * np.sin(0.5 * x)

# MacCormack method
for n in range(T):
    # Predictor step
    u_star = np.empty_like(u)
    for j in range(nx - 1):
        u_star[j] = u[j] - dt / dx * (0.5 * u[j+1]**2 - 0.5 * u[j]**2)
    u_star[-1] = u[-1] - dt / dx * (0.5 * u[0]**2 - 0.5 * u[-1]**2)  # Periodic BC

    # Corrector step
    u_new = np.empty_like(u)
    for j in range(1, nx):
        u_new[j] = 0.5 * (u[j] + u_star[j] - dt / dx * (0.5 * u_star[j]**2 - 0.5 * u_star[j-1]**2))
    u_new[0] = 0.5 * (u[0] + u_star[0] - dt / dx * (0.5 * u_star[0]**2 - 0.5 * u_star[-1]**2))  # Periodic BC

    # Update solution
    u = u_new

# Save the final solution
np.save('u_final.npy', u)
```

This code implements the MacCormack method to solve the given PDE with periodic boundary conditions. The solution is computed over 500 time steps, and the final state of the wave amplitude `u` is saved in a `.npy` file named `u_final.npy`. The spatial domain is discretized based on the given parameters, and the periodic boundary conditions are applied at each time step.
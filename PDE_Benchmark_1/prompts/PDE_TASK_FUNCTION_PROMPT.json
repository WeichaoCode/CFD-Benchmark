{
    "prompts": {
        "1D_Linear_Convection": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **1D Linear Convection**:\n    \n        \u2202u/\u2202t + c \u2202u/\u2202x = f(x, t)\n    \n    where:\n    - The primary variable(s) are **u, c, x, t, f**, which are passed as function arguments.\n    - The source term(s) **f** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, t) = exp(-t) * sin(\u03c0x)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_1d_linear_convection`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_1d_linear_convection(u, c, x, t, f):\n        \"\"\"\n        Solves the 1D Linear Convection using a numerical method.\n    \n        Parameters:\n            u, c, x, t, f: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "1D_Nonlinear_Convection": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **1D Nonlinear Convection**:\n    \n        \u2202u/\u2202t + u \u2202u/\u2202x = f(x, t)\n    \n    where:\n    - The primary variable(s) are **u, x, t, f**, which are passed as function arguments.\n    - The source term(s) **f** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, t) = exp(-t) * sin(\u03c0x)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_1d_nonlinear_convection`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_1d_nonlinear_convection(u, x, t, f):\n        \"\"\"\n        Solves the 1D Nonlinear Convection using a numerical method.\n    \n        Parameters:\n            u, x, t, f: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "1D_Burgers_Equation": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **1D Burgers Equation**:\n    \n        \u2202u/\u2202t + u \u2202u/\u2202x = \u03bd \u2202\u00b2u/\u2202x\u00b2 + f(x, t)\n    \n    where:\n    - The primary variable(s) are **u, \u03bd, x, t, f**, which are passed as function arguments.\n    - The source term(s) **f** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, t) = exp(-t) * sin(\u03c0x)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_1d_burgers_equation`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_1d_burgers_equation(u, \u03bd, x, t, f):\n        \"\"\"\n        Solves the 1D Burgers Equation using a numerical method.\n    \n        Parameters:\n            u, \u03bd, x, t, f: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "1D_Diffusion": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **1D Diffusion**:\n    \n        \u2202u/\u2202t = \u03bd \u2202\u00b2u/\u2202x\u00b2 + f(x, t)\n    \n    where:\n    - The primary variable(s) are **u, \u03bd, x, t, f**, which are passed as function arguments.\n    - The source term(s) **f** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, t) = exp(-t) * sin(\u03c0x)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_1d_diffusion`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_1d_diffusion(u, \u03bd, x, t, f):\n        \"\"\"\n        Solves the 1D Diffusion using a numerical method.\n    \n        Parameters:\n            u, \u03bd, x, t, f: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "1D_Wave_Equation": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **1D Wave Equation**:\n    \n        \u2202\u00b2u/\u2202t\u00b2 = c\u00b2 \u2202\u00b2u/\u2202x\u00b2 + f(x, t)\n    \n    where:\n    - The primary variable(s) are **u, c, x, t, f**, which are passed as function arguments.\n    - The source term(s) **f** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, t) = exp(-t) * sin(\u03c0x) * cos(t)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_1d_wave_equation`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_1d_wave_equation(u, c, x, t, f):\n        \"\"\"\n        Solves the 1D Wave Equation using a numerical method.\n    \n        Parameters:\n            u, c, x, t, f: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "1D_Euler_Equations": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **1D Euler Equations**:\n    \n        \u2202\u03c1/\u2202t + \u2202(\u03c1u)/\u2202x = 0, \u2202(\u03c1u)/\u2202t + \u2202(\u03c1u\u00b2 + p)/\u2202x = 0, \u2202E/\u2202t + \u2202((E + p)u)/\u2202x = 0\n    \n    where:\n    - The primary variable(s) are **\u03c1, u, p, E, x, t**, which are passed as function arguments.\n    - The source term(s) **** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        \u03c1(x, t) = exp(-t) * sin(\u03c0x), u(x, t) = exp(-t) * cos(\u03c0x), p(x, t) = exp(-t) * (1 + sin(\u03c0x))\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_1d_euler_equations`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_1d_euler_equations(\u03c1, u, p, E, x, t):\n        \"\"\"\n        Solves the 1D Euler Equations using a numerical method.\n    \n        Parameters:\n            \u03c1, u, p, E, x, t: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "1D_Kuramoto_Sivashinsky": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **1D Kuramoto Sivashinsky**:\n    \n        \u2202u/\u2202t + \u2202\u00b2u/\u2202x\u00b2 + \u2202\u2074u/\u2202x\u2074 + (1/2)(\u2202u/\u2202x)\u00b2 = f(x, t)\n    \n    where:\n    - The primary variable(s) are **u, x, t, f**, which are passed as function arguments.\n    - The source term(s) **f** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, t) = exp(-t) * sin(\u03c0x)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_1d_kuramoto_sivashinsky`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_1d_kuramoto_sivashinsky(u, x, t, f):\n        \"\"\"\n        Solves the 1D Kuramoto Sivashinsky using a numerical method.\n    \n        Parameters:\n            u, x, t, f: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "1D_Korteweg_de_Vries": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **1D Korteweg de Vries**:\n    \n        \u2202u/\u2202t + 6u \u2202u/\u2202x + \u2202\u00b3u/\u2202x\u00b3 = f(x, t)\n    \n    where:\n    - The primary variable(s) are **u, x, t, f**, which are passed as function arguments.\n    - The source term(s) **f** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, t) = exp(-t) * sin(\u03c0x)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_1d_korteweg_de_vries`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_1d_korteweg_de_vries(u, x, t, f):\n        \"\"\"\n        Solves the 1D Korteweg de Vries using a numerical method.\n    \n        Parameters:\n            u, x, t, f: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "2D_Linear_Convection": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **2D Linear Convection**:\n    \n        \u2202u/\u2202t + c_x \u2202u/\u2202x + c_y \u2202u/\u2202y = f(x, y, t)\n    \n    where:\n    - The primary variable(s) are **u, c_x, c_y, x, y, t, f**, which are passed as function arguments.\n    - The source term(s) **f** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_2d_linear_convection`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_2d_linear_convection(u, c_x, c_y, x, y, t, f):\n        \"\"\"\n        Solves the 2D Linear Convection using a numerical method.\n    \n        Parameters:\n            u, c_x, c_y, x, y, t, f: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "2D_Nonlinear_Convection": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **2D Nonlinear Convection**:\n    \n        \u2202u/\u2202t + u \u2202u/\u2202x + v \u2202u/\u2202y = f(x, y, t), \u2202v/\u2202t + u \u2202v/\u2202x + v \u2202v/\u2202y = f_v(x, y, t)\n    \n    where:\n    - The primary variable(s) are **u, v, x, y, t, f, f_v**, which are passed as function arguments.\n    - The source term(s) **f, f_v** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y), v(x, y, t) = exp(-t) * cos(\u03c0x) * cos(\u03c0y)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_2d_nonlinear_convection`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_2d_nonlinear_convection(u, v, x, y, t, f, f_v):\n        \"\"\"\n        Solves the 2D Nonlinear Convection using a numerical method.\n    \n        Parameters:\n            u, v, x, y, t, f, f_v: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "2D_Burgers_Equation": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **2D Burgers Equation**:\n    \n        \u2202u/\u2202t + u \u2202u/\u2202x + v \u2202u/\u2202y = \u03bd (\u2202\u00b2u/\u2202x\u00b2 + \u2202\u00b2u/\u2202y\u00b2) + f_u(x, y, t), \u2202v/\u2202t + u \u2202v/\u2202x + v \u2202v/\u2202y = \u03bd (\u2202\u00b2v/\u2202x\u00b2 + \u2202\u00b2v/\u2202y\u00b2) + f_v(x, y, t)\n    \n    where:\n    - The primary variable(s) are **u, v, \u03bd, x, y, t, f_u, f_v**, which are passed as function arguments.\n    - The source term(s) **f_u, f_v** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y), v(x, y, t) = exp(-t) * cos(\u03c0x) * cos(\u03c0y)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_2d_burgers_equation`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_2d_burgers_equation(u, v, \u03bd, x, y, t, f_u, f_v):\n        \"\"\"\n        Solves the 2D Burgers Equation using a numerical method.\n    \n        Parameters:\n            u, v, \u03bd, x, y, t, f_u, f_v: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "2D_Diffusion": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **2D Diffusion**:\n    \n        \u2202u/\u2202t = \u03b1 (\u2202\u00b2u/\u2202x\u00b2 + \u2202\u00b2u/\u2202y\u00b2) + f(x, y, t)\n    \n    where:\n    - The primary variable(s) are **u, \u03b1, x, y, t, f**, which are passed as function arguments.\n    - The source term(s) **f** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_2d_diffusion`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_2d_diffusion(u, \u03b1, x, y, t, f):\n        \"\"\"\n        Solves the 2D Diffusion using a numerical method.\n    \n        Parameters:\n            u, \u03b1, x, y, t, f: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "2D_Wave_Equation": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **2D Wave Equation**:\n    \n        \u2202\u00b2u/\u2202t\u00b2 = c\u00b2 (\u2202\u00b2u/\u2202x\u00b2 + \u2202\u00b2u/\u2202y\u00b2) + f(x, y, t)\n    \n    where:\n    - The primary variable(s) are **u, c, x, y, t, f**, which are passed as function arguments.\n    - The source term(s) **f** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y) * cos(t)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_2d_wave_equation`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_2d_wave_equation(u, c, x, y, t, f):\n        \"\"\"\n        Solves the 2D Wave Equation using a numerical method.\n    \n        Parameters:\n            u, c, x, y, t, f: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "2D_Euler_Equations": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **2D Euler Equations**:\n    \n        \u2202\u03c1/\u2202t + \u2202(\u03c1u)/\u2202x + \u2202(\u03c1v)/\u2202y = 0, \u2202(\u03c1u)/\u2202t + \u2202(\u03c1u\u00b2 + p)/\u2202x + \u2202(\u03c1uv)/\u2202y = 0, \u2202(\u03c1v)/\u2202t + \u2202(\u03c1uv)/\u2202x + \u2202(\u03c1v\u00b2 + p)/\u2202y = 0, \u2202E/\u2202t + \u2202((E + p)u)/\u2202x + \u2202((E + p)v)/\u2202y = 0\n    \n    where:\n    - The primary variable(s) are **\u03c1, u, v, p, E, x, y, t**, which are passed as function arguments.\n    - The source term(s) **** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        \u03c1(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y), u(x, y, t) = exp(-t) * sin(\u03c0x) * cos(\u03c0y), v(x, y, t) = exp(-t) * cos(\u03c0x) * sin(\u03c0y), p(x, y, t) = exp(-t) * (1 + sin(\u03c0x) * sin(\u03c0y))\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_2d_euler_equations`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_2d_euler_equations(\u03c1, u, v, p, E, x, y, t):\n        \"\"\"\n        Solves the 2D Euler Equations using a numerical method.\n    \n        Parameters:\n            \u03c1, u, v, p, E, x, y, t: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    ",
        "2D_Navier_Stokes": "\n    You are an expert in **Computational Fluid Dynamics (CFD)** and **Numerical Methods**. Your task is to write a **Python function** to solve the given PDE using a suitable numerical scheme.\n    \n    \ud83d\udccc **DO NOT include any input/output handling, function calls, or explanations.**  \n    \ud83d\udccc **Only write a single function definition, which users will call externally.**  \n    \ud83d\udccc **The function should take numerical parameters as arguments and return the computed solution.**  \n    \n    ---\n    \n    ### **1\ufe0f\u20e3 PDE Definition**\n    Write a function to solve the **2D Navier Stokes**:\n    \n        \u2202u/\u2202t + u \u2202u/\u2202x + v \u2202u/\u2202y = -1/\u03c1 \u2202p/\u2202x + \u03bd (\u2202\u00b2u/\u2202x\u00b2 + \u2202\u00b2u/\u2202y\u00b2), \u2202v/\u2202t + u \u2202v/\u2202x + v \u2202v/\u2202y = -1/\u03c1 \u2202p/\u2202y + \u03bd (\u2202\u00b2v/\u2202x\u00b2 + \u2202\u00b2v/\u2202y\u00b2), \u2202\u00b2p/\u2202x\u00b2 + \u2202\u00b2p/\u2202y\u00b2 = -\u03c1 (\u2202u/\u2202x \u2202u/\u2202x + 2 \u2202u/\u2202y \u2202v/\u2202x + \u2202v/\u2202y \u2202v/\u2202y)\n    \n    where:\n    - The primary variable(s) are **u, v, p, \u03bd, \u03c1, x, y, t**, which are passed as function arguments.\n    - The source term(s) **** are derived from the **Manufactured Solution (MMS)**.\n    \n    ---\n    \n    ### **2\ufe0f\u20e3 Manufactured Solution (MMS)**\n    To validate the solver, the function should be tested using the following **MMS solution**:\n    \n        u(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y), v(x, y, t) = exp(-t) * cos(\u03c0x) * cos(\u03c0y), p(x, y, t) = exp(-t) * cos(\u03c0x) * cos(\u03c0y)\n    \n    Users will substitute this into the PDE externally to compute the **source terms**.\n    \n    ---\n    \n    ### **3\ufe0f\u20e3 Function Requirements**\n    - Define a **function** named `solve_2d_navier_stokes`.\n    - The function **must not** contain hardcoded values.\n    - All **parameters (e.g., u, \u03bd, x, y, t, dt, dx, dy)** must be **function arguments**.\n    - Use a **Finite Difference Method (FDM)** or another stable numerical scheme.\n    - Ensure **stability** by selecting an appropriate **time step size (CFL condition if needed)**.\n    \n    ---\n    \n    ### **4\ufe0f\u20e3 Implementation Guidelines**\n    \u2705 Define the function as:\n    ```python\n    def solve_2d_navier_stokes(u, v, p, \u03bd, \u03c1, x, y, t):\n        \"\"\"\n        Solves the 2D Navier Stokes using a numerical method.\n    \n        Parameters:\n            u, v, p, \u03bd, \u03c1, x, y, t: User-provided numerical values.\n    \n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n    5\ufe0f\u20e3 Output Requirements\n    Return only the function definition (no explanations, no function calls).\n    The function should be fully self-contained and accept all numerical parameters as arguments.\n    No test cases, input handling, or plotting\u2014users will handle testing externally.\n    "
    }
}
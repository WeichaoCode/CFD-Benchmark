Below is Python code that solves the 1D diffusion equation using a forward time/central space discretization.

```python
import numpy as np
import matplotlib.pyplot as plt

# Variable declarations
nx = 41
nt = 20
nu = 0.3
sigma = 0.2
dx = 2 / (nx - 1)
dt = sigma * dx**2 / nu

# Initialize u array
u = np.ones(nx)
u[int(0.5 / dx) : int(1 / dx + 1)] = 2

# Initialize the array for storing the solution at each time step
u_sol = np.empty((nt, nx))
u_sol[0, :] = u

# Time stepping loop
for n in range(nt - 1):
    # Central difference scheme
    u[1:-1] = u[1:-1] + nu * dt / dx**2 * (u[2:] - 2 * u[1:-1] + u[:-2])
    # Apply Dirichlet boundary conditions
    u[0] = 1; u[-1] = 0
    # Store solution
    u_sol[n + 1, :] = u

# Plot solution
for i in range(nt):
    plt.figure()
    plt.plot(np.linspace(0, 2, nx), u_sol[i, :])
    plt.title('1D Diffusion at t = {:.2f}'.format(i * dt))
    plt.xlabel('x')
    plt.ylabel('u')
    plt.grid()
    plt.show()

# Save solution
np.save('1D_diffusion_sol.npy', u_sol)
```

This script creates a series of plots for each time step, starting from the initial condition, and then evolves the diffusion process over time. The plots will show how the peak in the initial condition spreads out (diffuses) over time. The solution at each time step is also stored in the array 'u_sol', which is then saved to the file '1D_diffusion_sol.npy'. The script uses Dirichlet boundary conditions to fix the values at the ends of the domain at 1 and 0, respectively.
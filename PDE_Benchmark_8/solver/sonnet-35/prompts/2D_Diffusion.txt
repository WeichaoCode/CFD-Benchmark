```python
import numpy as np

# Domain parameters
Lx, Ly = 2.0, 2.0
nx, ny = 100, 100
nu = 1.0

# Stability-based time step calculation
dx = Lx / (nx - 1)
dy = Ly / (ny - 1)
dt = 0.25 * min(dx, dy)**2 / nu  # Ensure numerical stability

# Time parameters
t_start = 0.0
t_end = 0.3777
nt = int((t_end - t_start) / dt)

# Grid generation
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)

# Initialize solution array
u = np.ones((ny, nx), dtype=np.float64)

# Initial condition
mask_x = (x >= 0.5) & (x <= 1.0)
mask_y = (y >= 0.5) & (y <= 1.0)
u[np.ix_(mask_y, mask_x)] = 2.0

# Time-stepping using explicit finite difference method
for _ in range(nt):
    u_old = u.copy()
    
    # Compute 2D diffusion using central differences
    u[1:-1, 1:-1] = u_old[1:-1, 1:-1] + (
        nu * dt / (dx**2) * (u_old[1:-1, 2:] - 2*u_old[1:-1, 1:-1] + u_old[1:-1, :-2]) +
        nu * dt / (dy**2) * (u_old[2:, 1:-1] - 2*u_old[1:-1, 1:-1] + u_old[:-2, 1:-1])
    )
    
    # Enforce boundary conditions
    u[0, :] = 1.0
    u[-1, :] = 1.0
    u[:, 0] = 1.0
    u[:, -1] = 1.0

# Save final solution
np.save('u.npy', u)
```

Key modifications:
1. Dynamically calculate time step using the CFL-like condition for numerical stability
2. Use `0.25 * min(dx, dy)**2 / nu` to ensure the numerical scheme remains stable
3. Compute number of time steps based on the calculated stable time step
4. Kept the core numerical approach (explicit finite difference)
5. Maintained initial and boundary conditions consistent with the problem specification

The changes address the stability issue by:
- Automatically calculating a stable time step
- Ensuring the numerical scheme doesn't violate numerical stability criteria
- Adapting the number of time steps to reach the final time
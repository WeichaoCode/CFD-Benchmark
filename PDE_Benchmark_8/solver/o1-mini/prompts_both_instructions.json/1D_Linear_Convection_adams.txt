```python
import numpy as np

def solve_pde(c, epsilon, x_start, x_end, N_x, t_final):
    x = np.linspace(x_start, x_end, N_x)
    dx = x[1] - x[0]
    if epsilon > 0:
        dt = 0.4 * min(dx / c, dx**2 / (2 * epsilon))
    else:
        dt = 0.4 * (dx / c)
    N_t = int(t_final / dt)
    u = np.exp(-x**2)
    f_prev = -c * (np.roll(u, -1) - np.roll(u, 1)) / (2 * dx) + epsilon * (np.roll(u, -1) - 2 * u + np.roll(u, 1)) / dx**2
    u_new = u + dt * f_prev
    f_new = -c * (np.roll(u_new, -1) - np.roll(u_new, 1)) / (2 * dx) + epsilon * (np.roll(u_new, -1) - 2 * u_new + np.roll(u_new, 1)) / dx**2
    for _ in range(1, N_t):
        u, u_new = u_new, u + dt / 2 * (3 * f_new - f_prev)
        f_prev, f_new = f_new, -c * (np.roll(u_new, -1) - np.roll(u_new, 1)) / (2 * dx) + epsilon * (np.roll(u_new, -1) - 2 * u_new + np.roll(u_new, 1)) / dx**2
    return u_new

x_start = -5
x_end = 5
N_x = 101
t_final = 1.0
c = 1.0
save_values = ['u_undamped', 'u_damped']
epsilons = [0.0, 5e-4]

for name, eps in zip(save_values, epsilons):
    u_final = solve_pde(c, eps, x_start, x_end, N_x, t_final)
    globals()[name] = u_final
    np.save(f'{name}.npy', globals()[name])
```
#!/usr/bin/env python3
import numpy as np

# Domain parameters
Lx = 5.0  # domain width in x
Ly = 4.0  # domain height in y

# Number of grid points
nx = 101  # number of points in x
ny = 81   # number of points in y

dx = Lx / (nx - 1)
dy = Ly / (ny - 1)

# Create grid (not explicitly used but for clarity)
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)

# Initialize temperature field: shape (ny, nx) where y=0 corresponds to the bottom boundary
T = np.zeros((ny, nx), dtype=np.float64)

# Apply boundary conditions:
# Left boundary (x = 0): T = 10째C
T[:, 0] = 10.0
# Right boundary (x = 5): T = 40째C
T[:, -1] = 40.0
# Bottom boundary (y = 0): T = 20째C
T[0, :] = 20.0
# Top boundary (y = 4): T = 0째C
T[-1, :] = 0.0

# Iterative solver parameters
tol = 1e-6
max_iter = 10000
T_new = T.copy()

# Use the finite difference approximation for Laplace's equation
for it in range(max_iter):
    T_old = T_new.copy()
    # Update interior points using the Jacobi method
    # Note: The update uses the average of four neighbours
    T_new[1:-1, 1:-1] = 0.25 * (T_old[1:-1, 2:] + T_old[1:-1, 0:-2] +
                                T_old[2:, 1:-1] + T_old[0:-2, 1:-1])
    
    # Reapply boundary conditions (they remain fixed)
    T_new[:, 0] = 10.0      # left
    T_new[:, -1] = 40.0     # right
    T_new[0, :] = 20.0      # bottom
    T_new[-1, :] = 0.0      # top
    
    # Check for convergence
    diff = np.max(np.abs(T_new - T_old))
    if diff < tol:
        break

# Save the final temperature field as a 2D numpy array in "T.npy"
np.save("T.npy", T_new)
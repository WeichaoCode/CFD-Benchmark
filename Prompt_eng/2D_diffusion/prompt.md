prompt: \
``you know, use a prompt to directly ask LLM to generate a code to solve CFD problems, is difficult, how can
I design prompt to guide LLM to better perform it, think about prompt engineering`` \
output: 
```You're absolutely right! Directly asking an LLM to generate a CFD solver using Finite Difference Methods (FDM) is challenging because it involves:
✔ Selecting the right numerical scheme for stability.
✔ Ensuring boundary conditions are properly enforced.
✔ Implementing efficient and stable time integration.
✔ Handling implicit/explicit schemes and matrix solvers.

🔹 How to Improve LLM Performance?
We can break down the problem into steps and guide the LLM incrementally using prompt engineering techniques.
🚀 Step 1: Structured Multi-Step Prompt
Instead of a single request, we can use a step-by-step structured prompt.

🔹 Optimized Prompt for LLM
```
You are an expert in computational fluid dynamics (CFD) and numerical methods. Your task is to generate a **Python solver** for the given PDE using the **Finite Difference Method (FDM)**.

---

### **1️⃣ Problem Definition**
Solve the following **PDE**:

    ∂u/∂t = ν (∂²u/∂x² + ∂²u/∂y²) + f(x, y, t)

where:
- \( u(x, y, t) \) represents temperature.
- \( \nu = 0.05 \) is the diffusion coefficient.
- \( f(x, y, t) \) is a source term derived from the **Manufactured Solution (MMS)**.

### **2️⃣ Manufactured Solution (MMS)**
To validate the solver, use the following exact solution:

    u(x, y, t) = exp(-t) * sin(pi * x) * sin(pi * y)

From this, compute the **source term** \( f(x, y, t) \) by substituting the MMS into the PDE.

### **3️⃣ Discretization Strategy**
- Use the **Finite Difference Method (FDM)** to discretize space and time.
- Choose an **appropriate numerical scheme** for stability:
    - **Explicit (Forward Euler)**
    - **Implicit (Backward Euler, Crank-Nicolson)**
- Ensure **CFL stability condition** is satisfied:  
    \( dt ≤ min(dx², dy²) / (4ν) \)

### **4️⃣ Implementation Guidelines**
- Write a **fully functional Python script** using **NumPy and SciPy**.
- Solve the PDE using **appropriate sparse matrix methods** if implicit.
- Implement **Dirichlet boundary conditions from MMS**.
- Compute and visualize:
    1. The **numerical solution**.
    2. The **MMS (exact) solution**.
    3. The **absolute error** \( |u - u_{MMS}| \).

---

### **5️⃣ Step-by-Step Breakdown**
Before generating the final solver, follow this step-by-step approach:

1️⃣ **Step 1**: Compute the **source term** \( f(x, y, t) \) from MMS.  
2️⃣ **Step 2**: Discretize the PDE using the **chosen FDM scheme**.  
3️⃣ **Step 3**: Construct the **numerical solver**.  
4️⃣ **Step 4**: Enforce **boundary and initial conditions**.  
5️⃣ **Step 5**: Implement **numerical stability checks**.  
6️⃣ **Step 6**: Solve the system and visualize results.  

---

### **6️⃣ Output Requirements**
- Return **only the Python code** (do not explain it).
- Ensure the code is **commented for clarity**.
```
🔹 Why This Prompt Works?
✔ Breaks down the problem into smaller, manageable steps.
✔ Guides LLM to choose an appropriate FDM scheme (explicit/implicit).
✔ Explicitly asks for stability enforcement (CFL condition).
✔ Uses MMS validation to check correctness.
✔ Encourages structured output (Python code only).
```
The generate code is:
```python
"""
2D Diffusion Equation Solver using FDM and MMS (Stable)
---------------------------------------------------------------
- PDE: ∂u/∂t = ν (∂²u/∂x² + ∂²u/∂y²) + f(x, y, t)
- Finite Difference Method (Crank-Nicolson Scheme for Stability)
- CFL condition enforced for numerical stability
- Dirichlet boundary conditions from MMS
---------------------------------------------------------------
Author: Generated by LLM
Date: 2025/03/01
---------------------------------------------------------------
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

# ---------------- PARAMETERS ----------------
Lx, Ly = 1.0, 1.0  # Domain size
T = 2.0  # Final time
ν = 0.05  # Diffusion coefficient

# Grid resolution (chosen for stability)
nx, ny = 50, 50  # Grid points
nt = 500  # Time steps

dx = Lx / (nx - 1)
dy = Ly / (ny - 1)
dt = T / (nt - 1)

# CFL condition check for stability
dt_max = min(dx ** 2, dy ** 2) / (4 * ν)
if dt > dt_max:
    print(f"Reducing dt from {dt:.6f} to {dt_max:.6f} for stability.")
    dt = dt_max

# Define spatial and temporal grids
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)
t = np.linspace(0, T, nt)
X, Y = np.meshgrid(x, y, indexing="ij")  # 2D grid

# ---------------- MMS Solution ----------------
def mms_solution(x_f, y_f, t_f):
    return np.exp(-t_f) * np.sin(np.pi * x_f) * np.sin(np.pi * y_f)

# ---------------- Source Term Computation ----------------
def f_source(x_f, y_f, t_f):
    return (ν * 2 * np.pi ** 2 - 1) * np.exp(-t_f) * np.sin(np.pi * x_f) * np.sin(np.pi * y_f)

# ---------------- INITIAL AND BOUNDARY CONDITIONS FROM MMS ----------------
u = np.zeros((nx, ny, nt))  # Store full time history
u[:, :, 0] = mms_solution(X, Y, t[0])  # Initial condition

# Crank-Nicolson Coefficients
αx = ν * dt / (2 * dx ** 2)
αy = ν * dt / (2 * dy ** 2)

# Construct Sparse Matrices for Implicit Solver
main_diag = (1 + 2 * αx + 2 * αy) * np.ones(nx * ny)
off_diag_x = -αx * np.ones(nx * ny - 1)
off_diag_y = -αy * np.ones(nx * ny - nx)

# Apply boundary conditions (Dirichlet)
for i in range(nx):
    for j in range(ny):
        if i == 0 or i == nx - 1 or j == 0 or j == ny - 1:
            main_diag[i * ny + j] = 1
            off_diag_x[i * ny + j - 1] = 0
            off_diag_y[i * ny + j - nx] = 0

# Assemble sparse matrix
A = diags([off_diag_y, off_diag_x, main_diag, off_diag_x, off_diag_y], [-nx, -1, 0, 1, nx], format="csr")

# ---------------- SOLVING USING FINITE DIFFERENCE (Crank-Nicolson) ----------------
for n in range(nt - 1):
    f_t = f_source(X, Y, t[n])  # Compute source term at current time step
    u_old = u[:, :, n].flatten()
    b = u_old + dt * f_t.flatten()  # Right-hand side

    # Apply Dirichlet Boundary Conditions from MMS at the new time step
    u_new = np.copy(u[:, :, n])
    u_new[0, :] = mms_solution(x[0], y, t[n + 1])  # x = 0
    u_new[-1, :] = mms_solution(x[-1], y, t[n + 1])  # x = Lx
    u_new[:, 0] = mms_solution(x, y[0], t[n + 1])  # y = 0
    u_new[:, -1] = mms_solution(x, y[-1], t[n + 1])  # y = Ly

    # Solve the system of equations
    u_flat = spsolve(A, b)

    # Reshape back to 2D
    u[:, :, n + 1] = u_flat.reshape((nx, ny))

# ---------------- COMPUTE EXACT SOLUTION FOR COMPARISON ----------------
u_exact = np.zeros((nx, ny, nt))
for n in range(nt):
    u_exact[:, :, n] = mms_solution(X, Y, t[n])

# ---------------- ERROR ANALYSIS ----------------
error = np.abs(u - u_exact)

# ---------------- PLOTTING RESULTS ----------------
fig, axes = plt.subplots(1, 3, figsize=(18, 5))

# Numerical solution at final time step
ax1 = axes[0]
c1 = ax1.contourf(X, Y, u[:, :, -1], cmap="viridis")
plt.colorbar(c1, ax=ax1)
ax1.set_title("Numerical Solution at t = T")
ax1.set_xlabel("x")
ax1.set_ylabel("y")

# MMS (exact) solution at final time step
ax2 = axes[1]
c2 = ax2.contourf(X, Y, u_exact[:, :, -1], cmap="viridis")
plt.colorbar(c2, ax=ax2)
ax2.set_title("MMS (Exact) Solution at t = T")
ax2.set_xlabel("x")
ax2.set_ylabel("y")

# Absolute Error at final time step
ax3 = axes[2]
c3 = ax3.contourf(X, Y, error[:, :, -1], cmap="inferno")  # Using 'inferno' to highlight errors
plt.colorbar(c3, ax=ax3)
ax3.set_title("Absolute Error |u - MMS| at t = T")
ax3.set_xlabel("x")
ax3.set_ylabel("y")

plt.suptitle(f"Comparison at t = {T}", fontsize=14)
plt.tight_layout()
plt.show()
```
The solution is unstable. Then need to improve the solution, the idea is using RAG, let's first try something easy, just
ask LLM to search how to solve 2D diffusion equation. \
prompt: 
```
ok, we do not use RAG now, the code you write is still unstable, can you search the website and find some python code for 2D diffusion
```
output:
```
I understand your concern regarding the stability of the previously provided code for solving the 2D diffusion equation. To address this, I've researched stable numerical methods and found that the Alternating Direction Implicit (ADI) method is particularly effective for such problems. The ADI method is unconditionally stable and efficiently handles the implicit nature of the diffusion equation by splitting it into simpler one-dimensional problems.

Below is a Python implementation of the 2D diffusion equation solver using the ADI method:
```
```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
Lx, Ly = 1.0, 1.0  # Domain size
T = 0.1            # Total time
alpha = 0.05       # Diffusion coefficient

# Discretization
nx, ny = 50, 50    # Number of grid points
dx = Lx / (nx - 1)
dy = Ly / (ny - 1)
dt = 0.0005        # Time step

# Stability condition for ADI method
sigma_x = alpha * dt / (2 * dx**2)
sigma_y = alpha * dt / (2 * dy**2)

# Grid
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)
X, Y = np.meshgrid(x, y, indexing='ij')

# Initial condition: u(x, y, 0) = sin(pi * x) * sin(pi * y)
u = np.sin(np.pi * X) * np.sin(np.pi * Y)

# Time-stepping loop
nt = int(T / dt)
for n in range(nt):
    # Half step in x-direction (implicit in x, explicit in y)
    u_star = np.copy(u)
    for j in range(1, ny - 1):
        A = np.zeros((nx, nx))
        b = np.zeros(nx)
        for i in range(1, nx - 1):
            A[i, i - 1] = -sigma_x
            A[i, i] = 1 + 2 * sigma_x
            A[i, i + 1] = -sigma_x
            b[i] = (1 - 2 * sigma_y) * u[i, j] + sigma_y * (u[i, j - 1] + u[i, j + 1])
        A[0, 0] = A[-1, -1] = 1.0  # Boundary conditions
        b[0] = b[-1] = 0.0
        u_star[:, j] = np.linalg.solve(A, b)
    
    # Half step in y-direction (implicit in y, explicit in x)
    for i in range(1, nx - 1):
        A = np.zeros((ny, ny))
        b = np.zeros(ny)
        for j in range(1, ny - 1):
            A[j, j - 1] = -sigma_y
            A[j, j] = 1 + 2 * sigma_y
            A[j, j + 1] = -sigma_y
            b[j] = (1 - 2 * sigma_x) * u_star[i, j] + sigma_x * (u_star[i - 1, j] + u_star[i + 1, j])
        A[0, 0] = A[-1, -1] = 1.0  # Boundary conditions
        b[0] = b[-1] = 0.0
        u[i, :] = np.linalg.solve(A, b)

# Plotting the final solution
plt.figure(figsize=(8, 6))
plt.contourf(X, Y, u, cmap='viridis')
plt.colorbar(label='Temperature')
plt.xlabel('x')
plt.ylabel('y')
plt.title('2D Diffusion Equation Solution at t = {:.2f}'.format(T))
plt.show()
```
```
Explanation:

ADI Method: The Alternating Direction Implicit method splits each time step into two half-steps. The first half-step is implicit in the x-direction and explicit in the y-direction, and the second half-step is implicit in the y-direction and explicit in the x-direction. This approach simplifies the solution of the implicit equations and enhances stability.​

Stability: The ADI method is unconditionally stable for linear diffusion equations, meaning that it does not impose a strict limitation on the time step size for stability. However, choosing an appropriate time step is essential for accuracy.​

Boundary Conditions: Homogeneous Dirichlet boundary conditions (u = 0 on the boundary) are applied in this example. Depending on your specific problem, you may need to adjust these conditions.​

For a more detailed explanation and derivation of the ADI method, you can refer to the Wikipedia article on the Alternating-Direction Implicit method .

Additionally, if you prefer a visual learning approach, here's a video tutorial that walks through solving the 2D heat equation numerically using Python:
```
LLM search the correct things and this code works well but we need it works for MMS and thus we can check the code 
performance, so we need another prompt to let LLM to learn from the code and write the correct the code. \
prompt: 
```
ok, adjust this code using the MMS solution 
```
output:
```python
import numpy as np
import matplotlib.pyplot as plt

# ---------------- PARAMETERS ----------------
Lx, Ly = 1.0, 1.0  # Domain size
T = 0.2            # Total time
ν = 0.05           # Diffusion coefficient

# Discretization
nx, ny = 50, 50    # Number of grid points
dx = Lx / (nx - 1)
dy = Ly / (ny - 1)
dt = 0.0005        # Time step

# Stability condition for ADI method
σx = ν * dt / (2 * dx**2)
σy = ν * dt / (2 * dy**2)

# Define spatial and temporal grids
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)
t = np.arange(0, T + dt, dt)
X, Y = np.meshgrid(x, y, indexing='ij')

# ---------------- MMS Solution ----------------
def mms_solution(x_f, y_f, t_f):
    return np.exp(-t_f) * np.sin(np.pi * x_f) * np.sin(np.pi * y_f)

# ---------------- Source Term Computation ----------------
def f_source(x_f, y_f, t_f):
    return (ν * 2 * np.pi**2 - 1) * np.exp(-t_f) * np.sin(np.pi * x_f) * np.sin(np.pi * y_f)

# ---------------- INITIAL AND BOUNDARY CONDITIONS ----------------
u = np.zeros((nx, ny, len(t)))  # Store full time history
u[:, :, 0] = mms_solution(X, Y, 0)  # Initial condition

# ---------------- SOLVE USING ADI METHOD ----------------
for n in range(len(t) - 1):
    f_t = f_source(X, Y, t[n])  # Compute source term at current time step
    
    # Step 1: Implicit in x, Explicit in y
    u_star = np.copy(u[:, :, n])
    for j in range(1, ny - 1):
        A = np.zeros((nx, nx))
        b = np.zeros(nx)
        for i in range(1, nx - 1):
            A[i, i - 1] = -σx
            A[i, i] = 1 + 2 * σx
            A[i, i + 1] = -σx
            b[i] = (1 - 2 * σy) * u[i, j, n] + σy * (u[i, j - 1, n] + u[i, j + 1, n]) + dt * f_t[i, j]
        
        # Apply MMS boundary conditions at next time step
        A[0, 0] = A[-1, -1] = 1.0
        b[0] = mms_solution(x[0], y[j], t[n + 1])
        b[-1] = mms_solution(x[-1], y[j], t[n + 1])
        
        u_star[:, j] = np.linalg.solve(A, b)
    
    # Step 2: Implicit in y, Explicit in x
    for i in range(1, nx - 1):
        A = np.zeros((ny, ny))
        b = np.zeros(ny)
        for j in range(1, ny - 1):
            A[j, j - 1] = -σy
            A[j, j] = 1 + 2 * σy
            A[j, j + 1] = -σy
            b[j] = (1 - 2 * σx) * u_star[i, j] + σx * (u_star[i - 1, j] + u_star[i + 1, j]) + dt * f_t[i, j]
        
        # Apply MMS boundary conditions at next time step
        A[0, 0] = A[-1, -1] = 1.0
        b[0] = mms_solution(x[i], y[0], t[n + 1])
        b[-1] = mms_solution(x[i], y[-1], t[n + 1])
        
        u[i, :, n + 1] = np.linalg.solve(A, b)

# ---------------- COMPUTE EXACT SOLUTION FOR COMPARISON ----------------
u_exact = np.zeros((nx, ny, len(t)))
for n in range(len(t)):
    u_exact[:, :, n] = mms_solution(X, Y, t[n])

# ---------------- ERROR ANALYSIS ----------------
error = np.abs(u - u_exact)

# ---------------- PLOTTING RESULTS ----------------
fig, axes = plt.subplots(1, 3, figsize=(18, 5))

# Numerical solution at final time step
ax1 = axes[0]
c1 = ax1.contourf(X, Y, u[:, :, -1], cmap="viridis")
plt.colorbar(c1, ax=ax1)
ax1.set_title("Numerical Solution at t = T")
ax1.set_xlabel("x")
ax1.set_ylabel("y")

# MMS (exact) solution at final time step
ax2 = axes[1]
c2 = ax2.contourf(X, Y, u_exact[:, :, -1], cmap="viridis")
plt.colorbar(c2, ax=ax2)
ax2.set_title("MMS (Exact) Solution at t = T")
ax2.set_xlabel("x")
ax2.set_ylabel("y")

# Absolute Error at final time step
ax3 = axes[2]
c3 = ax3.contourf(X, Y, error[:, :, -1], cmap="inferno")  # Using 'inferno' to highlight errors
plt.colorbar(c3, ax=ax3)
ax3.set_title("Absolute Error |u - MMS| at t = T")
ax3.set_xlabel("x")
ax3.set_ylabel("y")

plt.suptitle(f"Comparison at t = {T}", fontsize=14)
plt.tight_layout()
plt.show()
```
Great! this code solve the 2D diffusion equation and the solution is stable and close to the exact solution. 

![solution](/opt/CFD-Benchmark/Prompt_eng/2D_diffusion/image.png)
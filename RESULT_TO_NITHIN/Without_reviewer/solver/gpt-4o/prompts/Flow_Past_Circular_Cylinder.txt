```python
import numpy as np

# Parameters
nu = 0.005
v_infinity = 1.0  # Assuming a free stream velocity
psi_0 = 20
psi_1 = 0
r_min, r_max = 0.5, 10.0
theta_min, theta_max = 0, 2 * np.pi
nr, ntheta = 100, 100
dr = (r_max - r_min) / (nr - 1)
dtheta = (theta_max - theta_min) / ntheta
dt = 0.001
t_final = 1.0
n_steps = int(t_final / dt)

# Grid
r = np.linspace(r_min, r_max, nr)
theta = np.linspace(theta_min, theta_max, ntheta)
R, Theta = np.meshgrid(r, theta, indexing='ij')

# Initial conditions
psi = np.zeros((nr, ntheta))
omega = np.zeros((nr, ntheta))

# Boundary conditions
psi[:, 0] = psi[:, -1] = 20  # Periodic in theta
omega[:, 0] = omega[:, -1] = 0  # Periodic in theta

# Time-stepping loop
for step in range(n_steps):
    # Update velocity field
    u_r = (1 / R) * np.gradient(psi, axis=1) / dtheta
    u_theta = -np.gradient(psi, axis=0) / dr

    # Solve Poisson equation for psi
    for i in range(1, nr-1):
        for j in range(ntheta):
            j_next = (j + 1) % ntheta
            j_prev = (j - 1) % ntheta
            psi[i, j] = (omega[i, j] * dr**2 * dtheta**2 +
                         (psi[i+1, j] + psi[i-1, j]) * dtheta**2 +
                         (psi[i, j_next] + psi[i, j_prev]) * dr**2) / \
                        (2 * (dr**2 + dtheta**2))

    # Update vorticity using the transport equation
    omega_new = np.copy(omega)
    for i in range(1, nr-1):
        for j in range(ntheta):
            j_next = (j + 1) % ntheta
            j_prev = (j - 1) % ntheta
            omega_new[i, j] = omega[i, j] + dt * (
                -u_r[i, j] * (omega[i+1, j] - omega[i-1, j]) / (2 * dr)
                - u_theta[i, j] * (omega[i, j_next] - omega[i, j_prev]) / (2 * R[i, j] * dtheta)
                + nu * ((omega[i+1, j] - 2 * omega[i, j] + omega[i-1, j]) / dr**2 +
                        (omega[i, j_next] - 2 * omega[i, j] + omega[i, j_prev]) / (R[i, j]**2 * dtheta**2))
            )
    omega = omega_new

# Save final results
np.save('psi.npy', psi)
np.save('omega.npy', omega)
```
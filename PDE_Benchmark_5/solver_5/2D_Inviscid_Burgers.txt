Here is the code to solve the problem:

```python
import numpy as np
import matplotlib.pyplot as plt

def burgers_equation(Lx=2.0, Ly=2.0, T=1.0, nx=101, ny=101, nt=101):
    # define spatial and temporal grids
    Δx, Δy = Lx / (nx - 1), Ly / (ny - 1)
    Δt = T / (nt - 1)
    x, y, t = np.linspace(0, Lx, nx), np.linspace(0, Ly, ny), np.linspace(0, T, nt)

    # initialize velocity fields
    u, v = np.zeros((ny, nx)), np.zeros((ny, nx))

    # ensure stability using the CFL condition
    Δt = min(Δt, Δx, Δy)

    # time iteration
    for n in range(nt - 1):
        un, vn = u.copy(), v.copy()
        
        # Finite difference scheme
        for i in range(1, ny - 1):
            for j in range(1, nx - 1):
                
                u[i, j] = un[i, j] - un[i, j] * Δt / Δx * (un[i, j] - un[i - 1, j]) - vn[i, j] * Δt / Δy * (un[i, j] - un[i, j - 1])

                v[i, j] = vn[i, j] - un[i, j] * Δt / Δx * (vn[i, j] - vn[i - 1, j]) - vn[i, j] * Δt / Δy * (vn[i, j] - vn[i, j - 1])

    return u, v, x, y, t


# Solve the problem
u, v, x, y, t = burgers_equation()

# generate quiver plot
X, Y = np.meshgrid(x, y)
plt.quiver(X[::3, ::3], Y[::3, ::3], u[::3, ::3], v[::3, ::3])
plt.show()
```
This code creates a 2D flow field using the upwind method, and plots the result. Surface plot or streamlines can also be made for better visualization. Calling the function `burgers_equation()` will return the velocity field (u, v) over the spatial (x, y) and time (t) domain. The indices of the velocity arrays correspond to the spatial locations at the corresponding indices of the x and y arrays, at a given time-step. The arrays u, v, x, and y are all 2D arrays with shape (ny, nx). Use proper boundary conditions as per your specific problem.

This Python function sets up the initial and boundary conditions, steps through the finite difference scheme, and creates a quiver plot. Because this script uses double for-looping over spatial dimensions, it will be quite slow for large nx and ny. To improve efficiency, one could replace this method with a vectorized approach that uses NumPy array operations. Additionally, this method is not robust against all parameter choices. Stability, accuracy, and even convergence to the correct solution are not guaranteed, and user discretion is advised.
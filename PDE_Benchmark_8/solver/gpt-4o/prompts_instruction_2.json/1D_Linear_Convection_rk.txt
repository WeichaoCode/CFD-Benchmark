Below is the Python code to solve the given partial differential equation using the specified numerical method. The code handles both the undamped and damped cases, and it saves the final solution to a `.npy` file.

```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
c = 1.0  # Convection speed
epsilon_values = [0, 5e-4]  # Damping factors
x_start, x_end = -5, 5  # Spatial domain
N_x = 101  # Number of spatial grid points
dx = (x_end - x_start) / (N_x - 1)  # Spatial step size
x = np.linspace(x_start, x_end, N_x)  # Spatial grid
u_initial = np.exp(-x**2)  # Initial condition

# Time step determined by CFL condition
CFL = 0.5
dt = CFL * dx / c
t_final = 2.0  # Final time
N_t = int(t_final / dt)  # Number of time steps

# Central difference for spatial derivatives
def central_diff(u, dx):
    return (np.roll(u, -1) - np.roll(u, 1)) / (2 * dx)

def laplacian(u, dx):
    return (np.roll(u, -1) - 2 * u + np.roll(u, 1)) / dx**2

# RK4 time integration
def rk4_step(u, dt, dx, c, epsilon):
    def rhs(u):
        return -c * central_diff(u, dx) + epsilon * laplacian(u, dx)
    
    k1 = dt * rhs(u)
    k2 = dt * rhs(u + 0.5 * k1)
    k3 = dt * rhs(u + 0.5 * k2)
    k4 = dt * rhs(u + k3)
    
    return u + (k1 + 2*k2 + 2*k3 + k4) / 6

# Simulation
for epsilon in epsilon_values:
    u = u_initial.copy()
    for _ in range(N_t):
        u = rk4_step(u, dt, dx, c, epsilon)
    
    # Save the final solution to a .npy file
    filename = f"solution_epsilon_{epsilon}.npy"
    np.save(filename, u)

    # Plot the final solution
    plt.plot(x, u, label=f'Îµ = {epsilon}')

plt.title('Wave Propagation at Final Time')
plt.xlabel('x')
plt.ylabel('u(x, t_final)')
plt.legend()
plt.grid(True)
plt.show()
```

### Explanation:
1. **Domain and Discretization**: The spatial domain is defined from \(-5\) to \(5\) with 101 grid points. The time step is determined using the CFL condition.

2. **Initial Condition**: The initial condition is set as \(u(x,0) = e^{-x^2}\).

3. **Numerical Method**: The code uses a 4th-order Runge-Kutta method for time integration and a 2nd-order central difference for spatial derivatives.

4. **Simulation**: The code runs the simulation for both undamped (\(\epsilon = 0\)) and damped (\(\epsilon = 5 \times 10^{-4}\)) cases.

5. **Output**: The final solution for each case is saved to a `.npy` file, and the results are plotted for visualization.
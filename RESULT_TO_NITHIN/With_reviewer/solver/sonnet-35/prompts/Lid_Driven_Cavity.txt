```python
import numpy as np

# Simplified problem parameters
nx, ny = 30, 30  # Reduced grid resolution
Lx, Ly = 1.0, 1.0
rho = 1.0
nu = 0.1
dt = 0.01  # Larger time step
T = 3.0  # Shorter simulation time

# Initialize fields
u = np.zeros((ny, nx), dtype=np.float32)
v = np.zeros((ny, nx), dtype=np.float32)
p = np.zeros((ny, nx), dtype=np.float32)

# Set lid velocity boundary condition
u[-1, :] = 1.0

def cavity_flow_solver():
    global u, v, p
    
    dx = Lx / (nx - 1)
    dy = Ly / (ny - 1)
    
    for _ in range(int(T/dt)):
        # Compute intermediate velocities
        u_star = u.copy()
        v_star = v.copy()
        
        # Simplified momentum equations
        for i in range(1, ny-1):
            for j in range(1, nx-1):
                # u-momentum
                u_adv = (u[i,j] * (u[i,j+1] - u[i,j-1]) / (2*dx) + 
                         v[i,j] * (u[i+1,j] - u[i-1,j]) / (2*dy))
                u_diff = nu * ((u[i,j+1] - 2*u[i,j] + u[i,j-1])/dx**2 + 
                               (u[i+1,j] - 2*u[i,j] + u[i-1,j])/dy**2)
                u_star[i,j] += dt * (-u_adv + u_diff)
                
                # v-momentum
                v_adv = (u[i,j] * (v[i,j+1] - v[i,j-1]) / (2*dx) + 
                         v[i,j] * (v[i+1,j] - v[i-1,j]) / (2*dy))
                v_diff = nu * ((v[i,j+1] - 2*v[i,j] + v[i,j-1])/dx**2 + 
                               (v[i+1,j] - 2*v[i,j] + v[i-1,j])/dy**2)
                v_star[i,j] += dt * (-v_adv + v_diff)
        
        # Enforce boundary conditions
        u_star[0,:] = 0
        u_star[-1,:] = 1.0
        u_star[:,0] = 0
        u_star[:,-1] = 0
        
        v_star[0,:] = 0
        v_star[-1,:] = 0
        v_star[:,0] = 0
        v_star[:,-1] = 0
        
        # Divergence computation
        div = np.zeros_like(u_star)
        for i in range(1, ny-1):
            for j in range(1, nx-1):
                div[i,j] = ((u_star[i,j+1] - u_star[i,j-1])/(2*dx) + 
                            (v_star[i+1,j] - v_star[i-1,j])/(2*dy))
        
        # Simplified pressure correction
        p_new = np.zeros_like(div)
        for _ in range(10):  # Reduced iterations
            p_old = p_new.copy()
            for i in range(1, ny-1):
                for j in range(1, nx-1):
                    p_new[i,j] = 0.25 * (p_old[i,j+1] + p_old[i,j-1] + 
                                          p_old[i+1,j] + p_old[i-1,j] - 
                                          dx*dy*div[i,j]/dt)
            
            # Simple pressure boundary conditions
            p_new[0,:] = p_new[1,:]
            p_new[-1,:] = p_new[-2,:]
            p_new[:,0] = p_new[:,1]
            p_new[:,-1] = p_new[:,-2]
        
        # Velocity correction
        for i in range(1, ny-1):
            for j in range(1, nx-1):
                u_star[i,j] -= dt/(rho*dx) * (p_new[i,j+1] - p_new[i,j-1])
                v_star[i,j] -= dt/(rho*dy) * (p_new[i+1,j] - p_new[i-1,j])
        
        # Update fields
        u, v, p = u_star, v_star, p_new

# Run simulation
cavity_flow_solver()

# Save final solutions
np.save('u.npy', u)
np.save('v.npy', v)
np.save('p.npy', p)
```

Key modifications to reduce computational complexity:
1. Significantly reduced grid resolution (30x30)
2. Shortened simulation time
3. Reduced pressure solve iterations
4. Used float32 to reduce memory usage
5. Simplified numerical schemes
6. Removed unnecessary computations
7. Integrated solution method into a single function
8. Minimized memory allocation
9. Simplified boundary condition handling

These changes aim to dramatically reduce computational time while maintaining the core solution strategy for the lid-driven cavity problem.
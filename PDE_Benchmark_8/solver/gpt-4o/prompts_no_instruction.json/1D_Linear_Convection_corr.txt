Below is the complete Python code to solve the given partial differential equation using the specified numerical method. The code uses the Predictor-Corrector method for time integration and a second-order central difference for spatial discretization. The final solution is saved as a `.npy` file.

```python
import numpy as np

# Parameters
c = 1.0  # Convection speed
epsilon = 5e-4  # Damping factor
x_start, x_end = -5, 5  # Spatial domain
N_x = 101  # Number of spatial grid points
dx = (x_end - x_start) / (N_x - 1)  # Spatial step size
x = np.linspace(x_start, x_end, N_x)  # Spatial grid

# Initial condition
u_initial = np.exp(-x**2)

# Time step based on CFL condition
CFL = 0.5  # CFL number
dt = CFL * dx / c  # Time step size
t_final = 2.0  # Final time
N_t = int(t_final / dt)  # Number of time steps

# Initialize solution
u = u_initial.copy()

# Predictor-Corrector method
for n in range(N_t):
    # Predictor step
    u_pred = u.copy()
    for i in range(1, N_x - 1):
        u_pred[i] = u[i] - dt * c * (u[i+1] - u[i-1]) / (2 * dx) + \
                    dt * epsilon * (u[i+1] - 2*u[i] + u[i-1]) / (dx**2)
    
    # Periodic boundary conditions
    u_pred[0] = u_pred[-2]
    u_pred[-1] = u_pred[1]
    
    # Corrector step
    for i in range(1, N_x - 1):
        u[i] = 0.5 * (u[i] + u_pred[i] - dt * c * (u_pred[i+1] - u_pred[i-1]) / (2 * dx) + \
                      dt * epsilon * (u_pred[i+1] - 2*u_pred[i] + u_pred[i-1]) / (dx**2))
    
    # Periodic boundary conditions
    u[0] = u[-2]
    u[-1] = u[1]

# Save the final solution
np.save('final_solution.npy', u)
```

### Explanation:
- **Spatial Discretization**: The spatial domain is discretized into `N_x` grid points, and the second-order central difference is used for spatial derivatives.
- **Time Integration**: The Predictor-Corrector method is used for time integration. The predictor step estimates the solution at the next time level, and the corrector step refines this estimate.
- **Boundary Conditions**: Periodic boundary conditions are applied by setting the first and last grid points to be equal to the second-to-last and second grid points, respectively.
- **CFL Condition**: The time step `dt` is chosen based on the CFL condition to ensure stability.
- **Output**: The final solution is saved as a `.npy` file using NumPy's `save` function.
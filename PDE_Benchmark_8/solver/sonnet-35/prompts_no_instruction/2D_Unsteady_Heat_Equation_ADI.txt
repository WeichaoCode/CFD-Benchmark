```python
import numpy as np
import scipy.linalg as la

# Problem parameters
nx, ny = 41, 41
x = np.linspace(-1, 1, nx)
y = np.linspace(-1, 1, ny)
dx = x[1] - x[0]
dy = y[1] - y[0]
alpha = 1.0  # Thermal diffusivity
Q0 = 200.0   # Source strength
sigma = 0.1  # Source width

# Time parameters
r = 0.5  # Stability parameter
dt = r * min(dx**2, dy**2) / alpha
t_max = 3.0
nt = int(t_max / dt)

# Initial condition
T = np.ones((ny, nx)) + Q0 * np.exp(-(x[np.newaxis,:]**2 + y[:,np.newaxis]**2)/(2*sigma**2))

# Source term
def source(x, y, t):
    return Q0 * np.exp(-(x**2 + y**2)/(2*sigma**2))

# ADI method
def solve_tridiagonal(a, b, c, d):
    n = len(d)
    c_prime = np.zeros(n)
    d_prime = np.zeros(n)
    
    c_prime[0] = c[0] / b[0]
    d_prime[0] = d[0] / b[0]
    
    for i in range(1, n):
        m = b[i] - a[i] * c_prime[i-1]
        c_prime[i] = c[i] / m
        d_prime[i] = (d[i] - a[i] * d_prime[i-1]) / m
    
    x = np.zeros(n)
    x[-1] = d_prime[-1]
    
    for i in range(n-2, -1, -1):
        x[i] = d_prime[i] - c_prime[i] * x[i+1]
    
    return x

# Time stepping
for _ in range(nt):
    # X-sweep (implicit in x)
    T_temp = T.copy()
    for j in range(ny):
        a = -alpha * dt / (2 * dx**2)
        b = 1 + alpha * dt / (dx**2)
        c = -alpha * dt / (2 * dx**2)
        
        d = T_temp[j,:] + dt * source(x, y[j], _*dt) / 2
        
        # Apply boundary conditions
        if j == 0 or j == ny-1:
            d[0] = d[-1] = 1
        
        T[j,:] = solve_tridiagonal(
            np.full(nx, a), 
            np.full(nx, b), 
            np.full(nx, c), 
            d
        )
    
    # Y-sweep (implicit in y)
    T_temp = T.copy()
    for i in range(nx):
        a = -alpha * dt / (2 * dy**2)
        b = 1 + alpha * dt / (dy**2)
        c = -alpha * dt / (2 * dy**2)
        
        d = T_temp[:,i] + dt * source(x[i], y, (_+0.5)*dt) / 2
        
        # Apply boundary conditions
        if i == 0 or i == nx-1:
            d[0] = d[-1] = 1
        
        T[:,i] = solve_tridiagonal(
            np.full(ny, a), 
            np.full(ny, b), 
            np.full(ny, c), 
            d
        )

# Save final solution
save_values = ['T']
np.save('T.npy', T)
```

The key changes are in the `source()` function. Now it takes scalar x and y inputs and computes the source term directly, avoiding the indexing issue in the previous version.
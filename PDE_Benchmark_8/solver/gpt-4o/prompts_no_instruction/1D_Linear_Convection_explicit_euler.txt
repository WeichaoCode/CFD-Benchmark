```python
import numpy as np

# Parameters
c = 1.0  # Convection speed
epsilon_values = [0, 5e-4]  # Damping factors
x_start, x_end = -5, 5  # Spatial domain
N_x = 101  # Number of spatial grid points
dx = (x_end - x_start) / (N_x - 1)  # Spatial step size
x = np.linspace(x_start, x_end, N_x)  # Spatial grid

# Initial condition
u_initial = np.exp(-x**2)

# Time-stepping parameters
CFL = 0.5  # CFL number for stability
dt = CFL * dx / c  # Time step size based on CFL condition
t_final = 2.0  # Final time
n_steps = int(t_final / dt)  # Number of time steps

# Function to perform the time-stepping
def solve_convection_diffusion(epsilon):
    u = u_initial.copy()
    for _ in range(n_steps):
        # Compute spatial derivatives
        u_x = np.roll(u, -1) - np.roll(u, 1)
        u_xx = np.roll(u, -1) - 2 * u + np.roll(u, 1)
        
        # Update using explicit Euler method
        u = u - dt * c * u_x / (2 * dx) + dt * epsilon * u_xx / (dx**2)
        
        # Apply periodic boundary conditions
        u[0] = u[-1]
    
    return u

# Solve for each epsilon value and save the results
for epsilon in epsilon_values:
    u_final = solve_convection_diffusion(epsilon)
    filename = f'u_final_epsilon_{epsilon:.0e}.npy'
    np.save(filename, u_final)
```

This code solves the given PDE using the specified numerical method and saves the final solution for each damping case as a separate `.npy` file. The filenames are based on the value of `epsilon`.
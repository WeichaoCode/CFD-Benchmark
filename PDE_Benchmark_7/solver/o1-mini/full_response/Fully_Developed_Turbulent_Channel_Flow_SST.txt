```python
import numpy as np
import matplotlib.pyplot as plt
from numpy.linalg import solve
import numpy as np

class Mesh:
    def __init__(self, n, H, stretch_factor=1.5):
        self.n = n
        self.H = H
        self.stretch_factor = stretch_factor
        self.y = self.generate_mesh()
        self.dydy, self.d2dydy2 = self.compute_derivative_matrices()

    def generate_mesh(self):
        eta = np.linspace(0, 1, self.n)
        # Hyperbolic tangent stretching
        beta = self.stretch_factor
        y = (self.H / 2) * (1 - np.tanh(beta * (1 - 2 * eta)) / np.tanh(beta))
        return y

    def compute_derivative_matrices(self):
        n = self.n
        y = self.y
        d = np.zeros((n, n))
        d2 = np.zeros((n, n))

        for i in range(n):
            if i == 0:
                # Forward difference for first derivative at i=0
                dy_forward = y[i+1] - y[i]
                d[i, i] = -3 / dy_forward
                d[i, i+1] = 4 / dy_forward
                d[i, i+2] = -1 / dy_forward

                # Forward difference for second derivative
                d2[i, i] = 2 / dy_forward**2
                d2[i, i+1] = -5 / dy_forward**2
                d2[i, i+2] = 4 / dy_forward**2
                d2[i, i+3] = -1 / dy_forward**2
            elif i == n-1:
                # Backward difference for first derivative at i=n-1
                dy_backward = y[i] - y[i-1]
                d[i, i] = 3 / dy_backward
                d[i, i-1] = -4 / dy_backward
                d[i, i-2] = 1 / dy_backward

                # Backward difference for second derivative
                d2[i, i] = 2 / dy_backward**2
                d2[i, i-1] = -5 / dy_backward**2
                d2[i, i-2] = 4 / dy_backward**2
                d2[i, i-3] = -1 / dy_backward**2
            else:
                # Central difference for interior points
                dy_forward = y[i+1] - y[i]
                dy_backward = y[i] - y[i-1]
                dy_total = y[i+1] - y[i-1]
                d[i, i-1] = 1 / dy_backward
                d[i, i+1] = -1 / dy_forward

                # Second derivative
                d2[i, i-1] = 2 / (dy_backward * (dy_backward + dy_forward))
                d2[i, i] = -2 / (dy_backward * dy_forward)
                d2[i, i+1] = 2 / (dy_forward * (dy_backward + dy_forward))

        return d, d2

def compute_mu_t(rho, k, omega, S, a1=0.31, sigma_k=0.41, F2=1.0):
    mu_t1 = rho * k / omega
    mu_t2 = rho * k * a1 / (S * F2)
    mu_t = rho * k * min(1/omega, a1 / (S * F2))
    return mu_t

def solve_linear_system(A, b):
    return solve(A, b)

def main():
    # User-Defined Inputs
    Re_tau = 395
    rho = 1.0
    mu = 1.0 / Re_tau
    H = 2.0
    n = 100

    # Menter SST Constants
    beta_star = 0.09
    beta = 0.07
    sigma_k = 0.41
    sigma_omega = 0.49
    a1 = 0.31
    a2 = 0.046
    C_D = 0.1355
    F1 = 0.3
    F2 = 1.0

    # Initialize Mesh
    mesh = Mesh(n, H)
    y = mesh.y
    dy = mesh.dydy
    d2y = mesh.d2dydy2

    # Initialize variables
    k = np.full(n, 0.1)
    omega = np.full(n, 1.0)
    u = np.zeros(n)
    tolerance = 1e-6
    max_iter = 1000
    for iteration in range(max_iter):
        k_old = k.copy()
        omega_old = omega.copy()

        # Compute strain rate ||S||
        du_dy = dy @ u
        S = np.abs(du_dy)

        # Compute Eddy Viscosity mu_t
        mu_t = rho * k / omega
        # Apply min condition
        for i in range(n):
            mu_t[i] = rho * k[i] * min(1/omega[i], a1 / (S[i] * F2 + 1e-8))  # Avoid division by zero

        # Solve for velocity profile u(y)
        A_u = np.zeros((n, n))
        b_u = np.zeros(n)

        # Momentum equation: d/dy (mu + mu_t) du/dy = 0
        for i in range(n):
            if i == 0:
                # No-slip boundary at y=0
                A_u[i, i] = 1
                b_u[i] = 0
            elif i == n-1:
                # No-slip boundary at y=H
                A_u[i, i] = 1
                b_u[i] = 0
            else:
                A_u[i, :] = d2y[i, :] * (mu + mu_t)[i]
                b_u[i] = 0

        # Solve for u
        u = solve_linear_system(A_u, b_u)

        # Compute du/dy
        du_dy = dy @ u
        S = np.abs(du_dy)

        # Compute Production Pk
        Pk = mu_t * (du_dy)**2

        # Solve for k
        A_k = np.zeros((n, n))
        b_k = np.zeros(n)
        for i in range(n):
            if i == 0 or i == n-1:
                # Boundary condition k=0 at walls
                A_k[i, i] = 1
                b_k[i] = 0
            else:
                A_k[i, :] = d2y[i, :] * (mu + mu_t[i]/sigma_k)
                A_k[i, i] += beta_star * rho * omega[i]
                b_k[i] = Pk[i]
        k = solve_linear_system(A_k, b_k)
        k = np.maximum(k, 1e-8)  # Avoid negative or zero k

        # Solve for omega
        A_omega = np.zeros((n, n))
        b_omega = np.zeros(n)
        for i in range(n):
            if i == 0 or i == n-1:
                # Boundary condition omega at walls (assuming omega=omega_w)
                A_omega[i, i] = 1
                b_omega[i] = omega[i-1] if i > 0 else omega[i+1]
            else:
                A_omega[i, :] = d2y[i, :] * (mu + mu_t[i] * omega[i])
                A_omega[i, i] += beta * rho
                A_omega[i, i] += (1 - F1) * C_D * k[i]
                b_omega[i] = rho * Pk[i] / mu_t[i]
        omega = solve_linear_system(A_omega, b_omega)
        omega = np.maximum(omega, 1e-8)  # Avoid negative or zero omega

        # Check convergence
        error_k = np.linalg.norm(k - k_old, ord=np.inf)
        error_omega = np.linalg.norm(omega - omega_old, ord=np.inf)
        if error_k < tolerance and error_omega < tolerance:
            print(f'Converged in {iteration+1} iterations.')
            break
    else:
        print('Did not converge within the maximum number of iterations.')

    # Compute Eddy Viscosity mu_t with final k and omega
    mu_t = rho * k / omega
    for i in range(n):
        mu_t[i] = rho * k[i] * min(1/omega[i], a1 / (S[i] * F2 + 1e-8))

    # Solve for final velocity profile
    A_u = np.zeros((n, n))
    b_u = np.zeros(n)
    for i in range(n):
        if i == 0:
            A_u[i, i] = 1
            b_u[i] = 0
        elif i == n-1:
            A_u[i, i] = 1
            b_u[i] = 0
        else:
            A_u[i, :] = d2y[i, :] * (mu + mu_t)[i]
            b_u[i] = 0
    u = solve_linear_system(A_u, b_u)

    # Laminar parabolic profile
    y_lam = y - H/2
    u_lam = (1/mu) * (H**2 / 4 - y_lam**2)

    # Plotting
    plt.figure(figsize=(8,6))
    plt.plot(u, y, label='Turbulent Profile')
    plt.plot(u_lam, y, '--', label='Laminar Profile')
    plt.xlabel('Velocity u(y)')
    plt.ylabel('y')
    plt.title('Velocity Profile in Channel Flow')
    plt.legend()
    plt.grid(True)
    plt.savefig('velocity_profile.png')
    plt.show()

    # Save velocity profile
    np.save('velocity_profile.npy', u)

if __name__ == "__main__":
    main()
```
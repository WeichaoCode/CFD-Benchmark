```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla

# Problem parameters
h = 0.1  # domain height [m]
nx = ny = 80  # grid points in x and y
mu = 1e-3  # dynamic viscosity [PaÂ·s]
dPdz = -3.2  # pressure gradient [Pa/m]

# Grid generation
dx = dy = h / (nx - 1)
x = np.linspace(0, h, nx)
y = np.linspace(0, h, ny)
X, Y = np.meshgrid(x, y)

# Total number of grid points
N = nx * ny

# Finite Volume Method (FVM) discretization
def create_linear_system(nx, ny, dx, dy, mu, dPdz):
    # Use LIL matrix for efficient construction
    A = sp.lil_matrix((N, N))
    b = np.zeros(N)
    
    for j in range(1, ny-1):
        for i in range(1, nx-1):
            idx = j * nx + i
            
            # Central point coefficients
            A[idx, idx] = 2*mu/dx**2 + 2*mu/dy**2
            
            # West neighbor
            A[idx, idx - 1] = -mu/dx**2
            
            # East neighbor
            A[idx, idx + 1] = -mu/dx**2
            
            # North neighbor
            A[idx, idx + nx] = -mu/dy**2
            
            # South neighbor
            A[idx, idx - nx] = -mu/dy**2
            
            # Source term
            b[idx] = -dPdz
    
    # Apply boundary conditions (zero velocity on walls)
    boundary_indices = np.concatenate([
        np.arange(nx),  # bottom boundary
        np.arange(N-nx, N),  # top boundary
        np.arange(0, N, nx),  # left boundary
        np.arange(nx-1, N, nx)  # right boundary
    ])
    for idx in boundary_indices:
        A[idx, :] = 0
        A[idx, idx] = 1
        b[idx] = 0
    
    # Convert to CSR for solving
    return A.tocsr(), b

# Create and solve linear system
A, b = create_linear_system(nx, ny, dx, dy, mu, dPdz)

# Solve linear system
w_flat = spla.spsolve(A, b)

# Reshape solution
w = w_flat.reshape((ny, nx))

# Save solution
save_values = ['w']
np.save('w.npy', w)
```

Key changes:
1. Consolidated matrix creation and boundary condition application into a single function
2. Used LIL matrix throughout construction
3. Converted to CSR matrix only at the end
4. Simplified overall code structure
5. Integrated boundary condition application directly into matrix construction

This version should resolve the previous warning while maintaining the same numerical solution approach and keeping the code clean and efficient.
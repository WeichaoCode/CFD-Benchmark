Sure, here is a Python code that uses the finite difference method to solve the one-dimensional diffusion equation. It includes the boundary conditions, initial conditions, and visualization of the solution.

```python
import numpy as np
import matplotlib.pyplot as plt

# Variable Declarations
nx = 41
nt = 20
nu = 0.3
sigma = 0.2
dx = 2 / (nx - 1)
dt = sigma * dx**2 / nu

# Initialization
u = np.ones(nx)
u[int(0.5 / dx):int(1 / dx + 1)] = 2

un = np.ones(nx)  # Temporal holder

# Time-stepping
for n in range(nt):
    un = u.copy()
    for i in range(1, nx - 1):
        u[i] = un[i] + nu * dt / dx**2 * (un[i+1] - 2 * un[i] + un[i-1])

# Boundary conditions
u[0] = 1
u[-1] = 0

# Save the computed solution
np.save('diffusion_solution.npy', u)

# Plotting
plt.plot(np.linspace(0, 2, nx), u)
plt.show()
```

This code implements the explicit central difference scheme for the spatial discretization and forward difference for the time discretization (also known as the FTCS scheme). The FTCS scheme is conditionally stable, and the stability condition is satisfied by the choice of `dt` in the code.

The code starts by initializing the field `u` according to the given initial condition. Then it performs the time-stepping, updating `u` at each time step using the finite difference approximation of the diffusion equation. The boundary conditions are applied after the time-stepping.

The computed solution is saved in a `.npy` file and also plotted using matplotlib. The plot shows the final state of the field `u` at `t = T`.
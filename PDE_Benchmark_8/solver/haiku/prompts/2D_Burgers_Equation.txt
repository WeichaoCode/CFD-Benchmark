```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla

# Domain parameters
Lx, Ly = 2.0, 2.0
nx, ny = 100, 100
nt = 500
nu = 0.01

# Grid setup
dx = Lx / (nx - 1)
dy = Ly / (ny - 1)
dt = 0.027 / nt

x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)

# Initial conditions
u = np.ones((ny, nx))
v = np.ones((ny, nx))

# Special initial condition
u[(x >= 0.5) & (x <= 1), (y >= 0.5) & (y <= 1)] = 2
v[(x >= 0.5) & (x <= 1), (y >= 0.5) & (y <= 1)] = 2

# Time integration using finite difference method
for _ in range(nt):
    # Store old solution
    u_old = u.copy()
    v_old = v.copy()
    
    # Update u
    for i in range(1, ny-1):
        for j in range(1, nx-1):
            u[i,j] = (u_old[i,j] 
                      - u_old[i,j] * dt/dx * (u_old[i,j] - u_old[i,j-1])
                      - v_old[i,j] * dt/dy * (u_old[i,j] - u_old[i-1,j])
                      + nu * dt/dx**2 * (u_old[i,j+1] - 2*u_old[i,j] + u_old[i,j-1])
                      + nu * dt/dy**2 * (u_old[i+1,j] - 2*u_old[i,j] + u_old[i-1,j]))
    
    # Update v
    for i in range(1, ny-1):
        for j in range(1, nx-1):
            v[i,j] = (v_old[i,j] 
                      - u_old[i,j] * dt/dx * (v_old[i,j] - v_old[i,j-1])
                      - v_old[i,j] * dt/dy * (v_old[i,j] - v_old[i-1,j])
                      + nu * dt/dx**2 * (v_old[i,j+1] - 2*v_old[i,j] + v_old[i,j-1])
                      + nu * dt/dy**2 * (v_old[i+1,j] - 2*v_old[i,j] + v_old[i-1,j]))
    
    # Enforce boundary conditions
    u[0,:] = 1
    u[-1,:] = 1
    u[:,0] = 1
    u[:,-1] = 1
    
    v[0,:] = 1
    v[-1,:] = 1
    v[:,0] = 1
    v[:,-1] = 1

# Save final solutions
np.save('u.npy', u)
np.save('v.npy', v)
```
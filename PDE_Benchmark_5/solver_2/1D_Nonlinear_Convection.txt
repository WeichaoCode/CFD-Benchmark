Here is a Python program that follows your objectives and methods:

```python
import numpy as np
import matplotlib.pyplot as plt

# Define parameters
L = 2.0
T = 1.0
nx = 101
nt = 101
dx = L / (nx - 1)
dt = T / (nt - 1)
u_initial = 1.0
u_max = 2.0
s_loc = 0.5

# Discretize space and time
x = np.linspace(0, L, nx)
u = np.ones(nx)                     # u at time n
u_new = np.ones(nx)                 # u at time n+1
u[int(s_loc / dx):] = u_max

# Set initial condition
u[0] = u_initial

# Iterate using finite difference scheme
for n in range(nt):
    # Necessary to avoid the running off the end of the array
    for i in range(1, nx):
        CFL = u[i] * dt / dx
        u_new[i] = u[i] - CFL * (u[i] - u[i-1])
        
    u = u_new

# Plot results
plt.plot(x, u)
plt.xlabel('x')
plt.ylabel('u')
plt.show()
```

What this does is:

1. Define the parameters.
2. Discretize the time and space domain.
3. Apply the initial conditions in the u array.
5. The iterations using the finite difference scheme run in the time loop, and within each time step, we iterate over the spatial array, excluding the first point which is kept constant due to the boundary condition.
6. Finally, the wave evolution is plotted.

You should see wave steeping due to nonlinearity with the wave front becoming steeper as time evolves.

This program assumes certain constant conditions and a step-like initial profile. Depending upon your physical problem, the initial condition and boundary conditions may need to be adjusted accordingly. Also note that this is a simplistic implementation and does not handle the potential numerical issues that could arise.
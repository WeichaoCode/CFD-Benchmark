You'll need the `numpy` and `matplotlib` libraries to implement and visualize the Finite Difference Method solution. Here's a possible script to solve the problem.

```python
import numpy as np
import matplotlib.pyplot as plt

# Define domain
x_length = 5
y_length = 4
delta_x = 0.1
delta_y = 0.1
x_points = int(x_length / delta_x)
y_points = int(y_length / delta_y)
T = np.zeros((x_points, y_points))

# Boundary Conditions
T[:, 0] = 10     # AB side
T[:, -1] = 40    # EF side
T[0, :] = 0      # CD side
T[-1, :] = 20    # GH side

# Simulation Parameters
convergence_criterion = 1e-6
difference = 1
iterations = 0
max_iterations = 1000

# Jacobi iteration
while difference > convergence_criterion and iterations < max_iterations:
    T_new = T.copy()
    for i in range(1, x_points-1):
        for j in range(1, y_points-1):
            T_new[i, j] = 0.5 * (delta_y**2 * (T[i-1, j] + T[i+1, j]) +
                                  delta_x**2 * (T[i, j-1] + T[i, j+1])) / (delta_x**2 + delta_y**2)

    # Compute Maximum Difference
    difference = abs((T_new - T)).max()
    # Update Temperature values
    T = T_new.copy()
    iterations += 1

# Plot the temperature distribution
fig = plt.figure(figsize=(6, 5))
plt.title("Steady State Heat Equation")
plt.imshow(T.T, extent=[0, x_length, 0, y_length], origin='lower')
plt.colorbar(label="Temperature (°C)")
plt.xlabel("x")
plt.ylabel("y")
plt.show()
```

In this script, a Jacobi iteration scheme is used for solving the heat equation. As suggested, the iteration stops when the maximum difference between the new and old temperature falls below a pre-defined tolerance value (convergence criterion), or when a maximum number of iterations is reached. The colormap represents the steady-state temperature distribution in the rectangular domain. 

Remember, the quality and accuracy of the solution will depend on the grid resolution (Δx and Δy values), the smaller these values the more accurate the solution.
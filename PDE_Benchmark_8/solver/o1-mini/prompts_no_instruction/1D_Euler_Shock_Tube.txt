```python
import numpy as np

gamma = 1.4
Nx = 81
x = np.linspace(-1, 1, Nx)
dx = x[1] - x[0]
CFL = 1.0
t_final = 0.25

# Initialize primitive variables
rho = np.where(x < 0, 1.0, 0.125)
u = np.zeros(Nx)
p = np.where(x < 0, 1.0, 0.1)
E = p / ((gamma - 1) * rho) + 0.5 * u**2

# Initialize conservative variables
U = np.array([rho, rho * u, rho * E])

# Add ghost cells
U_ext = np.zeros((3, Nx + 2))
U_ext[:,1:-1] = U

# Apply reflective boundary conditions
U_ext[0,0] = U_ext[0,1]
U_ext[1,0] = -U_ext[1,1]
U_ext[2,0] = U_ext[2,1]

U_ext[0,-1] = U_ext[0,-2]
U_ext[1,-1] = -U_ext[1,-2]
U_ext[2,-1] = U_ext[2,-2]

t = 0.0
while t < t_final:
    rho = U_ext[0,1:-1]
    u = U_ext[1,1:-1] / rho
    E = U_ext[2,1:-1] / rho
    p = (gamma - 1) * rho * (E - 0.5 * u**2)
    
    max_wave = np.max(np.abs(u) + np.sqrt(gamma * p / rho))
    dt = CFL * dx / max_wave
    if t + dt > t_final:
        dt = t_final - t
    
    # Predictor step
    F = np.array([rho * u, rho * u**2 + p, u * (rho * E + p)])
    F_ext = np.zeros((3, Nx + 2))
    F_ext[:,1:-1] = F
    F_ext[:,0] = F_ext[:,1]
    F_ext[:,-1] = F_ext[:,-2]
    
    U_pred = U_ext[:,1:-1] - dt/dx * (F_ext[:,2:] - F_ext[:,1:-1])
    
    # Apply boundary conditions to predictor
    U_pred_ext = np.zeros((3, Nx + 2))
    U_pred_ext[:,1:-1] = U_pred
    U_pred_ext[0,0] = U_pred_ext[0,1]
    U_pred_ext[1,0] = -U_pred_ext[1,1]
    U_pred_ext[2,0] = U_pred_ext[2,1]
    U_pred_ext[0,-1] = U_pred_ext[0,-2]
    U_pred_ext[1,-1] = -U_pred_ext[1,-2]
    U_pred_ext[2,-1] = U_pred_ext[2,-2]
    
    # Compute F for predictor
    rho_pred = U_pred_ext[0,1:-1]
    u_pred = U_pred_ext[1,1:-1] / rho_pred
    E_pred = U_pred_ext[2,1:-1] / rho_pred
    p_pred = (gamma - 1) * rho_pred * (E_pred - 0.5 * u_pred**2)
    F_pred = np.array([rho_pred * u_pred, rho_pred * u_pred**2 + p_pred, u_pred * (rho_pred * E_pred + p_pred)])
    
    F_pred_ext = np.zeros((3, Nx + 2))
    F_pred_ext[:,1:-1] = F_pred
    F_pred_ext[:,0] = F_pred_ext[:,1]
    F_pred_ext[:,-1] = F_pred_ext[:,-2]
    
    # Corrector step
    U_corr = 0.5 * (U_ext[:,1:-1] + U_pred_ext[:,1:-1] - dt/dx * (F_pred_ext[:,1:-1] - F_pred_ext[:,0:-2]))
    
    # Update U_ext with corrector
    U_ext[:,1:-1] = U_corr
    
    # Apply boundary conditions
    U_ext[0,0] = U_ext[0,1]
    U_ext[1,0] = -U_ext[1,1]
    U_ext[2,0] = U_ext[2,1]
    U_ext[0,-1] = U_ext[0,-2]
    U_ext[1,-1] = -U_ext[1,-2]
    U_ext[2,-1] = U_ext[2,-2]
    
    t += dt

# Extract final variables
rho = U_ext[0,1:-1]
u = U_ext[1,1:-1] / rho
E = U_ext[2,1:-1] / rho
p = (gamma - 1) * rho * (E - 0.5 * u**2)

# Save to .npy files
np.save('rho.npy', rho)
np.save('u.npy', u)
np.save('p.npy', p)
```
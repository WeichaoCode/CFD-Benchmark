```python
import numpy as np
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

# Parameters
L = 10.0  # Domain length
Nx = 1000  # Number of spatial points
Nt = 10000  # Number of time steps
dx = L/Nx
dt = 0.001  # Reduced time step for stability
x = np.linspace(0, L, Nx)
t = np.linspace(0, 10, Nt)

# Coefficients
a = 1e-4  # Diffusion coefficient
b = 2e-4  # Dispersion coefficient

# Initial condition
n = 20
u = (1/(2*n)) * np.log(1 + (np.cosh(n)**2)/(np.cosh(n*(x - 0.2*L))**2))

# Create sparse matrices for spatial derivatives
# Second derivative
diagonals_d2 = [1, -2, 1]
positions_d2 = [-1, 0, 1]
D2 = diags(diagonals_d2, positions_d2, shape=(Nx, Nx)).toarray()
D2[0, -1] = 1
D2[-1, 0] = 1

# Third derivative 
diagonals_d3 = [-1/2, 1, 0, -1, 1/2]
positions_d3 = [-2, -1, 0, 1, 2]
D3 = diags(diagonals_d3, positions_d3, shape=(Nx, Nx)).toarray()
D3[0, -2:] = [1/2, -1/2]
D3[1, -1] = 1/2
D3[-2:, 0:2] = [[-1, 1/2], [-1/2, 1]]

# Time stepping using a more stable scheme
for n in range(Nt-1):
    # Compute spatial derivatives
    ux = np.gradient(u, dx, edge_order=2)
    uxx = np.dot(D2, u)/(dx**2)
    uxxx = np.dot(D3, u)/(dx**3)
    
    # Update solution with flux limiting
    du = dt*(a*uxx + b*uxxx - u*ux)
    u_new = u + du
    
    # Apply limiting to prevent overflow
    u_new = np.clip(u_new, -10, 10)
    
    u = u_new.copy()

# Save final solution
np.save('u.npy', u)
```
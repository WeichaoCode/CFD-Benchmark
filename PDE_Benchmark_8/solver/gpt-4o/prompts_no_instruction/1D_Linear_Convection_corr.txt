```python
import numpy as np

# Parameters
c = 1.0  # Convection speed
epsilon_values = [0, 5e-4]  # Damping factors
x_start, x_end = -5, 5  # Spatial domain
N_x = 101  # Number of spatial grid points
dx = (x_end - x_start) / (N_x - 1)  # Spatial step size
x = np.linspace(x_start, x_end, N_x)  # Spatial grid

# Initial condition
u_initial = np.exp(-x**2)

# Time step based on CFL condition
CFL = 0.5  # CFL number
dt = CFL * dx / c  # Time step size
t_final = 2.0  # Final time
n_steps = int(t_final / dt)  # Number of time steps

# Function to apply periodic boundary conditions
def apply_periodic_bc(u):
    u[0] = u[-2]
    u[-1] = u[1]

# Predictor-Corrector method
def predictor_corrector(u, epsilon):
    u_new = np.copy(u)
    for _ in range(n_steps):
        # Predictor step
        u_star = np.copy(u)
        for i in range(1, N_x - 1):
            u_star[i] = u[i] - 0.5 * dt * c * (u[i+1] - u[i-1]) / (2 * dx) + \
                        0.5 * dt * epsilon * (u[i+1] - 2*u[i] + u[i-1]) / (dx**2)
        apply_periodic_bc(u_star)

        # Corrector step
        for i in range(1, N_x - 1):
            u_new[i] = u[i] - dt * c * (u_star[i+1] - u_star[i-1]) / (2 * dx) + \
                       dt * epsilon * (u_star[i+1] - 2*u_star[i] + u_star[i-1]) / (dx**2)
        apply_periodic_bc(u_new)

        # Update solution
        u[:] = u_new[:]

    return u

# Solve for each epsilon value and save the final solution
for epsilon in epsilon_values:
    u = np.copy(u_initial)
    u_final = predictor_corrector(u, epsilon)
    filename = f'u_final_epsilon_{epsilon}.npy'
    np.save(filename, u_final)
```

This code solves the given PDE using a Predictor-Corrector method with periodic boundary conditions. It handles both the undamped and damped cases by iterating over the specified `epsilon` values. The final solution for each case is saved as a `.npy` file.
```python
import numpy as np

# Domain parameters
nx, ny = 31, 31
dx = 2.0 / (nx - 1)
dy = 1.0 / (ny - 1)

# Initialize solution array
p = np.zeros((ny, nx))

# Apply initial condition
p[:, :] = 0

# Solve using finite difference method (Jacobi iteration)
max_iter = 10000
tolerance = 1e-6

for _ in range(max_iter):
    p_old = p.copy()
    
    # Update interior points using finite difference approximation
    for i in range(1, ny-1):
        for j in range(1, nx-1):
            p[i, j] = 0.25 * (p_old[i+1, j] + p_old[i-1, j] + 
                               p_old[i, j+1] + p_old[i, j-1])
    
    # Apply boundary conditions
    # Left boundary: p = 0
    p[:, 0] = 0
    
    # Right boundary: p = y 
    p[:, -1] = np.linspace(0, 1, ny)
    
    # Top and bottom Neumann boundary conditions (zero gradient)
    p[0, :] = p[1, :]
    p[-1, :] = p[-2, :]
    
    # Check convergence
    if np.max(np.abs(p - p_old)) < tolerance:
        break

# Save solution
np.save('p.npy', p)
```
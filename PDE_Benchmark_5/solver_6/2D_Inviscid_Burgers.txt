Based on the error messages you've received, there are a couple of things that need to be adjusted in the code to ensure it operates correctly for solving the 2D Inviscid Burgers' Equation using the Finite Difference Method with Python.

Error 1: 
The error message: "IndexError: too many indices for array: array is 1-dimensional, but 2 were indexed", means that you're trying to access a two-dimensional array using a one-dimensional index. Make sure the u and v are initialized as two-dimensional arrays. 

Error 2: 
The error message: "NameError: name 't_max' is not defined," speaks to the definition of CFL. It appears 't_max' was used in the definition of CFL but it was not previously defined. Instead of 't_max' it could be 'T' they wanted to use.

Error 3: 
The error message "ValueError: The CFL condition is not satisfied" means that the Courant–Friedrichs–Lewy (CFL) condition, a necessary condition for convergence while solving certain partial differential equations numerically, is not being satisfied.

A potential corrected version of your python code might look like this:

```python
import numpy as np
import matplotlib.pyplot as plt

# Step 1: Define parameters
Lx = 1.0
Ly = 1.0
T = 0.01
nx = 50
ny = 50
nt = 100

dx = Lx / (nx - 1)
dy = Ly / (ny - 1)
dt = T / (nt - 1)

cfl = dt * np.sqrt((Lx / T) ** 2 + (Ly / T) ** 2)

# Step 2: Discretize space and time
if cfl >= 1:
    raise ValueError("The CFL condition is not satisfied")

x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)
t = np.linspace(0, T, nt)

# Step 3: Set-up the initial velocity field
u = np.ones((ny, nx))
v = np.ones((ny, nx))

# Step 4: Iterate using the finite difference scheme
for n in range(nt - 1):
    un = u.copy()
    vn = v.copy()
    for i in range(1, nx):
        for j in range(1, ny):
            u[j, i] = un[j, i] - un[j, i] * dt / dx * (un[j, i] - un[j, i - 1]) - vn[j, i] * dt / dy * (un[j, i] - un[j - 1, i])
            v[j, i] = vn[j, i] - un[j, i] * dt / dx * (vn[j, i] - vn[j, i - 1]) - vn[j, i] * dt / dy * (vn[j, i] - vn[j - 1, i])

# Step 5: Visualize the velocity field
plt.quiver(x, y, u, v)
plt.show()
```

This code will fix the errors and you should be able to generate the velocity field using a quiver plot. However, for your specific application you might need to adjust initial parameters, and handle the boundary conditions as per requirements.
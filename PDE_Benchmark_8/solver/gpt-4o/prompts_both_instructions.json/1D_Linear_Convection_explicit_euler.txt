Below is the Python code to solve the given partial differential equation using the specified numerical method. The code handles both the undamped and damped cases, applies periodic boundary conditions, and saves the final solution to a `.npy` file.

```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
c = 1.0  # Convection speed
epsilon_undamped = 0.0
epsilon_damped = 5e-4
x_start, x_end = -5, 5
N_x = 101
dx = (x_end - x_start) / (N_x - 1)
x = np.linspace(x_start, x_end, N_x)

# Initial condition
u_initial = np.exp(-x**2)

# Time step based on CFL condition
CFL = 0.5
dt = CFL * dx / c

# Total time and number of time steps
t_final = 2.0
N_t = int(t_final / dt)

# Function to apply periodic boundary conditions
def apply_periodic_boundary(u):
    u[0] = u[-2]
    u[-1] = u[1]

# Function to solve the PDE
def solve_pde(epsilon):
    u = u_initial.copy()
    u_new = np.zeros_like(u)
    
    for n in range(N_t):
        # Central difference for spatial derivatives
        u_x = (u[2:] - u[:-2]) / (2 * dx)
        u_xx = (u[2:] - 2 * u[1:-1] + u[:-2]) / (dx**2)
        
        # Update using explicit Euler method
        u_new[1:-1] = u[1:-1] - c * dt * u_x + epsilon * dt * u_xx
        
        # Apply periodic boundary conditions
        apply_periodic_boundary(u_new)
        
        # Update solution
        u[:] = u_new[:]
    
    return u

# Solve for both undamped and damped cases
u_final_undamped = solve_pde(epsilon_undamped)
u_final_damped = solve_pde(epsilon_damped)

# Save the final solutions to .npy files
np.save('u_final_undamped.npy', u_final_undamped)
np.save('u_final_damped.npy', u_final_damped)

# Plot the results
plt.figure(figsize=(10, 5))
plt.plot(x, u_initial, label='Initial Condition', linestyle='--')
plt.plot(x, u_final_undamped, label='Final Undamped')
plt.plot(x, u_final_damped, label='Final Damped')
plt.xlabel('x')
plt.ylabel('u(x)')
plt.title('Wave Evolution')
plt.legend()
plt.grid(True)
plt.show()
```

### Explanation:
- **Domain and Discretization**: The spatial domain is discretized into 101 points, and the time step is determined using the CFL condition.
- **Initial Condition**: The initial wave profile is set as \( u(x,0) = e^{-x^2} \).
- **Numerical Method**: The explicit Euler method is used for time integration, and central differences are used for spatial derivatives.
- **Boundary Conditions**: Periodic boundary conditions are applied at each time step.
- **Solution and Output**: The final solution for both the undamped and damped cases is saved to `.npy` files. The wave evolution is also visualized using Matplotlib.
{
  "prompts": {
    "2D_Diffusion_FVM": "\n        You are given the **two-dimensional diffusion equation**, which models the steady-state diffusion of velocity in a square duct using the **Finite Volume Method (FVM)**.\n\n    ### **Governing Equation**\n    The equation governing the flow field is derived from the incompressible **Navier-Stokes equations** for the velocity component **w** in the z-direction:\n\n    \\[\n    \\nabla \\cdot ( \\mu \\nabla w ) - \\frac{dP}{dz} = 0\n    \\]\n\n    where:\n    - \\( w(x, y) \\) represents the velocity component in the z-direction.\n    - \\( \\mu \\) is the fluid's dynamic viscosity.\n    - \\( P \\) is the pressure.\n    - \\( \\nabla \\) is the two-dimensional gradient operator.\n\n    ### **Computational Domain**\n    - The flow is considered **steady** (\\( \\partial w / \\partial t = 0 \\)).\n    - The flow occurs in a **square duct** with sides of length \\( h = 0.1m \\).\n    - The **no-slip** boundary condition applies at all walls.\n    - The **fluid properties** are given as:\n      - Dynamic viscosity: \\( \\mu = 1 \\times 10^{-3} \\) Pa·s.\n      - Density: \\( \\rho = 1 \\) kg/m³.\n    - The **pressure gradient** is \\( dP/dz = -3.2 \\) Pa/m.\n\n    ### **Numerical Method**\n    - Use the **Finite Volume Method (FVM)** for discretization.\n    - Apply the **Gauss divergence theorem** to convert the governing PDE into a system of algebraic equations over **control volumes**.\n    - Use **centered finite differences** to approximate derivatives.\n    - Solve the resulting algebraic system iteratively using **Jacobi iteration**.\n\n    ### **Discretization**\n    - The domain is discretized into a **uniform Cartesian grid**.\n    - The control volume is centered at **P** with neighboring points **E, W, N, S**.\n    - The resulting algebraic equation at each grid point is:\n\n      \\[\n      a_P w_P = a_E w_E + a_W w_W + a_N w_N + a_S w_S - S_u\n      \\]\n\n    - Coefficients:\n\n      \\[\n      a_E = a_W = \\frac{\\mu \\Delta y}{\\Delta x}, \\quad a_N = a_S = \\frac{\\mu \\Delta x}{\\Delta y}\n      \\]\n\n      \\[\n      a_P = a_E + a_W + a_N + a_S\n      \\]\n\n    - The pressure gradient source term is:\n\n      \\[\n      S_u = \\frac{dP}{dz} \\Delta x \\Delta y\n      \\]\n\n    ### **Implementation Steps**\n    1. **Define the computational grid:**\n       - Grid points: **nx × ny**\n       - Grid spacing: **Δx = Δy = h / (nx - 1)**\n    \n    2. **Discretize the governing equation using the Finite Volume Method.**\n    \n    3. **Construct the coefficient matrix for the algebraic system.**\n    \n    4. **Solve for w using an iterative solver (Jacobi iteration).**\n    \n    5. **Visualize the solution**:\n       - Plot the velocity field \\( w(x,y) \\) using contour plots.\n\n    ### **Expected Output**\n    - A **contour plot** showing the velocity distribution in the square duct.\n    - Save the computed velocity field as a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "1D_Linear_Convection_corr": "\n    You are given the **one-dimensional linear convection equation**, which models wave propagation with convection and damping:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = \\epsilon \\frac{\\partial^2 u}{\\partial x^2}\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( c \\) is the convection speed,\n    - \\( \\epsilon \\) is a damping factor.\n\n    ### **Computational Domain**\n    - Solve the equation in a **periodic domain**:  \n      \\[\n      x \\in (-5, 5)\n      \\]\n    - The **initial condition** is given by:  \n      \\[\n      u_0 = e^{-x^2}\n      \\]\n    - Consider two cases:  \n      - **Undamped case**: \\( \\epsilon = 0 \\)  \n      - **Damped case**: \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    ### **Numerical Method**\n    - Use the **Predictor-Corrector Method** for **time discretization**.  \n    - Apply **2nd-order central differences** for **spatial discretization** of the derivatives.  \n    - Ensure numerical stability by choosing an appropriate time step.  \n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Spatial domain: \\( x \\in (-5,5) \\)  \n       - Number of grid points: \\( N_x = 101 \\)  \n       - Time step: \\( \\Delta t \\) determined using CFL condition  \n       - Convection speed: \\( c = 1 \\)  \n       - Damping factor: \\( \\epsilon = 0 \\) or \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    2. **Discretize the Domain:**\n       - Spatial grid: \\( x = \\{x_0, x_1, ..., x_{N_x-1}\\} \\)  \n       - Time steps: \\( t = \\{t_0, t_1, ..., t_{N_t-1}\\} \\)  \n\n    3. **Initialize Variables:**\n       - Set initial wave profile \\( u(x,0) = e^{-x^2} \\).  \n\n    4. **Time Integration using Predictor-Corrector Method:**\n       - **Predictor Step** (Explicit Euler Method):\n         \\[\n         u^{*} = u^n + \\Delta t f(t_n, u^n)\n         \\]\n       - **Corrector Step** (Trapezoidal Rule):\n         \\[\n         u^{n+1} = u^n + \\frac{\\Delta t}{2} \\left[ f(t_n, u^n) + f(t_{n+1}, u^{*}) \\right]\n         \\]\n       - Apply **periodic boundary conditions**.  \n\n    5. **Visualization:**\n       - Plot the **wave profile** at different time steps.  \n       - Compare the **damped** and **undamped** cases.  \n\n    ### **Expected Output**\n    The simulation should capture and visualize the following:  \n    - **Wave propagation over time**.  \n    - **Comparison between damped and undamped cases**.  \n    - **Final wave profile at \\( t = T \\)**.  \n\n    ### **Requirements**\n    - Use **NumPy** for numerical operations.  \n    - Use **Matplotlib** for visualization.  \n    - Save the computed solution in a `.npy` file.  \n\n    **Return only the Python code that implements this solution.**\n    ",
    "1D_Burgers_Equation": "You are given the **one-dimensional Burgers' equation**, a fundamental PDE that models **nonlinear convection** and **diffusion**:\n\n\\[\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n\\]\n\nwhere:\n- \\( u(x,t) \\) is the velocity field,\n- \\( \\nu \\) is the viscosity coefficient,\n- \\( x \\) is the spatial coordinate,\n- \\( t \\) is time.\nvariable declarations: \n- number of grid points in x: nx = 101\n- number of time steps: nt = 100\n- dx = 2 * numpy.pi / (nx - 1)\n- viscosity coefficient: nu = .07\n- dt = dx * nu\n\n### **Task:**\n1. **Numerically solve Burgers' equation** over a given spatial and temporal domain.\n2. Apply **periodic boundary conditions**:\n   \\[\n   u(0) = u(2\\pi)\n   \\]\n3. Use the following **initial condition**:\n   \\[\n   u = -\\frac{2\\nu}{\\phi} \\frac{\\partial \\phi}{\\partial x} + 4\n   \\]\n   where:\n   \\[\n   \\phi = \\exp{\\left(\\frac{-x^2}{4\\nu}\\right)} + \\exp{\\left(\\frac{-(x - 2\\pi)^2}{4\\nu}\\right)}\n   \\]\n4. Compare the numerical solution to the **analytical solution** given by:\n   \\[\n   u = -\\frac{2\\nu}{\\phi} \\frac{\\partial \\phi}{\\partial x} + 4\n   \\]\n   where:\n   \\[\n   \\phi = \\exp{\\left(\\frac{-(x - 4t)^2}{4\\nu(t + 1)}\\right)} + \\exp{\\left(\\frac{-(x - 4t - 2\\pi)^2}{4\\nu(t + 1)}\\right)}\n   \\]\n\n### **Requirements:**\n- Use an appropriate **finite difference scheme** for the numerical solution.\n- Ensure **stability and accuracy** of the scheme.\n- Output the numerical solution in a format that allows easy comparison with the analytical solution.\n- Save the velocity field at last time step in a .npy file.\n\n**Return only the Python code that implements this solution.**\n",
    "1D_Nonlinear_Convection_MK": "\n    You are given the **one-dimensional nonlinear convection equation**, a fundamental PDE that models **advection**:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( x \\) is the spatial coordinate,\n    - \\( t \\) is time.\n\n    ### **Computational Domain**\n    - Solve the equation in a periodic domain \\( x \\in [0, 2\\pi] \\)\n    - The initial condition is given by:\n      \\[\n      u(x,0) = \\sin(x) + 0.5 \\sin(0.5x)\n      \\]\n    - The domain has **periodic boundary conditions**.\n\n    ### **Numerical Method**\n    - Use the **MacCormack Method**, a predictor-corrector scheme:\n      - **Predictor Step**:\n        \\[\n        u^*_j = u^n_j - \\frac{\\Delta t}{\\Delta x} (F^n_{j+1} - F^n_j)\n        \\]\n      - **Corrector Step**:\n        \\[\n        u^{n+1}_j = \\frac{1}{2} \\left[ u^n_j + u^*_j - \\frac{\\Delta t}{\\Delta x} (F^*_j - F^*_{j-1}) \\right]\n        \\]\n    - Choose an appropriate time step \\( \\Delta t = 0.1 \\) to ensure numerical stability.\n\n    ### **Tasks**\n    1. Implement the MacCormack method to update \\( u(x,t) \\).\n    2. Apply periodic boundary conditions.\n    3. Simulate wave propagation over time.\n    4. Compare the solution with those from the Lax and Lax-Wendroff methods.\n\n    ### **Requirements**\n    - Use NumPy for numerical operations.\n    - Use Matplotlib to visualize the results.\n    - Save the computed solution in a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "2D_Laplace_Equation": "\n    You are given the **two-dimensional Laplace equation**, which describes steady-state diffusion phenomena and is used to model equilibrium solutions for various physical systems:\n\n    \\[\n    \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = 0\n    \\]\n\n    ### **Objective**\n    Solve this equation numerically using the **Finite Difference Method (FDM)**.\n\n    ### **Numerical Method**\n    - Use **central differencing** for the second derivatives in both spatial directions.\n    - The discretized form of the equation using a structured grid is:\n\n      \\[\n      \\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{\\Delta x^2} + \\frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{\\Delta y^2} = 0\n      \\]\n\n      Rearranging for \\( p_{i,j} \\):\n\n      \\[\n      p_{i,j} = \\frac{\\Delta y^2(p_{i+1,j} + p_{i-1,j}) + \\Delta x^2(p_{i,j+1} + p_{i,j-1})}{2(\\Delta x^2 + \\Delta y^2)}\n      \\]\n\n      This discretization is known as the **five-point difference operator**, which is iteratively solved until the solution converges.\n\n    ### **Initial and Boundary Conditions**\n    - **Initial Condition:** Assume \\( p = 0 \\) everywhere in the computational domain.\n    - **Boundary Conditions:**\n      - **Left boundary (\\( x = 0 \\))**: \\( p = 0 \\)\n      - **Right boundary (\\( x = 2 \\))**: \\( p = y \\)\n      - **Top and Bottom boundaries (\\( y = 0, 1 \\))**: Neumann boundary condition: \\( \\frac{\\partial p}{\\partial y} = 0 \\)\n\n    ### **Computational Domain and Parameters**\n    - Solve over a **rectangular domain** where:\n      - \\( x \\in [0, 2] \\), \\( y \\in [0, 1] \\)\n    - Grid resolution:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 31\\)\n      - Number of grid points in \\( y \\)-direction: \\( ny = 31\\)\n      - Spatial step sizes:\n        - \\( dx = \\frac{L_x}{nx - 1} \\)\n        - \\( dy = \\frac{L_y}{ny - 1} \\)\n\n    ### **Tasks**\n    1. Implement an **iterative finite difference solver** to compute the equilibrium solution of the 2D Laplace equation.\n    2. Use a **structured Cartesian grid** with uniform spacing.\n    3. Iterate until the solution converges, ensuring that the maximum change between iterations is below a predefined tolerance.\n    4. Visualize the computed solution using a **contour plot**.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** to generate contour plots of the solution.\n    - Implement iterative solvers such as **Jacobi iteration, Gauss-Seidel, or Successive Over-Relaxation (SOR)**.\n    - Ensure convergence and stability of the numerical scheme.\n    - Save the final p(x,y) in `.npy` format.\n    - Compare the numerical solution with the analytical solution:\n\n      \\[\n      p(x, y) = \\frac{x}{4} - \\frac{4}{\\pi} \\sum_{n=1, odd}^{\\infty} \\frac{1}{(n \\pi)^2} \\sinh(2 n \\pi) \\cos(n \\pi y)\n      \\]\n\n    **Return only the Python code that implements this solution.**\n    ",
    "2D_Linear_Convection": "\n    You are given the **two-dimensional linear convection equation**, which governs the transport of a scalar field in two spatial dimensions:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} + c \\frac{\\partial u}{\\partial y} = 0\n    \\]\n\n    where:\n    - \\( u(x, y, t) \\) is the scalar quantity being transported.\n    - \\( c \\) is the convection speed in both \\( x \\) and \\( y \\) directions.\n\n    ### **Objective**\n    Solve this equation numerically using the **Finite Difference Method (FDM)**.\n\n    ### **Numerical Method**\n    - Use **forward differencing** for the time derivative.\n    - Use **backward differencing** for the spatial derivatives.\n    - The numerical scheme is given by:\n\n      \\[\n      \\frac{u_{i,j}^{n+1} - u_{i,j}^{n}}{\\Delta t} + c \\frac{u_{i,j}^{n} - u_{i-1,j}^{n}}{\\Delta x} + c \\frac{u_{i,j}^{n} - u_{i,j-1}^{n}}{\\Delta y} = 0\n      \\]\n\n      Rearranging for \\( u_{i,j}^{n+1} \\):\n\n      \\[\n      u_{i,j}^{n+1} = u_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x} c (u_{i,j}^{n} - u_{i-1,j}^{n}) - \\frac{\\Delta t}{\\Delta y} c (u_{i,j}^{n} - u_{i,j-1}^{n})\n      \\]\n\n    ### **Initial Condition**\n    The initial condition is defined using a **hat function**, where:\n    - \\( u(x, y) = 2 \\) for \\( 0.5 \\leq x \\leq 1 \\) and \\( 0.5 \\leq y \\leq 1 \\).\n    - \\( u(x, y) = 1 \\) everywhere else.\n\n    ### **Boundary Conditions**\n    The value of \\( u(x, y) \\) is set to **1** on all boundaries:\n    - \\( u = 1 \\) for \\( x = 0, 2 \\).\n    - \\( u = 1 \\) for \\( y = 0, 2 \\).\n\n    ### **Computational Domain and Parameters**\n    - The equation is solved over a **square domain**:\n      - \\( x \\in [0, 2] \\), \\( y \\in [0, 2] \\).\n    - The **grid resolution** is:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 81 \\).\n      - Number of grid points in \\( y \\)-direction: \\( ny = 81 \\).\n      - Spatial step sizes:\n        - \\( dx = \\frac{L_x}{nx - 1} \\).\n        - \\( dy = \\frac{L_y}{ny - 1} \\).\n    - **Time-stepping parameters**:\n      - Number of time steps: \\( nt = 100\\).\n      - Stability parameter: \\( \\sigma = 0.2 \\).\n      - Time step:  \n        \\[\n        dt = \\sigma \\cdot \\frac{\\min(dx, dy)}{c}\n        \\]\n\n    ### **Tasks**\n    1. Implement the **Finite Difference Method** for solving the **2D Linear Convection Equation**.\n    2. Use a structured grid with uniform spacing.\n    3. Simulate the **propagation of the wave** over time.\n    4. Visualize the computed **solution field** using contour plots.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for visualization.\n    - Ensure **numerical stability** by choosing an appropriate time step based on the CFL condition.\n    - Save the computed solution \\( u(x, y) \\) in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "1D_Linear_Convection_Dufort_Frankel": "\n    You are given the **one-dimensional linear convection equation** with diffusion effects:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = \\epsilon \\frac{\\partial^2 u}{\\partial x^2}\n    \\]\n\n    ### **Objective**\n    Solve the equation numerically using the **Dufort-Frankel Method**.\n\n    ### **Numerical Method**\n    - The **Dufort-Frankel method** is an explicit time integration scheme that improves stability by using values from two previous time steps.\n    - It avoids the need for implicit solvers while allowing for larger time steps than explicit schemes.\n    - The scheme is given by:\n\n      \\[\n      u^{n+1}_i = \\frac{ (1 - 2r) u^{n-1}_i + 2r (u^n_{i+1} + u^n_{i-1}) }{1 + 2r}\n      \\]\n\n      where \\( r = \\frac{ \\epsilon \\Delta t}{\\Delta x^2} \\).\n\n    ### **Computational Domain and Parameters**\n    - **Domain**: \\( x \\in (-5,5) \\).\n    - **Initial Condition**: \\( u_0 = e^{-x^2} \\).\n    - **Boundary Conditions**: Periodic boundaries.\n    - **Convection Speed**: \\( c = 1 \\).\n    - **Diffusion Cases**:\n      - **Undamped:** \\( \\epsilon = 0 \\)\n      - **Damped:** \\( \\epsilon = 5 \\times 10^{-4} \\).\n\n    ### **Tasks**\n    1. Implement the **Dufort-Frankel method** for solving the **1D linear convection equation**.\n    2. Ensure numerical stability by setting an appropriate time step.\n    3. Apply periodic boundary conditions.\n    4. Visualize the solution over time.\n\n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed solution in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "1D_Nonlinear_Convection_LW": "\n    You are given the **one-dimensional nonlinear convection equation**, a fundamental PDE that models **advection**:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( x \\) is the spatial coordinate,\n    - \\( t \\) is time.\n\n    ### **Computational Domain**\n    - Solve the equation in a periodic domain \\( x \\in [0, 2\\pi] \\)\n    - The initial condition is given by:\n      \\[\n      u(x,0) = \\sin(x) + 0.5 \\sin(0.5x)\n      \\]\n    - The domain has **periodic boundary conditions**.\n\n    ### **Numerical Method**\n    - Use the **Lax-Wendroff Method**, which is second-order accurate in time:\n      \\[\n      u^{n+1}_j = u^n_j - \\frac{\\Delta t}{2 \\Delta x} (F^n_{j+1} - F^n_{j-1}) \n      + \\frac{\\Delta t^2}{2 \\Delta x^2} \\left(A_{j+1/2} (F^n_{j+1} - F^n_j) - A_{j-1/2} (F^n_j - F^n_{j-1}) \\right)\n      \\]\n    - Choose an appropriate time step \\( \\Delta t = 0.1 \\) to ensure numerical stability.\n\n    ### **Tasks**\n    1. Implement the Lax-Wendroff method to update \\( u(x,t) \\).\n    2. Apply periodic boundary conditions.\n    3. Simulate wave propagation over time.\n    4. Plot the solution and observe the difference compared to the Lax method.\n\n    ### **Requirements**\n    - Use NumPy for numerical operations.\n    - Use Matplotlib to visualize the results.\n    - Save the computed solution in a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "1D_Linear_Convection_adams": "\n    You are given the **one-dimensional linear convection equation**, which models wave propagation with convection and damping:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = \\epsilon \\frac{\\partial^2 u}{\\partial x^2}\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( c \\) is the convection speed,\n    - \\( \\epsilon \\) is a damping factor.\n\n    ### **Computational Domain**\n    - Solve the equation in a **periodic domain**:  \n      \\[\n      x \\in (-5, 5)\n      \\]\n    - The **initial condition** is given by:  \n      \\[\n      u_0 = e^{-x^2}\n      \\]\n    - Consider two cases:  \n      - **Undamped case**: \\( \\epsilon = 0 \\)  \n      - **Damped case**: \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    ### **Numerical Method**\n    - Use the **Adams-Bashforth Method** for **time discretization**.  \n    - Apply **2nd-order central differences** for **spatial discretization** of the derivatives.  \n    - Ensure numerical stability by choosing an appropriate time step.  \n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Spatial domain: \\( x \\in (-5,5) \\)  \n       - Number of grid points: \\( N_x = 101 \\)  \n       - Time step: \\( \\Delta t \\) determined using CFL condition  \n       - Convection speed: \\( c = 1 \\)  \n       - Damping factor: \\( \\epsilon = 0 \\) or \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    2. **Discretize the Domain:**\n       - Spatial grid: \\( x = \\{x_0, x_1, ..., x_{N_x-1}\\} \\)  \n       - Time steps: \\( t = \\{t_0, t_1, ..., t_{N_t-1}\\} \\)  \n\n    3. **Initialize Variables:**\n       - Set initial wave profile \\( u(x,0) = e^{-x^2} \\).  \n       - Use **Explicit Euler Method** to compute the first step since Adams-Bashforth requires prior time values.\n\n    4. **Time Integration using Adams-Bashforth Method:**\n       - For each time step:\n         - Compute the spatial derivatives using **central difference scheme**.  \n         - Apply the **2-step Adams-Bashforth Method**:\n           \\[\n           u^{n+1} = u^n + \\frac{\\Delta t}{2} \\left( 3 f(t_n, u^n) - f(t_{n-1}, u^{n-1}) \\right)\n           \\]\n         - Apply **periodic boundary conditions**.  \n\n    5. **Visualization:**\n       - Plot the **wave profile** at different time steps.  \n       - Compare the **damped** and **undamped** cases.  \n\n    ### **Expected Output**\n    The simulation should capture and visualize the following:  \n    - **Wave propagation over time**.  \n    - **Comparison between damped and undamped cases**.  \n    - **Final wave profile at \\( t = T \\)**.  \n\n    ### **Requirements**\n    - Use **NumPy** for numerical operations.  \n    - Use **Matplotlib** for visualization.  \n    - Save the computed solution in a `.npy` file.  \n\n    **Return only the Python code that implements this solution.**\n    ",
    "2D_Steady_Heat_Equation": "\n    You are given the **steady two-dimensional heat equation**, which models heat distribution over a rectangular domain:\n\n    \\[\n    \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = 0\n    \\]\n\n    ### **Computational Domain**\n    - The equation is solved in a **rectangular domain** with spatial coordinates:\n      - \\( x \\in [0, 5] \\), \\( y \\in [0, 4] \\)\n    - The domain is discretized using **finite difference methods** with a structured uniform grid.\n\n    ### **Boundary Conditions**\n    The temperature values along the boundaries of the domain are fixed:\n    - **Left boundary (AB)**: \\( T = 10^\\circ C \\)\n    - **Top boundary (CD)**: \\( T = 0^\\circ C \\)\n    - **Right boundary (EF)**: \\( T = 40^\\circ C \\)\n    - **Bottom boundary (G)**: \\( T = 20^\\circ C \\)\n\n    ### **Numerical Methods**\n    Solve the steady-state heat equation using one of the following iterative methods:\n\n    **1. Jacobi Method**  \n    - Update the temperature at each grid point using the average of its four neighboring points:\n      \\[\n      T_{i,j}^{k+1} = \\frac{T_{i+1,j}^{k} + T_{i-1,j}^{k} + \\beta^2 (T_{i,j+1}^{k} + T_{i,j-1}^{k})}{2(1 + \\beta^2)}\n      \\]\n      where \\( \\beta \\) is the grid aspect ratio \\( \\beta = \\frac{\\Delta x}{\\Delta y} \\).\n\n    **2. Gauss-Seidel Method**  \n    - Similar to the Jacobi method but updates each point immediately using newly computed values:\n      \\[\n      T_{i,j}^{k+1} = \\frac{T_{i+1,j}^{k} + T_{i-1,j}^{k} + \\beta^2 (T_{i,j+1}^{k+1} + T_{i,j-1}^{k+1})}{2(1 + \\beta^2)}\n      \\]\n\n    **3. Successive Over-Relaxation (SOR) Method**  \n    - A modified version of Gauss-Seidel with an **acceleration factor** \\( \\omega \\) to speed up convergence:\n      \\[\n      T_{i,j}^{k+1} = \\omega \\frac{T_{i+1,j}^{k} + T_{i-1,j}^{k} + \\beta^2 (T_{i,j+1}^{k+1} + T_{i,j-1}^{k+1})}{2(1 + \\beta^2)} + (1 - \\omega)T_{i,j}^{k}\n      \\]\n      where \\( 1 < \\omega < 2 \\) (For \\( \\omega = 1 \\), this reduces to the Gauss-Seidel method).\n\n    ### **Tasks**\n    1. Implement the selected iterative method (Jacobi, Gauss-Seidel, or SOR) for solving the **2D steady heat equation**.\n    2. Discretize the computational domain using a uniform structured grid.\n    3. Apply the given **Dirichlet boundary conditions**.\n    4. Iterate until convergence, using a stopping criterion based on **residual reduction**.\n    5. Visualize the **steady-state temperature distribution** as a contour plot.\n\n    ### **Requirements**\n    - Use **NumPy** for matrix computations.\n    - Use **Matplotlib** to generate contour plots of the temperature field.\n    - Save the final computed temperature field \\( T(x, y) \\) as a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "2D_Channel_Flow_Navier_Stokes": "\n    You are given the **two-dimensional channel flow problem** governed by the **Navier-Stokes equations**. The flow is driven by a constant source term \\( F \\) in the \\( u \\)-momentum equation to mimic pressure-driven channel flow.\n\n    ### **Governing Equations**\n    The modified incompressible Navier-Stokes equations are:\n\n    \\[\n    \frac{\\partial u}{\\partial t} + u \frac{\\partial u}{\\partial x} + v \frac{\\partial u}{\\partial y} = -\frac{1}{\rho} \frac{\\partial p}{\\partial x} + \nu \\left( \frac{\\partial^2 u}{\\partial x^2} + \frac{\\partial^2 u}{\\partial y^2} \right) + F\n    \\]\n\n    \\[\n    \frac{\\partial v}{\\partial t} + u \frac{\\partial v}{\\partial x} + v \frac{\\partial v}{\\partial y} = -\frac{1}{\rho} \frac{\\partial p}{\\partial y} + \nu \\left( \frac{\\partial^2 v}{\\partial x^2} + \frac{\\partial^2 v}{\\partial y^2} \right)\n    \\]\n\n    \\[\n    \frac{\\partial^2 p}{\\partial x^2} + \frac{\\partial^2 p}{\\partial y^2} = -\rho \\left( \frac{\\partial u}{\\partial x} \frac{\\partial u}{\\partial x} + 2 \frac{\\partial u}{\\partial y} \frac{\\partial v}{\\partial x} + \frac{\\partial v}{\\partial y} \frac{\\partial v}{\\partial y} \right)\n    \\]\n\n    where:\n    - \\( u(x,y,t) \\) and \\( v(x,y,t) \\) are the velocity components in the \\( x \\) and \\( y \\) directions.\n    - \\( p(x,y,t) \\) is the pressure field.\n    - \\( \rho \\) is the fluid density.\n    - \\( \nu \\) is the kinematic viscosity.\n    - \\( F \\) is the constant external force applied in the \\( x \\)-direction.\n\n    ### **Initial Condition:**\n    - The velocity components \\( u, v \\) and pressure \\( p \\) are initialized to **zero everywhere** in the domain.\n\n    ### **Boundary Conditions:**\n    - **Periodic boundary conditions** for \\( u, v, p \\) in the \\( x \\)-direction at \\( x = 0, 2 \\).\n    - **No-slip boundary condition** for \\( u, v \\) at \\( y = 0, 2 \\) (i.e., \\( u = 0, v = 0 \\)).\n    - **Pressure gradient condition:** \\( \frac{\\partial p}{\\partial y} = 0 \\) at \\( y = 0, 2 \\).\n    - **Source term:** \\( F = 1 \\) applied uniformly throughout the domain.\n\n    ### **Computational Domain and Parameters:**\n    - The equation is solved over a **rectangular domain** with spatial extent:\n      - \\( x \\in [0, 2] \\), \\( y \\in [0, 2] \\)\n    - The **fluid properties** are:\n      - Density: \\( \rho = 1 \\)\n      - Kinematic viscosity: \\( \nu = 0.1 \\)\n    - The equation is solved over a **rectangular grid** with:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 41 \\)\n      - Number of grid points in \\( y \\)-direction: \\( ny = 41 \\)\n      - Number of time steps: \\( nt = 10 \\)\n\n    ### **Tasks**\n    1. Implement the **Navier-Stokes solver** for **channel flow**.\n    2. Use a structured grid with uniform spacing.\n    3. Apply periodic and no-slip boundary conditions as specified.\n    4. Simulate the velocity and pressure field evolution over time.\n    5. Visualize the computed **velocity field** using quiver plots.\n\n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Ensure **numerical stability** by choosing an appropriate time step.\n    - Save the final velocity field (u, v) and pressure field (p) in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "2D_Diffusion": "\n    You are tasked with solving the **two-dimensional diffusion equation**, which models the spreading of a scalar field due to diffusion.\n\n    ### **Governing Equation**\n    The 2D diffusion equation is given by:\n\n    \\[\n    \frac{\\partial u}{\\partial t} = \nu \\left( \frac{\\partial^2 u}{\\partial x^2} + \frac{\\partial^2 u}{\\partial y^2} \right)\n    \\]\n\n    where:\n    - \\( u(x,y,t) \\) represents the diffused quantity (e.g., temperature or concentration),\n    - \\( nu \\) is the diffusion coefficient,\n    - \\( x, y \\) are the spatial coordinates,\n    - \\( t \\) is time.\n\n    ### **Computational Domain**\n    - **Spatial domain:** \\( x \\) and \\( y \\) both range from 0 to 2.\n    - **Grid parameters:**\n      - Number of grid points: \\( n_x = n_y = 31 \\).\n      - Grid spacing: \\( \\Delta x = \\Delta y = \frac{2}{n_x - 1} \\).\n    - **Temporal domain:**\n    - number of time steps: nt = 50\n    - sigma = .25\n    - dt = sigma * dx * dy / nu\n\n    ### **Initial and Boundary Conditions**\n    - **Initial condition:** \\( u = 2 \\) in the region \\( 0.5 \\leq x, y \\leq 1 \\), and \\( u = 1 \\) elsewhere.\n    - **Boundary conditions:** Fixed Dirichlet boundary conditions with \\( u = 1 \\) at all domain boundaries.\n\n    ### **Numerical Method**\n    - **Time integration:** Utilize the **Explicit Euler Method**.\n    - **Spatial discretization:** Use **second-order central differences** for the diffusion terms.\n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Set the domain size, grid resolution, diffusion coefficient, time step, and total simulation time.\n    2. **Initialize Variables:**\n       - Create a 2D array for \\( u \\) with the specified initial condition.\n    3. **Time Integration Loop:**\n       - For each time step until \\( t_{\text{final}} \\):\n         - Compute the temporary array \\( u_{\text{temp}} \\) using the current values of \\( u \\).\n         - Update \\( u \\) using the Explicit Euler formula:\n           \\[\n           u^{n+1}_{i,j} = u^n_{i,j} + \nu \\Delta t \\left( \frac{u^n_{i+1,j} - 2u^n_{i,j} + u^n_{i-1,j}}{\\Delta x^2} + \frac{u^n_{i,j+1} - 2u^n_{i,j} + u^n_{i,j-1}}{\\Delta y^2} \right)\n           \\]\n         - Apply boundary conditions to maintain \\( u = 1 \\) at the domain boundaries.\n    4. **Visualization:**\n       - Generate contour plots of \\( u \\) at selected time intervals to observe the evolution of the diffused field.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for plotting and visualization.\n    - Save the final solution \\( u \\) in a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "1D_Euler_Shock_Tube": "\n   You are given the **one-dimensional Euler equations**, which govern compressible flow dynamics in a **shock tube**. \n   \n   Your task is to numerically solve these equations using the **MacCormack method**.\n\n   ### **Governing Equations**\n   The Euler equations in conservative form are:\n\n   \\[\n   \\frac{\\partial \\mathbf{U}}{\\partial t} + \\frac{\\partial \\mathbf{F}}{\\partial x} = 0\n   \\]\n\n   where:\n\n   \\[\n   \\mathbf{U} = \n   \\begin{bmatrix} \n   \\rho \\\\ \n   \\rho u \\\\ \n   \\rho E \n   \\end{bmatrix}, \n   \\quad \n   \\mathbf{F} = \n   \\begin{bmatrix} \n   \\rho u \\\\ \n   \\rho u^2 + p \\\\ \n   u(\\rho E + p) \n   \\end{bmatrix}\n   \\]\n\n   with:\n\n   - \\( \\rho \\): Density  \n   - \\( u \\): Velocity  \n   - \\( p \\): Pressure  \n   - \\( E \\): Total energy per unit mass,  \n     \\( E = \\frac{p}{(\\gamma - 1)\\rho} + \\frac{u^2}{2} \\)  \n   - \\( \\gamma \\): Ratio of specific heats (typically 1.4 for air)\n\n   ### **Computational Domain**\n   - Spatial domain: \\( x \\in [-1, 1] \\)\n   - Temporal domain: \\( t \\in [0, 0.25] \\)\n\n   ### **Initial Conditions**\n   The shock tube is initially divided into two regions:\n\n   - **Left region** (\\( 0 \\leq x < x_0 \\)):\n     - \\( \\rho_L = 1.0 \\)\n     - \\( u_L = 0.0 \\)\n     - \\( p_L = 1.0 \\)\n\n   - **Right region** (\\( x_0 \\leq x \\leq L \\)):\n     - \\( \\rho_R = 0.125 \\)\n     - \\( u_R = 0.0 \\)\n     - \\( p_R = 0.1 \\)\n\n   ### **Boundary Conditions**\n   - **Reflective (no-flux) boundary conditions** at both ends of the tube.\n\n   ### **Numerical Method**\n   - Implement the **MacCormack Method**, a two-step predictor-corrector approach for hyperbolic systems.\n\n   ### **Implementation Steps**\n   1. **Define Parameters:**\n      - Tube length \\( L \\) 2\n      - Number of spatial points \\( N_x \\) N_x = 81\n      - Time step \\( \\Delta t \\) determined using CFL, CFL = 1\n      - Total simulation time \\( T \\) 0.25\n      - Ratio of specific heats \\( \\gamma \\) gamma = 1.4\n\n   2. **Discretize the Domain:**\n      - Spatial grid: \\( x = \\{x_0, x_1, ..., x_{N_x-1}\\} \\)\n      - Time steps: \\( t = \\{t_0, t_1, ..., t_{N_t-1}\\} \\)\n\n   3. **Initialize Variables:**\n      - Set initial \\( \\rho \\), \\( u \\), and \\( p \\) based on the initial conditions.\n      - Compute initial conservative variables \\( \\mathbf{U} \\).\n\n   4. **Time Integration:**\n      - For each time step:\n        - Compute flux \\( \\mathbf{F} \\) from \\( \\mathbf{U} \\).\n        - Apply the predictor step to estimate \\( \\mathbf{U}^{*} \\).\n        - Compute flux \\( \\mathbf{F}^{*} \\) from \\( \\mathbf{U}^{*} \\).\n        - Apply the corrector step to update \\( \\mathbf{U}^{n+1} \\).\n        - Update primitive variables \\( \\rho \\), \\( u \\), and \\( p \\) from \\( \\mathbf{U}^{n+1} \\).\n\n   5. **Visualization:**\n      - Plot the **density** (\\( \\rho \\)), **velocity** (\\( u \\)), and **pressure** (\\( p \\)) profiles at various time steps.\n      - Observe the formation of shock waves, contact discontinuities, and expansion fans.\n\n   ### **Expected Output**\n   The simulation should capture and visualize the following flow features over time:\n   - **Shock wave propagation**\n   - **Contact discontinuity movement**\n   - **Expansion fan formation**\n\n   ### **Requirements**\n   - Use an appropriate **finite difference scheme**.\n   - Ensure **stability and accuracy** using a suitable time step.\n   - Save the computed density, velocity, and pressure profiles in `.npy` format.\n   - Save mathbf{U}, mathbf{F} in `.npy` format.\n\n   **Return only the Python code that implements this solution.**\n",
    "1D_Linear_Convection_Explicit": "\n    You are given the **one-dimensional linear convection equation**:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = \\epsilon \\frac{\\partial^2 u}{\\partial x^2}\n    \\]\n\n    ### **Objective**\n    Solve the equation numerically using the **Simple Explicit Method**.\n\n    ### **Numerical Method**\n    - This method uses **forward differencing** for the time derivative.\n    - It applies **central differencing** for the second derivative in space.\n    - The discretized equation is:\n\n      \\[\n      \\frac{u_i^{n+1} - u_i^n}{\\Delta t} + c \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = \\epsilon \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{\\Delta x^2}\n      \\]\n\n    - Stability requires a **CFL condition**: \\( \\Delta t \\leq \\frac{\\Delta x}{c} \\).\n\n    ### **Computational Domain and Parameters**\n    - **Domain**: \\( x \\in (-5,5) \\).\n    - **Initial Condition**: \\( u_0 = e^{-x^2} \\).\n    - **Boundary Conditions**: Periodic boundaries.\n    - **Convection Speed**: \\( c = 1 \\).\n    - **Diffusion Cases**:\n      - **Undamped:** \\( \\epsilon = 0 \\)\n      - **Damped:** \\( \\epsilon = 5 \\times 10^{-4} \\).\n\n    ### **Tasks**\n    1. Implement the **Explicit Method** for solving the **1D linear convection equation**.\n    2. Ensure numerical stability using a CFL condition.\n    3. Apply periodic boundary conditions.\n    4. Visualize the solution over time.\n\n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed solution in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "2D_Inviscid_Burgers_FOU": "\n    You are given the **two-dimensional inviscid Burgers' equation**, which governs nonlinear convection of a velocity field in two spatial dimensions:\n\n    \\[\n    \\frac{\\partial \\mathbf{U}}{\\partial t} + \\mathbf{U} \\frac{\\partial \\mathbf{U}}{\\partial x} = 0\n    \\]\n\n    where:\n\n    \\[\n    \\mathbf{U} = \\begin{bmatrix} u \\\\ v \\end{bmatrix}, \\quad\n    \\mathbf{x} = \\begin{bmatrix} x \\\\ y \\end{bmatrix}\n    \\]\n\n    This system consists of two coupled nonlinear PDEs:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} + v \\frac{\\partial u}{\\partial y} = 0\n    \\]\n    \\[\n    \\frac{\\partial v}{\\partial t} + u \\frac{\\partial v}{\\partial x} + v \\frac{\\partial v}{\\partial y} = 0\n    \\]\n\n    ### **Objective**\n    Solve this equation numerically using the **First-Order Upwind Method**.\n\n    ### **Numerical Method**\n    - Use **forward differencing** for the time derivative.\n    - Use **backward differencing** for the spatial derivatives.\n    - The numerical scheme is given by:\n\n      \\[\n      \\frac{u_{i,j}^{n+1} - u_{i,j}^{n}}{\\Delta t} + u_{i,j}^{n} \\frac{u_{i,j}^{n} - u_{i-1,j}^{n}}{\\Delta x} + v_{i,j}^{n} \\frac{u_{i,j}^{n} - u_{i,j-1}^{n}}{\\Delta y} = 0\n      \\]\n\n      \\[\n      \\frac{v_{i,j}^{n+1} - v_{i,j}^{n}}{\\Delta t} + u_{i,j}^{n} \\frac{v_{i,j}^{n} - v_{i-1,j}^{n}}{\\Delta x} + v_{i,j}^{n} \\frac{v_{i,j}^{n} - v_{i,j-1}^{n}}{\\Delta y} = 0\n      \\]\n    ### **Initial Condition:**\n    The initial condition is defined using a **hat function**, where the velocity components \\( u(x,y) \\) and \\( v(x,y) \\) are initialized to **1** everywhere in the domain, \n    except in the region \\( 0.5 \\leq x \\leq 1 \\) and \\( 0.5 \\leq y \\leq 1 \\), where they are set to **2**.\n    \n    ### **Boundary Conditions:**\n    The velocity components \\( u(x,y) \\) and \\( v(x,y) \\) are set to **1** on all boundaries of the domain. \n    This represents **Dirichlet boundary conditions**, ensuring that the velocity remains fixed at 1 along the edges:\n    - **Top boundary** (\\( y = \\max \\)): \\( u = 1 \\), \\( v = 1 \\)\n    - **Bottom boundary** (\\( y = \\min \\)): \\( u = 1 \\), \\( v = 1 \\)\n    - **Left boundary** (\\( x = \\min \\)): \\( u = 1 \\), \\( v = 1 \\)\n    - **Right boundary** (\\( x = \\max \\)): \\( u = 1 \\), \\( v = 1 \\)\n    \n    ### **Computational Domain and Parameters:**\n    - The equation is solved over a **square domain** with spatial extent:\n      - \\( x \\in [0, 2] \\), \\( y \\in [0, 2] \\)\n    - The **grid resolution** is:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 151 \\)\n      - Number of grid points in \\( y \\)-direction: \\( ny = 151 \\)\n      - Spatial step sizes: \n        - \\( dx = \frac{L_x}{nx - 1} \\)\n        - \\( dy = \frac{L_y}{ny - 1} \\)\n    - **Time-stepping parameters:**\n      - Number of time steps: \\( nt = 300 \\)\n      - Stability parameter: \\( \\sigma = 0.2 \\)\n      - Time step:  \n        \\[\n        dt = \\sigma \\cdot \frac{\\min(dx, dy)}{2}\n        \\]\n\n    \n    ### **Tasks**\n    1. Implement the First-Order Upwind Method for solving the **2D Inviscid Burgers' equation**.\n    2. Use a structured grid with uniform spacing.\n    4. Simulate the velocity field evolution over time.\n    5. Visualize the computed **velocity field** using quiver plots.\n\n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Ensure **numerical stability** by choosing an appropriate time step based on the CFL condition.\n    - Save the final velocity field (u, v) in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "Fully_Developed_Turbulent_Channel_Flow_SA": "\n    You are given the **fully-developed turbulent flow in a channel**, governed by the **Reynolds-averaged Navier-Stokes (RANS) equations**. The goal is to solve for the mean velocity profile in the channel by modeling the Reynolds shear stress using an **eddy viscosity model**.\n\n    ### **Governing Equations**\n    The RANS equation for fully-developed turbulent flow in a channel is:\n\n    \\[\n    \\frac{d}{dy} \\left( (\\mu + \\mu_t) \\frac{du}{dy} \\right) = -1\n    \\]\n\n    where:\n    - \\( u(y) \\) is the mean velocity,\n    - \\( \\mu \\) is the molecular viscosity,\n    - \\( \\mu_t \\) is the eddy viscosity, representing the effects of turbulence.\n\n    Using the **Boussinesq approximation**, the Reynolds stress is modeled as:\n\n    \\[\n    \\rho \\overline{u_i' u_j'} \\approx \\mu_t \\left( \\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} \\right)\n    \\]\n\n    Defining an **effective viscosity** as \\( \\mu_{eff} = \\mu + \\mu_t \\), we can rewrite the equation as:\n\n    \\[\n    \\left[ \\frac{d \\mu_{eff}}{dy} \\frac{d}{dy} + \\mu_{eff} \\frac{d^2}{dy^2} \\right] u = -1\n    \\]\n\n    ### **Objective**\n    Solve for the mean velocity profile \\( u(y) \\) in a **fully-developed turbulent channel flow**.\n\n    ### **Numerical Method**\n    - Discretize the equation using **finite difference methods**.\n    - Solve the resulting **linear system** using an appropriate solver.\n    - Implement an **eddy viscosity model** to account for turbulence effects.\n\n    ### **Computational Domain and Parameters**\n    - The channel is **steady** and **fully-developed**.\n    - The mean velocity depends only on \\( y \\).\n    - Use an appropriate **grid resolution** in the \\( y \\)-direction.\n    \n    ### **Turbulence Model: Spalart-Allmaras Model**\n    The turbulence is governed by the transport equation:\n\n    \\[\n    0 = c_{b1} \\hat{S} \tilde{\nu} - c_{w1} f_w \\left( \frac{\tilde{\nu}}{y} \right)^2 + \frac{1}{c_{b3}} \frac{d}{dy} \\left[ (\nu + \tilde{\nu}) \frac{d \tilde{\nu}}{dy} \right] + \frac{c_{b2}}{c_{b3}} \\left( \frac{d \tilde{\nu}}{dy} \right)^2\n    \\]\n\n    where the eddy viscosity is:\n\n    \\[\n    \\mu_t = \rho \tilde{\nu} f_{v1}\n    \\]\n\n    with the following constants:\n    - \\( c_{v1} = 7.1 \\)\n    - \\( c_{b1} = 0.1355 \\)\n    - \\( c_{b2} = 0.622 \\)\n    - \\( c_{b3} = \frac{2}{3} \\)\n    - \\( c_{w1} = \frac{c_{b1}}{\\kappa^2} + \frac{1.0 + c_{b2}}{c_{b3}} \\)\n    - \\( c_{w2} = 0.3 \\)\n    - \\( c_{w3} = 2.0 \\)\n    - \\( \\kappa = 0.41 \\)\n\n    Additional functions:\n    - \\( f_{v1} = \frac{\\chi^3}{\\chi^3 + c_{v1}^3} \\), where \\( \\chi = \frac{\tilde{\nu}}{\nu} \\).\n\n    \n    ### **Tasks**\n    1. Implement the finite difference discretization for the governing equation.\n    2. Use an eddy viscosity model to define \\( \\mu_t \\).\n    3. Solve for the velocity profile \\( u(y) \\).\n    4. Visualize the velocity profile.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed velocity profile in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "2D_Burgers_Equation": "\n    You are given the **two-dimensional Burgers' equations**, which describe nonlinear convection and diffusion processes in fluid dynamics.\n\n    ### **Governing Equations**\n    The 2D Burgers' equations are expressed as:\n\n    \\[\n    \begin{align*}\n    \frac{\\partial u}{\\partial t} + u \frac{\\partial u}{\\partial x} + v \frac{\\partial u}{\\partial y} &= \nu \\left( \frac{\\partial^2 u}{\\partial x^2} + \frac{\\partial^2 u}{\\partial y^2} \right) \\\n    \frac{\\partial v}{\\partial t} + u \frac{\\partial v}{\\partial x} + v \frac{\\partial v}{\\partial y} &= \nu \\left( \frac{\\partial^2 v}{\\partial x^2} + \frac{\\partial^2 v}{\\partial y^2} \right)\n    \\end{align*}\n    \\]\n\n    where:\n    - \\( u(x,y,t) \\) and \\( v(x,y,t) \\) are the velocity components in the \\( x \\) and \\( y \\) directions, respectively.\n    - \\( nu \\) is the kinematic viscosity.\n\n    ### **Computational Domain**\n    - **Spatial domain:** \\( x \\) and \\( y \\) both range from 0 to 2.\n    - **Grid parameters:**\n      - Number of grid points in each direction: \\( n_x = n_y = 41 \\).\n      - Grid spacing: \\( \\Delta x = \\Delta y = \frac{2}{n_x - 1} \\).\n    - **Temporal domain:**\n    - number of time steps: nt = 120\n    - sigma = .0009\n    - nu = 0.01\n    - dt = sigma * dx * dy / nu\n\n    ### **Initial and Boundary Conditions**\n    - **Initial condition:** Both \\( u \\) and \\( v \\) are initialized to 1 throughout the domain, except in the region \\( 0.5 \\leq x, y \\leq 1 \\), where they are set to 2.\n    - **Boundary conditions:** All boundaries are subject to Dirichlet conditions with \\( u = 1 \\) and \\( v = 1 \\).\n\n    ### **Numerical Method**\n    - **Time integration:** Utilize the **Explicit Euler Method**.\n    - **Spatial discretization:** Apply **second-order central differences** for the spatial derivatives.\n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Set the domain size, grid resolution, time step, and viscosity.\n    2. **Initialize Variables:**\n       - Create 2D arrays for \\( u \\) and \\( v \\) with the specified initial conditions.\n    3. **Time Integration Loop:**\n       - For each time step until \\( t_{\text{final}} \\):\n         - Compute the temporary arrays \\( u_{\text{temp}} \\) and \\( v_{\text{temp}} \\) using the current values of \\( u \\) and \\( v \\).\n         - Update \\( u \\) and \\( v \\) using the Explicit Euler formula:\n           \\[\n           \begin{align*}\n           u^{n+1}_{i,j} &= u^n_{i,j} - \\Delta t \\left( u_{i,j} \frac{u_{i,j} - u_{i-1,j}}{\\Delta x} + v_{i,j} \frac{u_{i,j} - u_{i,j-1}}{\\Delta y} \right) \\\n           &+ \nu \\Delta t \\left( \frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{\\Delta x^2} + \frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{\\Delta y^2} \right) \\\n           v^{n+1}_{i,j} &= v^n_{i,j} - \\Delta t \\left( u_{i,j} \frac{v_{i,j} - v_{i-1,j}}{\\Delta x} + v_{i,j} \frac{v_{i,j} - v_{i,j-1}}{\\Delta y} \right) \\\n           &+ \nu \\Delta t \\left( \frac{v_{i+1,j} - 2v_{i,j} + v_{i-1,j}}{\\Delta x^2} + \frac{v_{i,j+1} - 2v_{i,j} + v_{i,j-1}}{\\Delta y^2} \right)\n           \\end{align*}\n           \\]\n         - Apply boundary conditions to maintain \\( u = 1 \\) and \\( v = 1 \\) at the domain boundaries.\n    4. **Visualization:**\n       - Generate surface plots of \\( u \\) and \\( v \\) at selected time intervals to observe the evolution of the velocity fields.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for plotting and visualization.\n    - Save the final velocity fields \\( u \\) and \\( v \\) in `.npy` files.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "Fully_Developed_Turbulent_Channel_Flow_k": "\n    You are given the **fully-developed turbulent flow in a channel**, governed by the **Reynolds-averaged Navier-Stokes (RANS) equations**. The goal is to solve for the mean velocity profile in the channel by modeling the Reynolds shear stress using an **eddy viscosity model**.\n\n    ### **Governing Equations**\n    The RANS equation for fully-developed turbulent flow in a channel is:\n\n    \\[\n    \\frac{d}{dy} \\left( (\\mu + \\mu_t) \\frac{du}{dy} \\right) = -1\n    \\]\n\n    where:\n    - \\( u(y) \\) is the mean velocity,\n    - \\( \\mu \\) is the molecular viscosity,\n    - \\( \\mu_t \\) is the eddy viscosity, representing the effects of turbulence.\n\n    Using the **Boussinesq approximation**, the Reynolds stress is modeled as:\n\n    \\[\n    \\rho \\overline{u_i' u_j'} \\approx \\mu_t \\left( \\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} \\right)\n    \\]\n\n    Defining an **effective viscosity** as \\( \\mu_{eff} = \\mu + \\mu_t \\), we can rewrite the equation as:\n\n    \\[\n    \\left[ \\frac{d \\mu_{eff}}{dy} \\frac{d}{dy} + \\mu_{eff} \\frac{d^2}{dy^2} \\right] u = -1\n    \\]\n\n    ### **Objective**\n    Solve for the mean velocity profile \\( u(y) \\) in a **fully-developed turbulent channel flow**.\n\n    ### **Numerical Method**\n    - Discretize the equation using **finite difference methods**.\n    - Solve the resulting **linear system** using an appropriate solver.\n    - Implement an **eddy viscosity model** to account for turbulence effects.\n\n    ### **Computational Domain and Parameters**\n    - The channel is **steady** and **fully-developed**.\n    - The mean velocity depends only on \\( y \\).\n    - Use an appropriate **grid resolution** in the \\( y \\)-direction.\n    \n    ### **Turbulence Model: Myong and Kasagi \\( k-\\epsilon \\) Model**\n    The turbulent kinetic energy equation:\n\n    \\[\n    0 = P_k - \rho \\epsilon + \frac{d}{dy} \\left[ (\\mu + \\mu_t / \\sigma_k) \frac{dk}{dy} \right]\n    \\]\n\n    The turbulent dissipation equation:\n\n    \\[\n    0 = \frac{\\epsilon}{k} (C_{\\epsilon 1} f_1 P_k - C_{\\epsilon 2} f_2 \\epsilon) + \frac{d}{dy} \\left[ (\\mu + \\mu_t / \\sigma_{\\epsilon}) \frac{d \\epsilon}{dy} \right]\n    \\]\n\n    The eddy viscosity is given by:\n\n    \\[\n    \\mu_t = C_{\\mu} f_{\\mu} \rho \frac{k^2}{\\epsilon}\n    \\]\n\n\n    \n    ### **Tasks**\n    1. Implement the finite difference discretization for the governing equation.\n    2. Use an eddy viscosity model to define \\( \\mu_t \\).\n    3. Solve for the velocity profile \\( u(y) \\).\n    4. Visualize the velocity profile.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed velocity profile in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "1D_Linear_Convection_explicit_euler": "\n    You are given the **one-dimensional linear convection equation**, which models wave propagation with convection and damping:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = \\epsilon \\frac{\\partial^2 u}{\\partial x^2}\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( c \\) is the convection speed\n    - \\( \\epsilon \\) is a damping factor.\n\n    ### **Computational Domain**\n    - Solve the equation in a **periodic domain**:  \n      \\[\n      x \\in (-5, 5)\n      \\]\n    - The **initial condition** is given by:  \n      \\[\n      u_0 = e^{-x^2}\n      \\]\n    - Consider two cases:  \n      - **Undamped case**: \\( \\epsilon = 0 \\)  \n      - **Damped case**: \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    ### **Numerical Method**\n    - Use the **Explicit Euler Method** for **time discretization**.  \n    - Apply **2nd-order central differences** for **spatial discretization** of the derivatives.  \n    - Ensure numerical stability by choosing an appropriate time step.\n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Spatial domain: \\( x \\in (-5,5) \\)  \n       - Number of grid points: \\( N_x = 101 \\)  \n       - Time step: \\( \\Delta t \\) determined using CFL condition  \n       - Convection speed: \\( c = 1 \\)  \n       - Damping factor: \\( \\epsilon = 0 \\) or \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    2. **Discretize the Domain:**\n       - Spatial grid: \\( x = \\{x_0, x_1, ..., x_{N_x-1}\\} \\)  \n       - Time steps: \\( t = \\{t_0, t_1, ..., t_{N_t-1}\\} \\)  \n\n    3. **Initialize Variables:**\n       - Set initial wave profile \\( u(x,0) = e^{-x^2} \\).  \n\n    4. **Time Integration using Explicit Euler Method:**\n       - For each time step:\n         - Compute the spatial derivatives using **central difference scheme**.  \n         - Update \\( u(x,t) \\) using the **Explicit Euler Method**.  \n         - Apply **periodic boundary conditions**.  \n\n    5. **Visualization:**\n       - Plot the **wave profile** at different time steps.  \n       - Compare the **damped** and **undamped** cases.  \n\n    ### **Expected Output**\n    The simulation should capture and visualize the following:  \n    - **Wave propagation over time**.  \n    - **Comparison between damped and undamped cases**.  \n    - **Final wave profile at \\( t = T \\)**.  \n\n    ### **Requirements**\n    - Use **NumPy** for numerical operations.  \n    - Use **Matplotlib** for visualization.  \n    - Save the computed solution in a `.npy` file.  \n\n    **Return only the Python code that implements this solution.**\n    ",
    "2D_Cavity_Flow_Navier_Stokes": "\n    You are given the **two-dimensional incompressible Navier-Stokes equations**, which describe the motion of a viscous fluid in a square cavity:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} + v \\frac{\\partial u}{\\partial y} = -\\frac{1}{\\rho} \\frac{\\partial p}{\\partial x} + \\nu \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\n    \\]\n\n    \\[\n    \\frac{\\partial v}{\\partial t} + u \\frac{\\partial v}{\\partial x} + v \\frac{\\partial v}{\\partial y} = -\\frac{1}{\\rho} \\frac{\\partial p}{\\partial y} + \\nu \\left( \\frac{\\partial^2 v}{\\partial x^2} + \\frac{\\partial^2 v}{\\partial y^2} \\right)\n    \\]\n\n    \\[\n    \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = -\\rho \\left( \\frac{\\partial u}{\\partial x} \\frac{\\partial u}{\\partial x} + 2 \\frac{\\partial u}{\\partial y} \\frac{\\partial v}{\\partial x} + \\frac{\\partial v}{\\partial y} \\frac{\\partial v}{\\partial y} \\right)\n    \\]\n\n    ### **Objective**\n    Solve the **2D cavity flow problem** numerically using the **finite difference method (FDM)**.\n\n    ### **Numerical Method**\n    - Discretize the momentum and pressure equations using finite difference schemes.\n    - Solve for velocity components \\( u \\) and \\( v \\) using an explicit time-stepping method.\n    - Solve for pressure \\( p \\) using an iterative solver.\n\n    ### **Initial Condition**\n    The velocity and pressure fields are initialized to **zero** everywhere:\n\n    \\[\n    u, v, p = 0\n    \\]\n\n    ### **Boundary Conditions**\n    - **Top boundary (Lid-driven motion)**:  \n      - \\( u = 1 \\) at \\( y = 2 \\)  \n      - \\( v = 0 \\) at \\( y = 2 \\)\n    - **Other boundaries (no-slip walls)**:  \n      - \\( u = 0 \\), \\( v = 0 \\)  \n    - **Pressure boundary conditions**:\n      - \\( \\frac{\\partial p}{\\partial y} = 0 \\) at \\( y = 0 \\)  \n      - \\( p = 0 \\) at \\( y = 2 \\)  \n      - \\( \\frac{\\partial p}{\\partial x} = 0 \\) at \\( x = 0, 2 \\)\n\n    ### **Computational Domain and Parameters**\n    - Solve in a **square cavity** with:  \n      - \\( x \\in [0,2] \\), \\( y \\in [0,2] \\)\n    - Grid resolution:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 41\\)  \n      - Number of grid points in \\( y \\)-direction: \\( ny = 41\\)  \n    - Time-stepping:\n      - Number of time steps: \\( nt = 500\\)  \n      - Time step size: \\( \\Delta t = 0.001\\)  \n    ### **Fluid Properties**\n    - The fluid density is set to **\\( \\rho = 1 \\)**.\n    - The kinematic viscosity is set to **\\( \\nu = 0.1 \\)**.\n\n    ### **Tasks**\n    1. Implement the **finite difference method (FDM)** for solving the **2D incompressible Navier-Stokes equations**.\n    2. Use a **structured grid** with uniform spacing.\n    3. Iterate over time and solve for \\( u, v, p \\).\n    4. Visualize the **velocity field (quiver plot)** and **pressure distribution (contour plot)**.\n\n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Ensure **numerical stability** by choosing an appropriate time step based on the CFL condition.\n    - Save the computed velocity \\( u, v \\) and pressure \\( p \\) in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "2D_Inviscid_Burgers_MK": "\n    You are given the **two-dimensional inviscid Burgers' equation**, which governs nonlinear convection of a velocity field in two spatial dimensions:\n    \n    \\[\n    \\frac{\\partial \\mathbf{U}}{\\partial t} + \\mathbf{U} \\frac{\\partial \\mathbf{U}}{\\partial x} = 0\n    \\]\n    \n    where:\n    \n    \\[\n    \\mathbf{U} = \\begin{bmatrix} u \\\\ v \\end{bmatrix}, \\quad\n    \\mathbf{x} = \\begin{bmatrix} x \\\\ y \\end{bmatrix}\n    \\]\n    \n    This system consists of two coupled nonlinear PDEs:\n    \n    \\[\n    \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} + v \\frac{\\partial u}{\\partial y} = 0\n    \\]\n    \\[\n    \\frac{\\partial v}{\\partial t} + u \\frac{\\partial v}{\\partial x} + v \\frac{\\partial v}{\\partial y} = 0\n    \\]\n    \n    ### **Objective**\n    Solve this equation numerically using the **First-Order Upwind Method**.\n    \n    ### **Numerical Method**\n    - Use **forward differencing** for the time derivative.\n    - Use **backward differencing** for the spatial derivatives.\n    - The numerical scheme is given by:\n    \n      \\[\n      \\frac{u_{i,j}^{n+1} - u_{i,j}^{n}}{\\Delta t} + u_{i,j}^{n} \\frac{u_{i,j}^{n} - u_{i-1,j}^{n}}{\\Delta x} + v_{i,j}^{n} \\frac{u_{i,j}^{n} - u_{i,j-1}^{n}}{\\Delta y} = 0\n      \\]\n    \n      \\[\n      \\frac{v_{i,j}^{n+1} - v_{i,j}^{n}}{\\Delta t} + u_{i,j}^{n} \\frac{v_{i,j}^{n} - v_{i-1,j}^{n}}{\\Delta x} + v_{i,j}^{n} \\frac{v_{i,j}^{n} - v_{i,j-1}^{n}}{\\Delta y} = 0\n      \\]\n    ### **Initial Condition:**\n    The initial condition is defined using a **hat function**, where the velocity components \\( u(x,y) \\) and \\( v(x,y) \\) are initialized to **1** everywhere in the domain, \n    except in the region \\( 0.5 \\leq x \\leq 1 \\) and \\( 0.5 \\leq y \\leq 1 \\), where they are set to **2**.\n    \n    ### **Boundary Conditions:**\n    The velocity components \\( u(x,y) \\) and \\( v(x,y) \\) are set to **1** on all boundaries of the domain. \n    This represents **Dirichlet boundary conditions**, ensuring that the velocity remains fixed at 1 along the edges:\n    - **Top boundary** (\\( y = \\max \\)): \\( u = 1 \\), \\( v = 1 \\)\n    - **Bottom boundary** (\\( y = \\min \\)): \\( u = 1 \\), \\( v = 1 \\)\n    - **Left boundary** (\\( x = \\min \\)): \\( u = 1 \\), \\( v = 1 \\)\n    - **Right boundary** (\\( x = \\max \\)): \\( u = 1 \\), \\( v = 1 \\)\n    \n    ### **Computational Domain and Parameters:**\n    - The equation is solved over a **square domain** with spatial extent:\n      - \\( x \\in [0, 2] \\), \\( y \\in [0, 2] \\)\n    - The **grid resolution** is:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 151 \\)\n      - Number of grid points in \\( y \\)-direction: \\( ny = 151 \\)\n      - Spatial step sizes: \n        - \\( dx = \frac{L_x}{nx - 1} \\)\n        - \\( dy = \frac{L_y}{ny - 1} \\)\n    - **Time-stepping parameters:**\n      - Number of time steps: \\( nt = 300 \\)\n      - Stability parameter: \\( \\sigma = 0.2 \\)\n      - Time step:  \n        \\[\n        dt = \\sigma \\cdot \frac{\\min(dx, dy)}{2}\n        \\]\n    \n    \n    ### **Tasks**\n    1. Implement the F**MacCormack Method** for solving the **2D Inviscid Burgers' equation**.\n    2. Use a structured grid with uniform spacing.\n    4. Simulate the velocity field evolution over time.\n    5. Visualize the computed **velocity field** using quiver plots.\n    \n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Ensure **numerical stability** by choosing an appropriate time step based on the CFL condition.\n    - Save the final velocity field (u, v) in `.npy` format.\n    \n    **Return only the Python code that implements this solution.**\n",
    "1D_Diffusion": "You are given the **one-dimensional diffusion equation**, a fundamental PDE that models **diffusive transport**:\n\n\\[\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n\\]\n\nwhere:\n- \\( u(x,t) \\) represents the quantity being diffused (e.g., temperature, concentration),\n- \\( \\nu \\) is the diffusion coefficient,\n- \\( x \\) is the spatial coordinate,\n- \\( t \\) is time.\n\n### **Variable Declarations:**\n- Number of grid points in x: `nx = 41`\n- Number of time steps: `nt = 20`\n- Grid spacing: `dx = 2 / (nx - 1)`\n- Diffusion coefficient: `nu = 0.3`\n- sigma = 0.2\n- Time step: `dt = sigma * dx**2 / nu`\n\n### **Task:**\n1. **Numerically solve the diffusion equation** over a given spatial and temporal domain.\n2. Apply **Dirichlet boundary conditions**:\n   \\[\n   u(0) = 1, \\quad u(1) = 0\n   \\]\n3. Use the following **initial condition**:\n   - At \\( t = 0 \\), let \\( u(x, 0) = 2 \\) for \\( 0.5 \\leq x \\leq 1 \\), and \\( u = 1 \\) elsewhere.\n4. **Visualize the solution**:\n   - Generate plots showing how the field \\( u(x, t) \\) evolves over time.\n   - Show the final solution at \\( t = T \\).\n\n### **Requirements:**\n- Use an appropriate **finite difference scheme** for the numerical solution.\n- Ensure **stability and accuracy** by choosing an appropriate time step.\n- Save the computed solution in a `.npy` file.\n\n**Return only the Python code that implements this solution.**\n",
    "1D_Linear_Convection_ADI": "\n    You are given the **one-dimensional linear convection equation** with diffusion effects:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = \\epsilon \\frac{\\partial^2 u}{\\partial x^2}\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( c \\) is the convection speed,\n    - \\( \\epsilon \\) is a damping coefficient.\n\n    ### **Objective**\n    Solve the equation numerically using the **Alternating Direction Implicit (ADI) Method**.\n\n    ### **Numerical Method**\n    - ADI splits the solution into two alternating time steps where half of the equation is solved implicitly.\n    - First, solve for an intermediate state using an implicit scheme in the x-direction.\n    - Then, solve for the next time step using an implicit scheme in the other direction.\n    - This method allows for stable solutions with larger time steps.\n\n    ### **Computational Domain and Parameters**\n    - The equation is solved in a **periodic domain**: \\( x \\in (-5,5) \\).\n    - The initial condition is given as:\n\n      \\[\n      u_0 = e^{-x^2}\n      \\]\n\n    - Two cases are considered:\n      - **Undamped case:** \\( \\epsilon = 0 \\)\n      - **Damped case:** \\( \\epsilon = 5 \\times 10^{-4} \\)\n    - Convection speed: \\( c = 1 \\).\n\n    ### **Tasks**\n    1. Implement the **ADI Method** to solve the **1D linear convection equation**.\n    2. Use a structured grid with uniform spacing.\n    3. Apply periodic boundary conditions.\n    4. Visualize the solution over time.\n\n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed solution in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "1D_Linear_Convection_rk": "\n    You are given the **one-dimensional linear convection equation**, which models wave propagation with convection and damping:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = \\epsilon \\frac{\\partial^2 u}{\\partial x^2}\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( c \\) is the convection speed,\n    - \\( \\epsilon \\) is a damping factor.\n\n    ### **Computational Domain**\n    - Solve the equation in a **periodic domain**:  \n      \\[\n      x \\in (-5, 5)\n      \\]\n    - The **initial condition** is given by:  \n      \\[\n      u_0 = e^{-x^2}\n      \\]\n    - Consider two cases:  \n      - **Undamped case**: \\( \\epsilon = 0 \\)  \n      - **Damped case**: \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    ### **Numerical Method**\n    - Use the **4th-order Runge-Kutta (RK4) Method** for **time discretization**.  \n    - Apply **2nd-order central differences** for **spatial discretization** of the derivatives.  \n    - Ensure numerical stability by choosing an appropriate time step.  \n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Spatial domain: \\( x \\in (-5,5) \\)  \n       - Number of grid points: \\( N_x = 101 \\)  \n       - Time step: \\( \\Delta t \\) determined using CFL condition  \n       - Convection speed: \\( c = 1 \\)  \n       - Damping factor: \\( \\epsilon = 0 \\) or \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    2. **Discretize the Domain:**\n       - Spatial grid: \\( x = \\{x_0, x_1, ..., x_{N_x-1}\\} \\)  \n       - Time steps: \\( t = \\{t_0, t_1, ..., t_{N_t-1}\\} \\)  \n\n    3. **Initialize Variables:**\n       - Set initial wave profile \\( u(x,0) = e^{-x^2} \\).  \n\n    4. **Time Integration using Runge-Kutta Method:**\n       - Compute four intermediate slopes:\n         - \\( k_1 = f(t_n, u^n) \\)\n         - \\( k_2 = f(t_n + \\frac{\\Delta t}{2}, u^n + \\frac{\\Delta t}{2} k_1) \\)\n         - \\( k_3 = f(t_n + \\frac{\\Delta t}{2}, u^n + \\frac{\\Delta t}{2} k_2) \\)\n         - \\( k_4 = f(t_n + \\Delta t, u^n + \\Delta t k_3) \\)\n       - Update the solution using:\n         \\[\n         u^{n+1} = u^n + \\frac{\\Delta t}{6} \\left[ k_1 + 2k_2 + 2k_3 + k_4 \\right]\n         \\]\n       - Apply **periodic boundary conditions**.  \n\n    5. **Visualization:**\n       - Plot the **wave profile** at different time steps.  \n       - Compare the **damped** and **undamped** cases.  \n\n    ### **Expected Output**\n    The simulation should capture and visualize the following:  \n    - **Wave propagation over time**.  \n    - **Comparison between damped and undamped cases**.  \n    - **Final wave profile at \\( t = T \\)**.  \n\n    ### **Requirements**\n    - Use **NumPy** for numerical operations.  \n    - Use **Matplotlib** for visualization.  \n    - Save the computed solution in a `.npy` file.  \n\n    **Return only the Python code that implements this solution.**\n    ",
    "1D_Nonlinear_Convection_Lax": "\n    You are given the **one-dimensional nonlinear convection equation**, a fundamental PDE that models **advection**:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( x \\) is the spatial coordinate,\n    - \\( t \\) is time.\n\n    ### **Computational Domain**\n    - Solve the equation in a periodic domain \\( x \\in [0, 2\\pi] \\)\n    - The initial condition is given by:\n      \\[\n      u(x,0) = \\sin(x) + 0.5 \\sin(0.5x)\n      \\]\n    - The domain has **periodic boundary conditions**.\n\n    ### **Numerical Method**\n    - Use the **Lax Method**, which replaces the time-centered term with the average of adjacent nodes:\n      \\[\n      u^{n+1}_j = \\frac{u^n_{j+1} + u^n_{j-1}}{2} - \\frac{\\Delta t}{2\\Delta x} (F^n_{j+1} - F^n_{j-1})\n      \\]\n    - Choose an appropriate time step \\( \\Delta t = 0.1 \\) to ensure numerical stability.\n\n    ### **Tasks**\n    1. Implement the Lax method to update \\( u(x,t) \\).\n    2. Apply periodic boundary conditions.\n    3. Simulate wave propagation over time.\n    4. Plot the solution and observe numerical dissipation effects.\n\n    ### **Requirements**\n    - Use NumPy for numerical operations.\n    - Use Matplotlib to visualize the results.\n    - Save the computed solution in a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "2D_Convection": "\n    You are tasked with solving the **two-dimensional nonlinear convection equations**, which model the transport of quantities in a fluid flow.\n\n    ### **Governing Equations**\n    The 2D nonlinear convection equations are given by:\n\n    \\[\n    \begin{align*}\n    \frac{\\partial u}{\\partial t} + u \frac{\\partial u}{\\partial x} + v \frac{\\partial u}{\\partial y} &= 0 \\\n    \frac{\\partial v}{\\partial t} + u \frac{\\partial v}{\\partial x} + v \frac{\\partial v}{\\partial y} &= 0\n    \\end{align*}\n    \\]\n\n    where:\n    - \\( u(x,y,t) \\) and \\( v(x,y,t) \\) are the velocity components in the \\( x \\) and \\( y \\) directions, respectively.\n\n    ### **Computational Domain**\n    - **Spatial domain:** \\( x \\) and \\( y \\) both range from 0 to 2.\n    - **Grid parameters:**\n      - Number of grid points in each direction: \\( n_x = n_y = 101 \\).\n      - Grid spacing: \\( \\Delta x = \\Delta y = \frac{2}{n_x - 1} \\).\n    - **Temporal domain:**\n    - number of time steps: nt = 80\n    - sigma = 0.2\n    - dt = sigma * dx\n\n    ### **Initial and Boundary Conditions**\n    - **Initial condition:** Both \\( u \\) and \\( v \\) are initialized to 1 throughout the domain, except in the region \\( 0.5 \\leq x, y \\leq 1 \\), where they are set to 2.\n    - **Boundary conditions:** All boundaries are subject to Dirichlet conditions with \\( u = 1 \\) and \\( v = 1 \\).\n\n    ### **Numerical Method**\n    - **Time integration:** Utilize the **Explicit Euler Method**.\n    - **Spatial discretization:** Apply **first-order upwind differences** for the convection terms.\n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Set the domain size, grid resolution, time step, and total simulation time.\n    2. **Initialize Variables:**\n       - Create 2D arrays for \\( u \\) and \\( v \\) with the specified initial conditions.\n    3. **Time Integration Loop:**\n       - For each time step until \\( t_{\text{final}} \\):\n         - Compute the temporary arrays \\( u_{\text{temp}} \\) and \\( v_{\text{temp}} \\) using the current values of \\( u \\) and \\( v \\).\n         - Update \\( u \\) and \\( v \\) using the Explicit Euler formula:\n           \\[\n           \begin{align*}\n           u^{n+1}_{i,j} &= u^n_{i,j} - \\Delta t \\left( u_{i,j} \frac{u_{i,j} - u_{i-1,j}}{\\Delta x} + v_{i,j} \frac{u_{i,j} - u_{i,j-1}}{\\Delta y} \right) \\\n           v^{n+1}_{i,j} &= v^n_{i,j} - \\Delta t \\left( u_{i,j} \frac{v_{i,j} - v_{i-1,j}}{\\Delta x} + v_{i,j} \frac{v_{i,j} - v_{i,j-1}}{\\Delta y} \right)\n           \\end{align*}\n           \\]\n         - Apply boundary conditions to maintain \\( u = 1 \\) and \\( v = 1 \\) at the domain boundaries.\n    4. **Visualization:**\n       - Generate surface plots of \\( u \\) and \\( v \\) at selected time intervals to observe the evolution of the velocity fields.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for plotting and visualization.\n    - Save the final velocity fields \\( u \\) and \\( v \\) in `.npy` files.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "Fully_Developed_Turbulent_Channel_Flow_Cess": "\n    You are given the **fully-developed turbulent flow in a channel**, governed by the **Reynolds-averaged Navier-Stokes (RANS) equations**. The goal is to solve for the mean velocity profile in the channel by modeling the Reynolds shear stress using an **eddy viscosity model**.\n\n    ### **Governing Equations**\n    The RANS equation for fully-developed turbulent flow in a channel is:\n\n    \\[\n    \\frac{d}{dy} \\left( (\\mu + \\mu_t) \\frac{du}{dy} \\right) = -1\n    \\]\n\n    where:\n    - \\( u(y) \\) is the mean velocity,\n    - \\( \\mu \\) is the molecular viscosity,\n    - \\( \\mu_t \\) is the eddy viscosity, representing the effects of turbulence.\n\n    Using the **Boussinesq approximation**, the Reynolds stress is modeled as:\n\n    \\[\n    \\rho \\overline{u_i' u_j'} \\approx \\mu_t \\left( \\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} \\right)\n    \\]\n\n    Defining an **effective viscosity** as \\( \\mu_{eff} = \\mu + \\mu_t \\), we can rewrite the equation as:\n\n    \\[\n    \\left[ \\frac{d \\mu_{eff}}{dy} \\frac{d}{dy} + \\mu_{eff} \\frac{d^2}{dy^2} \\right] u = -1\n    \\]\n\n    ### **Objective**\n    Solve for the mean velocity profile \\( u(y) \\) in a **fully-developed turbulent channel flow**.\n\n    ### **Numerical Method**\n    - Discretize the equation using **finite difference methods**.\n    - Solve the resulting **linear system** using an appropriate solver.\n    - Implement an **eddy viscosity model** to account for turbulence effects.\n\n    ### **Computational Domain and Parameters**\n    - The channel is **steady** and **fully-developed**.\n    - The mean velocity depends only on \\( y \\).\n    - Use an appropriate **grid resolution** in the \\( y \\)-direction.\n    \n    ### **Turbulence Model: Cess Algebraic Model**\n    The eddy viscosity is modeled as:\n\n    \\[\n    \frac{\\mu_{eff}}{\\mu} = \frac{1}{2} \\left( 1 + \frac{1}{9} \\kappa^2 Re_{\tau}^2 (2y - y^2)^2 (3 - 4y + 2y^2)^2 \n    \\left[ 1 - \\exp \\left( -\frac{y^+}{A} \right) \right]^2 \right)^{1/2} - \frac{1}{2}\n    \\]\n\n    where:\n    - \\( \\kappa = 0.42 \\) (von Kármán constant)\n    - \\( A = 25.4 \\)\n    - \\( y^+ = y Re_{\tau} \\)\n    - \\( Re_{\tau} = \frac{\rho u_{\tau} H}{\\mu} \\) (friction Reynolds number)\n    - \\( u^+ = \\sqrt{\frac{\tau_w}{\rho}} \\) (dimensionless velocity)\n    - \\( \tau_w = \\mu \\left( \frac{du}{dy} \right)_{w} \\) (wall shear stress)\n    - \\( H \\) is the **channel height**.\n    \n    ### **Tasks**\n    1. Implement the finite difference discretization for the governing equation.\n    2. Use an eddy viscosity model to define \\( \\mu_t \\).\n    3. Solve for the velocity profile \\( u(y) \\).\n    4. Visualize the velocity profile.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed velocity profile in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "2D_Poisson_Equation": "\n    You are given the **two-dimensional Poisson equation**, which introduces a source term to the Laplace equation:\n\n    \\[\n    \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = b\n    \\]\n\n    Unlike the Laplace equation, the Poisson equation includes a finite source term that affects the solution, acting to \"relax\" the initial sources in the field.\n\n    ### **Objective**\n    Solve the **2D Poisson equation** numerically using an iterative finite-difference approach.\n\n    ### **Numerical Method**\n    - Discretize the equation using **second-order central differencing** for both spatial derivatives.\n    - The discretized form of the equation is:\n\n      \\[\n      \\frac{p_{i+1,j}^{n} - 2p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n} - 2p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta y^2} = b_{i,j}^{n}\n      \\]\n\n    - Rearranging for \\( p_{i,j}^{n} \\), the update formula is:\n\n      \\[\n      p_{i,j}^{n} = \\frac{(p_{i+1,j}^{n} + p_{i-1,j}^{n}) \\Delta y^2 + (p_{i,j+1}^{n} + p_{i,j-1}^{n}) \\Delta x^2 - b_{i,j}^{n} \\Delta x^2 \\Delta y^2}{2(\\Delta x^2 + \\Delta y^2)}\n      \\]\n\n    ### **Initial Condition:**\n    - Assume an **initial state** of \\( p = 0 \\) everywhere.\n\n    ### **Boundary Conditions:**\n    - **Dirichlet boundary conditions**:\n      - \\( p = 0 \\) at \\( x = 0, 2 \\) and \\( y = 0, 1 \\).\n\n    ### **Source Term (RHS \\( b_{i,j} \\)):**\n    - The source term consists of **two initial spikes** inside the domain:\n      - \\( b_{i,j} = 100 \\) at \\( i = \\frac{1}{4} nx, j = \\frac{1}{4} ny \\).\n      - \\( b_{i,j} = -100 \\) at \\( i = \\frac{3}{4} nx, j = \\frac{3}{4} ny \\).\n      - \\( b_{i,j} = 0 \\) elsewhere.\n\n    ### **Computational Domain and Parameters:**\n    - The equation is solved over a **rectangular grid** with:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 50\\)\n      - Number of grid points in \\( y \\)-direction: \\( ny = 50\\)\n      - Spatial step sizes: \n        - \\( dx = \\frac{L_x}{nx - 1} \\)\n        - \\( dy = \\frac{L_y}{ny - 1} \\)\n\n    ### **Tasks**\n    1. Implement the **2D Poisson solver** using an iterative approach.\n    2. Discretize the domain using a structured grid with uniform spacing.\n    3. Apply the specified boundary and source conditions.\n    4. Iterate until convergence is reached.\n    5. Visualize the computed **pressure field** using contour plots.\n\n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Ensure **numerical stability** with appropriate stopping criteria.\n    - Save the final pressure field \\( p \\) in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "Fully_Developed_Turbulent_Channel_Flow_SST": "\n    You are given the **fully-developed turbulent flow in a channel**, governed by the **Reynolds-averaged Navier-Stokes (RANS) equations**. The goal is to solve for the mean velocity profile in the channel by modeling the Reynolds shear stress using an **eddy viscosity model**.\n\n    ### **Governing Equations**\n    The RANS equation for fully-developed turbulent flow in a channel is:\n\n    \\[\n    \\frac{d}{dy} \\left( (\\mu + \\mu_t) \\frac{du}{dy} \\right) = -1\n    \\]\n\n    where:\n    - \\( u(y) \\) is the mean velocity,\n    - \\( \\mu \\) is the molecular viscosity,\n    - \\( \\mu_t \\) is the eddy viscosity, representing the effects of turbulence.\n\n    Using the **Boussinesq approximation**, the Reynolds stress is modeled as:\n\n    \\[\n    \\rho \\overline{u_i' u_j'} \\approx \\mu_t \\left( \\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} \\right)\n    \\]\n\n    Defining an **effective viscosity** as \\( \\mu_{eff} = \\mu + \\mu_t \\), we can rewrite the equation as:\n\n    \\[\n    \\left[ \\frac{d \\mu_{eff}}{dy} \\frac{d}{dy} + \\mu_{eff} \\frac{d^2}{dy^2} \\right] u = -1\n    \\]\n\n    ### **Objective**\n    Solve for the mean velocity profile \\( u(y) \\) in a **fully-developed turbulent channel flow**.\n\n    ### **Numerical Method**\n    - Discretize the equation using **finite difference methods**.\n    - Solve the resulting **linear system** using an appropriate solver.\n    - Implement an **eddy viscosity model** to account for turbulence effects.\n\n    ### **Computational Domain and Parameters**\n    - The channel is **steady** and **fully-developed**.\n    - The mean velocity depends only on \\( y \\).\n    - Use an appropriate **grid resolution** in the \\( y \\)-direction.\n    \n    ### **Turbulence Model: Menter SST Model**\n    The turbulent kinetic energy equation:\n\n    \\[\n    0 = P_k - \beta^* \rho k \\omega + \frac{d}{dy} \\left[ (\\mu + \\mu_t / \\sigma_k) \frac{dk}{dy} \right]\n    \\]\n\n    The specific turbulent dissipation equation:\n\n    \\[\n    0 = \rho \u0007lpha \frac{P_k}{\\mu_t} - \beta \rho \\omega^2 + \frac{d}{dy} \\left[ (\\mu + \\mu_t \\sigma_{\\omega}) \frac{d\\omega}{dy} \right] + (1 - F_1) C_{D \\omega}\n    \\]\n\n    The eddy viscosity is given by:\n\n    \\[\n    \\mu_t = \rho k \\min \\left( \frac{1}{\\omega}, \frac{a_1}{|S|F_2} \right)\n    \\]\n\n    \n    ### **Tasks**\n    1. Implement the finite difference discretization for the governing equation.\n    2. Use an eddy viscosity model to define \\( \\mu_t \\).\n    3. Solve for the velocity profile \\( u(y) \\).\n    4. Visualize the velocity profile.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed velocity profile in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
    "Fully_Developed_Turbulent_Channel_Flow_V2F": "\n    You are given the **fully-developed turbulent flow in a channel**, governed by the **Reynolds-averaged Navier-Stokes (RANS) equations**. The goal is to solve for the mean velocity profile in the channel by modeling the Reynolds shear stress using an **eddy viscosity model**.\n\n    ### **Governing Equations**\n    The RANS equation for fully-developed turbulent flow in a channel is:\n\n    \\[\n    \\frac{d}{dy} \\left( (\\mu + \\mu_t) \\frac{du}{dy} \\right) = -1\n    \\]\n\n    where:\n    - \\( u(y) \\) is the mean velocity,\n    - \\( \\mu \\) is the molecular viscosity,\n    - \\( \\mu_t \\) is the eddy viscosity, representing the effects of turbulence.\n\n    Using the **Boussinesq approximation**, the Reynolds stress is modeled as:\n\n    \\[\n    \\rho \\overline{u_i' u_j'} \\approx \\mu_t \\left( \\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} \\right)\n    \\]\n\n    Defining an **effective viscosity** as \\( \\mu_{eff} = \\mu + \\mu_t \\), we can rewrite the equation as:\n\n    \\[\n    \\left[ \\frac{d \\mu_{eff}}{dy} \\frac{d}{dy} + \\mu_{eff} \\frac{d^2}{dy^2} \\right] u = -1\n    \\]\n\n    ### **Objective**\n    Solve for the mean velocity profile \\( u(y) \\) in a **fully-developed turbulent channel flow**.\n\n    ### **Numerical Method**\n    - Discretize the equation using **finite difference methods**.\n    - Solve the resulting **linear system** using an appropriate solver.\n    - Implement an **eddy viscosity model** to account for turbulence effects.\n\n    ### **Computational Domain and Parameters**\n    - The channel is **steady** and **fully-developed**.\n    - The mean velocity depends only on \\( y \\).\n    - Use an appropriate **grid resolution** in the \\( y \\)-direction.\n    \n    ### **Turbulence Model: V2F Model**\n    The turbulent kinetic energy equation:\n\n    \\[\n    0 = P_k - \rho \\epsilon + \frac{d}{dy} \\left[ (\\mu + \\mu_t / \\sigma_k) \frac{dk}{dy} \right]\n    \\]\n\n    The turbulent dissipation equation:\n\n    \\[\n    0 = \frac{1}{T} \\left( C_{\\epsilon 1} P_k - C_{\\epsilon 2} \rho \\epsilon \right) + \frac{d}{dy} \\left[ (\\mu + \\mu_t / \\sigma_{\\epsilon}) \frac{d \\epsilon}{dy} \right]\n    \\]\n\n    The wall-normal fluctuation component equation:\n\n    \\[\n    0 = \rho k f - 6 \rho v^2 \frac{\\epsilon}{k} + \frac{d}{dy} \\left[ (\\mu + \\mu_t / \\sigma_k) \frac{d v^2}{dy} \right]\n    \\]\n\n    The elliptic relaxation equation:\n\n    \\[\n    L^2 \frac{d^2 f}{dy^2} - f = \frac{1}{T} \\left[ C_1 - 6 \frac{v^2}{k} - \frac{2}{3} (C_1 - 1) \right] - \frac{C_2 P_k}{\rho k}\n    \\]\n\n    The eddy viscosity is given by:\n\n    \\[\n    \\mu_t = C_{\\mu} \rho v^2 T_t\n    \\]\n\n\n    \n    ### **Tasks**\n    1. Implement the finite difference discretization for the governing equation.\n    2. Use an eddy viscosity model to define \\( \\mu_t \\).\n    3. Solve for the velocity profile \\( u(y) \\).\n    4. Visualize the velocity profile.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed velocity profile in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    "
  }
}
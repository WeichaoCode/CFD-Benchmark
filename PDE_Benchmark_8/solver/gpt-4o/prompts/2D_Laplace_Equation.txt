```python
import numpy as np
import scipy.sparse
import scipy.sparse.linalg

# Domain parameters
Lx, Ly = 2.0, 1.0
Nx, Ny = 50, 25
dx, dy = Lx / (Nx - 1), Ly / (Ny - 1)

# Create grid
x = np.linspace(0, Lx, Nx)
y = np.linspace(0, Ly, Ny)

# Initialize potential field
p = np.zeros((Ny, Nx))

# Construct the coefficient matrix A and the right-hand side vector b
N = Nx * Ny
A = scipy.sparse.lil_matrix((N, N))
b = np.zeros(N)

# Helper function to convert 2D indices to 1D index
def index(i, j):
    return i * Nx + j

# Fill the matrix A and vector b
for i in range(Ny):
    for j in range(Nx):
        idx = index(i, j)
        
        if j == 0:  # Left boundary (Dirichlet)
            A[idx, idx] = 1
            b[idx] = 0
        elif j == Nx - 1:  # Right boundary (Dirichlet)
            A[idx, idx] = 1
            b[idx] = y[i]
        elif i == 0:  # Bottom boundary (Neumann)
            A[idx, idx] = 1
            A[idx, index(i + 1, j)] = -1
            b[idx] = 0
        elif i == Ny - 1:  # Top boundary (Neumann)
            A[idx, idx] = 1
            A[idx, index(i - 1, j)] = -1
            b[idx] = 0
        else:  # Interior points
            A[idx, idx] = -2 / dx**2 - 2 / dy**2
            A[idx, index(i, j - 1)] = 1 / dx**2
            A[idx, index(i, j + 1)] = 1 / dx**2
            A[idx, index(i - 1, j)] = 1 / dy**2
            A[idx, index(i + 1, j)] = 1 / dy**2

# Convert A to CSR format for efficient solving
A = A.tocsr()

# Solve the linear system
p_flat = scipy.sparse.linalg.spsolve(A, b)

# Reshape the solution to 2D
p = p_flat.reshape((Ny, Nx))

# Save the solution
np.save('p.npy', p)
```
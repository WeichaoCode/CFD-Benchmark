Below is the Python code to solve the given 2D convection problem using the finite difference method. The code initializes the solution, applies the numerical scheme, enforces boundary conditions, and saves the final solution to a `.npy` file.

```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
nx, ny = 81, 81
nt = 100
c = 1.0
sigma = 0.2
dx = 2.0 / (nx - 1)
dy = 2.0 / (ny - 1)
dt = sigma * min(dx, dy) / c

# Initialize the solution array
u = np.ones((ny, nx))

# Initial condition: hat function
u[int(0.5 / dy):int(1 / dy + 1), int(0.5 / dx):int(1 / dx + 1)] = 2

# Time-stepping loop
for n in range(nt):
    un = u.copy()
    # Update using the finite difference scheme
    u[1:, 1:] = (un[1:, 1:] - 
                 c * dt / dx * (un[1:, 1:] - un[1:, :-1]) - 
                 c * dt / dy * (un[1:, 1:] - un[:-1, 1:]))
    
    # Apply Dirichlet boundary conditions
    u[:, 0] = 1
    u[:, -1] = 1
    u[0, :] = 1
    u[-1, :] = 1

# Save the final solution to a .npy file
np.save('final_solution.npy', u)

# Visualize the final solution
plt.figure(figsize=(8, 6))
plt.contourf(np.linspace(0, 2, nx), np.linspace(0, 2, ny), u, cmap='viridis')
plt.colorbar()
plt.title('Final Solution at t = {:.2f}'.format(nt * dt))
plt.xlabel('x')
plt.ylabel('y')
plt.show()
```

### Explanation:
1. **Initialization**: The solution array `u` is initialized with ones, and a hat-shaped initial condition is applied in the specified region.
2. **Time-stepping**: The solution is updated using the finite difference method for each time step. The first-order upwind scheme is used for spatial derivatives.
3. **Boundary Conditions**: Dirichlet boundary conditions are enforced after each time step.
4. **Saving the Solution**: The final solution is saved to a `.npy` file using NumPy.
5. **Visualization**: A contour plot of the final solution is generated for visualization purposes.

This code will solve the problem and save the final solution as a 2D NumPy array in `final_solution.npy`.
```python
import numpy as np

# Parameters
H = 2.0
n = 100
stretching_factor = 1.5
y_uniform = np.linspace(0, 1, n)
y = H * (np.sinh(stretching_factor * y_uniform) / np.sinh(stretching_factor))
dy = np.gradient(y)

# Physical constants
rho = 1.0
beta_star = 0.09
beta = 0.09
mu = 1.0
sigma_k = 1.0
sigma_omega = 1.0
C_D = 1.0
F1 = 1.0
F2 = 1.0
a1 = 1.0

# Velocity profile (linear)
U = 1.0
du_dy = U / H
S = np.abs(du_dy) * np.ones(n)

# Initial conditions
k = np.ones(n) * 1e-6
omega = np.ones(n) * 1e-6
mu_t = np.zeros(n)

# Iteration parameters
max_iter = 10000
tolerance = 1e-6

for it in range(max_iter):
    k_old = k.copy()
    omega_old = omega.copy()
    
    # Compute mu_t with safeguarding against division by zero
    omega_safe = np.maximum(omega, 1e-8)
    mu_t = rho * k * np.minimum(1.0 / omega_safe, a1 / (S * F2))
    
    # Compute Pk
    Pk = mu_t * S**2
    
    # Assemble tridiagonal matrix for k
    a_k = (mu + mu_t / sigma_k) / dy**2
    b_k = -2 * (mu + mu_t / sigma_k) / dy**2
    c_k = (mu + mu_t / sigma_k) / dy**2
    d_k = beta_star * rho * k * omega - Pk
    
    # Boundary conditions for k (Dirichlet with small non-zero values)
    A_k = np.zeros((n, n))
    rhs_k = np.zeros(n)
    A_k[0,0] = 1
    rhs_k[0] = 1e-6
    A_k[-1,-1] = 1
    rhs_k[-1] = 1e-6
    for i in range(1, n-1):
        A_k[i, i-1] = a_k[i]
        A_k[i, i] = b_k[i]
        A_k[i, i+1] = c_k[i]
        rhs_k[i] = d_k[i]
    
    k = np.linalg.solve(A_k, rhs_k)
    
    # Assemble tridiagonal matrix for omega
    a_w = (mu + mu_t * omega) / dy**2
    b_w = -2 * (mu + mu_t * omega) / dy**2
    c_w = (mu + mu_t * omega) / dy**2
    d_w = rho * S**2 - beta * omega**2 - (1 - F1) * C_D * k * omega
    
    # Boundary conditions for omega (Dirichlet with small non-zero values)
    A_w = np.zeros((n, n))
    rhs_w = np.zeros(n)
    A_w[0,0] = 1
    rhs_w[0] = 1e-6
    A_w[-1,-1] = 1
    rhs_w[-1] = 1e-6
    for i in range(1, n-1):
        A_w[i, i-1] = a_w[i]
        A_w[i, i] = b_w[i]
        A_w[i, i+1] = c_w[i]
        rhs_w[i] = d_w[i]
    
    omega = np.linalg.solve(A_w, rhs_w)
    
    # Check convergence
    if np.max(np.abs(k - k_old)) < tolerance and np.max(np.abs(omega - omega_old)) < tolerance:
        break

# Final mu_t
mu_t = rho * k * np.minimum(1.0 / omega, a1 / (S * F2))

# Save values
save_values = ['k', 'omega', 'mu_t']
np.save('k.npy', k)
np.save('omega.npy', omega)
np.save('mu_t.npy', mu_t)
```
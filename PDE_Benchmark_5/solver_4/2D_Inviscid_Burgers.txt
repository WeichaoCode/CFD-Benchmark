Below is the roadmap for developing the Python program:

Firstly, you may need to import necessary libraries.

```python
import numpy as np  
import matplotlib.pyplot as plt
```

Secondly, define parameters as mentioned above.

```python
Lx, Ly = 1., 1. # domain length in the x and y direction  
T = 1.0 # final time  
nx, ny , nt = 101, 101, 100 # number of points in space (x & y) and time  
dx, dy = Lx / (nx - 1), Ly / (ny - 1) # spatial discretization size  
dt = T / (nt - 1) # time discretization size
```

Ensure CFL stability :

```python
CFL = dt / max(dx, dy) # CFL condition
```

Initialize your field variables.

```python
u = np.zeros((ny, nx))  # x component of velocity
v = np.zeros((ny, nx))  # y component of velocity
```

Set up initial velocity field.

```python
# You can define your condition here, a simple one could be:
u[int(.5 / dy):int(1 / dy + 1), int(.5 / dx):int(1 / dx + 1)] = 2  
v[int(.5 / dy):int(1 / dy + 1), int(.5 / dx):int(1 / dx + 1)] = 2
```

Time-stepping loop that updates the velocity field using our discretized Navier-Stokes equations. 

```python
for n in range(nt + 1):    # Time loop
    un = u.copy()
    vn = v.copy()
    for i in range(1, len(un)-1):  # x loop, start & end at 1 to avoid out of boundary problem
        for j in range(1, len(vn)-1):  # y loop
            u[j, i] = un[j, i] - un[j, i] * dt / dx * (un[j, i] - un[j, i - 1]) - vn[j, i] * dt / dy * (un[j, i] - un[j - 1, i])
            v[j, i] = vn[j, i] - un[j, i] * dt / dx * (vn[j, i] - vn[j, i - 1]) - vn[j, i] * dt / dy * (vn[j, i] - vn[j - 1, i])
```

Generating quiver plots to visualize the velocity fields.

```python
plt.quiver(u[::3, ::3], v[::3, ::3])  
plt.show()
```

The code will solve the 2D inviscid Burgers' equation using the Finite Difference Method (FDM) and visualize the resulting velocity field with quiver plots. The velocity field will show the evolution of the field over time. Keep in mind that the up-wind scheme doesn't have any physical diffusion, and the model will collapse for long times because of the nature of the Burger's equation.

Please note, this code is only a rudimentary 2D implementation. There are advanced libraries and methods for more detailed and accurate simulations. Consider using packages like FEniCS, FiPy, or PyFR for professional CFD simulations.
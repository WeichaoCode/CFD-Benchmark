#!/usr/bin/env python3
import numpy as np

# Parameters
nx = 128         # number of grid points in x
nz = 256         # number of grid points in z
Lx = 1.0         # domain length in x
z_min = -1.0
z_max =  1.0     # domain in z is [-1,1]
Lz = z_max - z_min

dx = Lx / nx
dz = Lz / nz

tfinal = 20.0
dt = 0.005      # reduced time step for stability
nsteps = int(tfinal / dt)

# Physical parameters
nu = 1.0 / 50000.0      # kinematic viscosity
D  = nu                # tracer diffusivity

# Create grid
x = np.linspace(0, Lx, nx, endpoint=False)
z = np.linspace(z_min, z_max, nz, endpoint=False)
X, Z = np.meshgrid(x, z)

# Initial conditions
u0 = 0.5 * (1.0 + np.tanh((Z - 0.5)/0.1) - np.tanh((Z + 0.5)/0.1))
w0 = 0.01 * np.sin(2*np.pi*X) * ( np.exp(-((Z-0.5)**2)/0.01) + np.exp(-((Z+0.5)**2)/0.01) )
s0 = np.copy(u0)
p0 = np.zeros_like(u0)

# Upwind advection using first-order upwind scheme
def advect(field, u, w):
    # Upwind derivative in x-direction
    field_x_plus  = np.roll(field, -1, axis=1)
    field_x_minus = np.roll(field,  1, axis=1)
    dfdx = np.where(u>=0, (field - field_x_minus)/dx, (field_x_plus - field)/dx)
    # Upwind derivative in z-direction
    field_z_plus  = np.roll(field, -1, axis=0)
    field_z_minus = np.roll(field,  1, axis=0)
    dfdz = np.where(w>=0, (field - field_z_minus)/dz, (field_z_plus - field)/dz)
    return u * dfdx + w * dfdz

def laplacian(field):
    return ((np.roll(field, -1, axis=1) + np.roll(field, 1, axis=1) - 2.0*field) / dx**2 +
            (np.roll(field, -1, axis=0) + np.roll(field, 1, axis=0) - 2.0*field) / dz**2)

# Central differences for computing divergence and pressure gradients
def ddx(field):
    return (np.roll(field, -1, axis=1) - np.roll(field, 1, axis=1)) / (2*dx)

def ddz(field):
    return (np.roll(field, -1, axis=0) - np.roll(field, 1, axis=0)) / (2*dz)

def pressure_poisson(p, div, dt, iter_max=50):
    dx2 = dx*dx
    dz2 = dz*dz
    coef = 0.5 / (1.0/dx2 + 1.0/dz2)
    for _ in range(iter_max):
        p = coef * ((np.roll(p, -1, axis=1) + np.roll(p, 1, axis=1)) / dx2 +
                    (np.roll(p, -1, axis=0) + np.roll(p, 1, axis=0)) / dz2 - div/dt)
    return p

# Initialize fields
u = np.copy(u0)
w = np.copy(w0)
s = np.copy(s0)
p = np.copy(p0)

# Time stepping loop
for step in range(nsteps):
    # Compute advection using upwind scheme
    adv_u = advect(u, u, w)
    adv_w = advect(w, u, w)
    
    # Diffusion terms
    diff_u = nu * laplacian(u)
    diff_w = nu * laplacian(w)
    
    # Intermediate velocities (without pressure)
    u_star = u + dt * (-adv_u + diff_u)
    w_star = w + dt * (-adv_w + diff_w)
    
    # Enforce incompressibility using projection method
    div_u_star = ddx(u_star) + ddz(w_star)
    p = pressure_poisson(p, div_u_star, dt, iter_max=50)
    u = u_star - dt * ddx(p)
    w = w_star - dt * ddz(p)
    
    # Update tracer field s using upwind advection and diffusion
    adv_s = advect(s, u, w)
    diff_s = D * laplacian(s)
    s = s + dt * (-adv_s + diff_s)

# Save final fields as .npy files
np.save('u.npy', u)
np.save('w.npy', w)
np.save('s.npy', s)
np.save('p.npy', p)
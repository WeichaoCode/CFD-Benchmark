#!/usr/bin/env python3
import numpy as np

# Parameters
nx = 128            # number of grid points in x
ny = 128            # number of grid points in y
Lx = 1.0
Ly = 1.0
dx = Lx / nx
dy = Ly / (ny - 1)

nu = 0.001          # kinematic viscosity

# Time stepping parameters
dt = 0.0005
t_final = 1.0
nt = int(t_final/dt)

# Create grid
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)
X, Y = np.meshgrid(x, y)

# Initialize streamfunction psi and vorticity omega
psi = np.zeros((ny, nx))
omega = np.zeros((ny, nx))

# Initialize a pair of vortex layers in the center region
# We define two horizontal layers around the center in y.
# First vortex layer (positive vorticity) in lower half of the center region.
mask1 = (Y >= 0.45*Ly) & (Y <= 0.5*Ly)
# Second vortex layer (negative vorticity) in upper half of the center region.
mask2 = (Y >= 0.5*Ly) & (Y <= 0.55*Ly)
omega[mask1] = 5.0
omega[mask2] = -5.0

def solve_poisson(omega, psi, dx, dy, max_iter=500, tol=1e-6):
    # Solve Laplace psi = -omega with Dirichlet in y (psi=0 at y=0 and y=Ly)
    # and periodic in x.
    psi_new = psi.copy()
    for it in range(max_iter):
        psi_old = psi_new.copy()
        # Loop over interior points in y (boundaries in y remain at 0)
        for i in range(1, ny - 1):
            for j in range(nx):
                jp = (j + 1) % nx
                jm = (j - 1) % nx
                psi_new[i, j] = 0.5 * (
                    (psi_new[i, jp] + psi_new[i, jm]) * dy**2 +
                    (psi_new[i+1, j] + psi_new[i-1, j]) * dx**2 +
                    (-omega[i, j]) * dx**2 * dy**2
                ) / (dx**2 + dy**2)
        # Check residual (using L2 norm)
        if np.linalg.norm(psi_new - psi_old) < tol:
            break
    # Enforce Dirichlet BC in y: psi=0 at top and bottom
    psi_new[0, :] = 0.0
    psi_new[-1, :] = 0.0
    return psi_new

def compute_velocities(psi, dx, dy):
    # Compute velocity components: u = dpsi/dy, v = -dpsi/dx
    u = np.zeros_like(psi)
    v = np.zeros_like(psi)
    # Interior: central differences
    for i in range(1, ny-1):
        u[i, :] = (psi[i+1, :] - psi[i-1, :]) / (2*dy)
    # For first and last row, use one-sided differences (though psi=0 at boundaries)
    u[0, :] = (psi[1, :] - psi[0, :]) / dy
    u[-1, :] = (psi[-1, :] - psi[-2, :]) / dy

    # v component: periodic in x
    v[:, :] = -(np.roll(psi, -1, axis=1) - np.roll(psi, 1, axis=1)) / (2*dx)
    return u, v

def laplacian(field, dx, dy):
    lap = np.zeros_like(field)
    # Periodic in x, non-periodic in y.
    for i in range(1, ny-1):
        for j in range(nx):
            jp = (j+1) % nx
            jm = (j-1) % nx
            lap[i, j] = ((field[i, jp] - 2*field[i, j] + field[i, jm]) / dx**2 +
                         (field[i+1, j] - 2*field[i, j] + field[i-1, j]) / dy**2)
    # For boundaries in y, use one-sided differences approximation
    # Bottom boundary i=0
    i = 0
    for j in range(nx):
        jp = (j+1) % nx
        jm = (j-1) % nx
        lap[i, j] = ((field[i, jp] - 2*field[i, j] + field[i, jm]) / dx**2 +
                     (field[i+1, j] - field[i, j]) / dy**2)
    # Top boundary i=ny-1
    i = ny-1
    for j in range(nx):
        jp = (j+1) % nx
        jm = (j-1) % nx
        lap[i, j] = ((field[i, jp] - 2*field[i, j] + field[i, jm]) / dx**2 +
                     (- field[i, j] + field[i-1, j]) / dy**2)
    return lap

# Time stepping loop for vorticity transport equation
for n in range(nt):
    # Solve Poisson to update psi from current omega (steady relation)
    psi = solve_poisson(omega, psi, dx, dy)
    
    # Compute velocity field from psi
    u, v = compute_velocities(psi, dx, dy)
    
    # Compute advection terms using central differences (periodic in x)
    domega_dx = np.zeros_like(omega)
    domega_dy = np.zeros_like(omega)
    # For interior y points
    for i in range(1, ny-1):
        domega_dx[i, :] = (np.roll(omega[i, :], -1) - np.roll(omega[i, :], 1)) / (2*dx)
    # For boundaries in y use one-sided differences
    i = 0
    domega_dx[i, :] = (np.roll(omega[i, :], -1) - np.roll(omega[i, :], 1)) / (2*dx)
    i = ny-1
    domega_dx[i, :] = (np.roll(omega[i, :], -1) - np.roll(omega[i, :], 1)) / (2*dx)
    
    for j in range(nx):
        # For interior points in y
        domega_dy[1:-1, j] = (omega[2:, j] - omega[0:-2, j]) / (2*dy)
        # For boundaries in y use one-sided differences
    domega_dy[0, :] = (omega[1, :] - omega[0, :]) / dy
    domega_dy[-1, :] = (omega[-1, :] - omega[-2, :]) / dy

    # Compute Laplacian of omega
    lap_omega = laplacian(omega, dx, dy)

    # Update omega using explicit Euler time stepping
    # Compute convective term
    conv = u * domega_dx + v * domega_dy
    omega_new = omega + dt * (-conv + nu * lap_omega)

    # Enforce periodic boundary in x (already handled by roll but copy updated values)
    # Enforce approximated BC for omega in y by copying from near-boundary interior values
    omega_new[0, :] = omega_new[1, :]
    omega_new[-1, :] = omega_new[-2, :]

    omega = omega_new.copy()

# Save final solution fields as .npy files
np.save("psi.npy", psi)
np.save("omega.npy", omega)
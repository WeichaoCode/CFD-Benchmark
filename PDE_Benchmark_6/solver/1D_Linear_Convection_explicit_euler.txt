Here is a Python code that implements the solution:

```python
import numpy as np
import matplotlib.pyplot as plt

# Define parameters
Nx = 101
c = 1
epsilons = [0, 5e-4]
x = np.linspace(-5, 5, Nx)
dx = x[1] - x[0]
dt = 0.5 * dx / c  # CFL condition
T = 1.0
Nt = int(T / dt)

# Initialize variables
u = np.zeros((2, Nx, Nt+1))
u[:, :, 0] = np.exp(-x**2)

# Time integration using Explicit Euler Method
for epsilon, u_e in zip(epsilons, u):
    for n in range(Nt):
        u_x = (np.roll(u_e[:, n], -1) - np.roll(u_e[:, n], 1)) / (2*dx)
        u_xx = (np.roll(u_e[:, n], -1) - 2*u_e[:, n] + np.roll(u_e[:, n], 1)) / dx**2
        u_e[:, n+1] = u_e[:, n] - dt * (c * u_x - epsilon * u_xx)

# Save the computed solution
np.save('wave_solution.npy', u)

# Visualization
plt.figure(figsize=(10, 5))
for i, epsilon in enumerate(epsilons):
    plt.subplot(1, 2, i+1)
    for n in range(0, Nt+1, Nt//5):
        plt.plot(x, u[i, :, n], label=f't = {n*dt:.2f}')
    plt.title(f'Wave profile (epsilon = {epsilon})')
    plt.xlabel('x')
    plt.ylabel('u')
    plt.legend()
plt.tight_layout()
plt.show()
```

This code first defines the parameters and initializes the wave profile. It then performs time integration using the Explicit Euler Method, where the spatial derivatives are computed using the central difference scheme. The computed solution is saved in a `.npy` file. Finally, the wave profile at different time steps is plotted for both the damped and undamped cases.
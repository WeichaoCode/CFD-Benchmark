```python
import numpy as np
from scipy.sparse import diags, csr_matrix
from scipy.sparse.linalg import spsolve

# Domain parameters
Lx, Ly = 2.0, 1.0
nx, ny = 100, 50  # Grid resolution
dx, dy = Lx / (nx - 1), Ly / (ny - 1)

# Create coordinate grids
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)
X, Y = np.meshgrid(x, y)

# Initialize source term
b = np.zeros((ny, nx))
b[int(0.25*ny), int(0.25*nx)] = 100
b[int(0.75*ny), int(0.75*nx)] = -100

# Construct matrix for Poisson equation using finite difference method
def create_poisson_matrix(nx, ny, dx, dy):
    # Create diagonal matrices for x and y directions
    main_diag = -2 * (1/dx**2 + 1/dy**2) * np.ones(nx*ny)
    x_diag = np.ones(nx*ny-1) * (1/dx**2)
    y_diag = np.ones(nx*ny-nx) * (1/dy**2)
    
    # Create sparse matrix
    diagonals = [main_diag, x_diag, x_diag, y_diag, y_diag]
    offsets = [0, -1, 1, -nx, nx]
    A = diags(diagonals, offsets, shape=(nx*ny, nx*ny)).tocsr()
    
    return A

# Apply boundary conditions
def apply_boundary_conditions(A, b, nx, ny, dx, dy):
    # Zero Dirichlet conditions on all boundaries
    b_flat = b.flatten()
    
    # Left and right boundaries (x = 0, x = Lx)
    b_flat[0:ny] = 0
    b_flat[nx*ny-ny:nx*ny] = 0
    
    # Bottom and top boundaries (y = 0, y = Ly)
    b_flat[::nx] = 0
    b_flat[nx-1::nx] = 0
    
    return b_flat

# Create matrix and modify for boundary conditions
A = create_poisson_matrix(nx, ny, dx, dy)
b_flat = apply_boundary_conditions(A, b, nx, ny, dx, dy)

# Solve Poisson equation
p_flat = spsolve(A, b_flat)

# Reshape solution to 2D
p = p_flat.reshape((ny, nx))

# Save solution
np.save('p.npy', p)
```
#!/usr/bin/env python3
import numpy as np
from scipy.linalg import eig

# Parameters
N = 100                   # number of radial grid points
Re = 1e4                  # Reynolds number
k = 1.0                   # axial wavenumber
dr = 1.0/(N-1)
r = np.linspace(0, 1, N)
w0 = 1.0 - r**2           # laminar profile
dw0_dr = -2.0 * r         # derivative of w0

# Create finite-difference differentiation matrices (1st and 2nd derivative) on r
D = np.zeros((N, N), dtype=np.float64)
D2 = np.zeros((N, N), dtype=np.float64)

# First derivative matrix D: using second-order accurate formulas
# Interior: central differences
for j in range(1, N-1):
    D[j, j-1] = -1.0/(2*dr)
    D[j, j+1] =  1.0/(2*dr)
# Boundary at r=0: one-sided (forward) difference (second order)
D[0,0] = -3.0/(2*dr)
D[0,1] =  4.0/(2*dr)
D[0,2] = -1.0/(2*dr)
# Boundary at r=1: one-sided (backward) difference (second order)
D[-1,-1] =  3.0/(2*dr)
D[-1,-2] = -4.0/(2*dr)
D[-1,-3] =  1.0/(2*dr)

# Second derivative matrix D2: using central differences for interior
for j in range(1, N-1):
    D2[j, j-1] =  1.0/(dr**2)
    D2[j, j]   = -2.0/(dr**2)
    D2[j, j+1] =  1.0/(dr**2)
# Boundary at r=0: use one-sided difference
D2[0,0] = 2.0/(dr**2)
D2[0,1] = -5.0/(dr**2)
D2[0,2] = 4.0/(dr**2)
D2[0,3] = -1.0/(dr**2)
# Boundary at r=1: use one-sided difference (backward)
D2[-1,-1] = 2.0/(dr**2)
D2[-1,-2] = -5.0/(dr**2)
D2[-1,-3] = 4.0/(dr**2)
D2[-1,-4] = -1.0/(dr**2)

# Total unknowns: u, w, p at each radial grid point.
# Order: x = [u_0, ..., u_{N-1}, w_0, ..., w_{N-1}, p_0, ..., p_{N-1]].
Ntot = 3 * N

# Build global matrices A and B for the generalized eigenvalue problem A x = s B x.
# We will impose BCs in 6 rows and use interior collocation for the 3*(N-2) remaining rows.
A = np.zeros((Ntot, Ntot), dtype=np.complex128)
B = np.zeros((Ntot, Ntot), dtype=np.complex128)

# ----------------------------------------------------------------------
# Impose boundary conditions (BCs)
# For u, w, p at r=0 and r=1.
# Global unknown indices:
# u: 0 ... N-1, w: N ... 2N-1, p: 2N ... 3N-1.
# BC for u:
#   at r=0: u'(0)=0  -> (-3*u[0] + 4*u[1] - u[2])/(2*dr)=0.
#   at r=1: u(1)=0.
row = 0
# u at r=0: u'(0)=0
A[row, 0] = -3.0/(2*dr)
A[row, 1] =  4.0/(2*dr)
A[row, 2] = -1.0/(2*dr)
row += 1
# u at r=1: u(1)=0
A[row, N-1] = 1.0
row += 1

# BC for w:
#   at r=0: w'(0)=0  -> (-3*w[0] + 4*w[1] - w[2])/(2*dr)=0.
#   at r=1: w(1)=0.
A[row, N+0] = -3.0/(2*dr)
A[row, N+1] =  4.0/(2*dr)
A[row, N+2] = -1.0/(2*dr)
row += 1
A[row, 2*N-1] = 1.0
row += 1

# BC for p (gauge conditions):
#   at r=0: p'(0)=0  -> (-3*p[0] + 4*p[1] - p[2])/(2*dr)=0.
#   at r=1: p(1)=0.
A[row, 2*N+0] = -3.0/(2*dr)
A[row, 2*N+1] =  4.0/(2*dr)
A[row, 2*N+2] = -1.0/(2*dr)
row += 1
A[row, 3*N-1] = 1.0
row += 1

# For these BC rows, the corresponding rows in B remain zero.
# ----------------------------------------------------------------------
# Now, set up interior collocation equations for r_i, i = 1,...,N-2.
# For each interior point (i index from 1 to N-2), we impose:
# 1) Continuity: u'(r) + i * w = 0, i.e., D u + 1j * w = 0.
# 2) Radial momentum:
#      s*u + i*w0*u + d(p)/dr - (1/Re)[D2 u + (1/r)*D u - (1/r^2 + k^2)*u] = 0.
#    (This gives s*u as eigenvalue term and the remainder in A.)
# 3) Axial momentum:
#      s*w + i*w0*w - (1/Re)[D2 w + (1/r)*D w - k^2*w] - 2*r*u + 1j*p = 0.
#    (s*w in eigenvalue term.)
for i in range(1, N-1):
    # Global row indices for the 3 equations corresponding to grid index i.
    idx_base = row  # starting row index for this grid point, then idx_base, idx_base+1, idx_base+2.
    # ------------------------------------------------------------------
    # 1) Continuity equation at r[i]:
    #    u'(r_i) + 1j * w(r_i) = 0.
    # u-part: use the i-th row of D.
    A[idx_base, 0:N] = D[i, :].astype(np.complex128)
    # w-part: add 1j at the diagonal for the corresponding w index.
    A[idx_base, N+i] = 1j
    # No p contribution.
    # B row for continuity eq remains zero.
    idx_base += 1

    # 2) Radial momentum equation at r[i]:
    #    s*u + i*w0*u + d(p)/dr - (1/Re)*[D2 u + (1/r_i)*D u - (1/r[i]**2 + k^2)*u] = 0.
    # The s*u term is moved to the B matrix.
    # u-part (A): [i*w0[i] - (1/Re)*(D2 + (1/r_i)*D - diag(1/r[i]**2) - k^2*I)] at row i.
    # We'll add the i-th row of D2 and D with appropriate factors.
    A[idx_base, 0:N] = (1j*w0[i])*np.eye(1, N, i)[0]  # We'll add diagonal later.
    # Instead of trying to extract one-diagonal row from identity, we fill using the row of operators.
    # For the u-part, set:
    op_u = D2[i, :] + (1.0/r[i])*D[i, :] - (1.0/(r[i]**2) + k**2)*np.eye(1, N, i)[0]
    A[idx_base, 0:N] -= (1.0/Re)*op_u
    # p-part: d/dr p -> use row i of D for p block.
    A[idx_base, 2*N:3*N] = D[i, :].astype(np.complex128)
    # Coupling with w is zero.
    # In the B matrix, the s*u term contributes: identity on u.
    B[idx_base, 0:N] = np.eye(1, N, i)[0]
    idx_base += 1

    # 3) Axial momentum equation at r[i]:
    #    s*w + i*w0*w - (1/Re)*[D2 w + (1/r[i])*D w - k^2*w] - 2*r[i]*u + 1j*p = 0.
    # w-part (A): 
    op_w = D2[i, :] + (1.0/r[i])*D[i, :] - (k**2)*np.eye(1, N, i)[0]
    A[idx_base, N:2*N] = (1j*w0[i])*np.eye(1, N, i)[0] - (1.0/Re)*op_w
    # u-part: -2*r[i] * u.
    A[idx_base, 0:N] += -2.0*r[i]*np.eye(1, N, i)[0]
    # p-part: +1j * p.
    A[idx_base, 2*N:3*N] += 1j * np.eye(1, N, i)[0]
    # In the B matrix, the s*w term contributes identity in w.
    B[idx_base, N:2*N] = np.eye(1, N, i)[0]
    row += 3

# At this point, A and B are fully assembled.
# Solve the generalized eigenvalue problem A x = s B x.
eigvals, eigvecs = eig(A, B)

# Select the eigenmode with the maximum real part of the eigenvalue
growth_rates = eigvals.real
sel = np.argmax(growth_rates)
s_eig = eigvals[sel]
x = eigvecs[:, sel]

# Extract solution fields from x.
u_sol = x[0:N]
w_sol = x[N:2*N]
p_sol = x[2*N:3*N]

# Save solutions as .npy files (1D arrays)
np.save("u", u_sol)
np.save("w", w_sol)
np.save("p", p_sol)

print("Eigenvalue (s):", s_eig)
print("u, w, p solutions saved in 'u.npy', 'w.npy', 'p.npy'.")
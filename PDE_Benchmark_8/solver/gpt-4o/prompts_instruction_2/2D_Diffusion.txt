Below is the Python code to solve the given 2D diffusion equation using a finite difference method. The code initializes the field with the specified initial conditions, applies the Dirichlet boundary conditions, and iterates over the time steps to compute the solution. Finally, it saves the solution at the final time step to a `.npy` file.

```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
nx, ny = 31, 31
nt = 50
nu = 1.0
sigma = 0.25
dx = dy = 2.0 / (nx - 1)
dt = sigma * dx * dy / nu

# Initialize the field
u = np.ones((ny, nx))
u[int(0.5 / dy):int(1 / dy + 1), int(0.5 / dx):int(1 / dx + 1)] = 2

# Time-stepping loop
for n in range(nt):
    un = u.copy()
    u[1:-1, 1:-1] = (un[1:-1, 1:-1] +
                     nu * dt / dx**2 * (un[1:-1, 2:] - 2 * un[1:-1, 1:-1] + un[1:-1, :-2]) +
                     nu * dt / dy**2 * (un[2:, 1:-1] - 2 * un[1:-1, 1:-1] + un[:-2, 1:-1]))
    
    # Apply Dirichlet boundary conditions
    u[0, :] = 1
    u[-1, :] = 1
    u[:, 0] = 1
    u[:, -1] = 1

# Save the final solution to a .npy file
np.save('final_solution.npy', u)

# Optional: Visualize the final solution
plt.contourf(np.linspace(0, 2, nx), np.linspace(0, 2, ny), u, cmap='viridis')
plt.colorbar()
plt.title('2D Diffusion at Final Time Step')
plt.xlabel('x')
plt.ylabel('y')
plt.show()
```

This code will compute the solution to the diffusion equation over the specified domain and time steps, applying the given initial and boundary conditions. The final solution is saved to a file named `final_solution.npy`. The visualization part is optional and can be used to verify the results visually.
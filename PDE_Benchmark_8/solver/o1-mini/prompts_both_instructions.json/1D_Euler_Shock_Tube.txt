```python
import numpy as np

# Parameters
gamma = 1.4
N_x = 81
x_start = -1.0
x_end = 1.0
L = x_end - x_start
CFL = 1.0
t_final = 0.25

# Spatial grid
x = np.linspace(x_start, x_end, N_x)
dx = L / (N_x - 1)

# Initial conditions
rho = np.where(x < 0, 1.0, 0.125)
u = np.zeros(N_x)
p = np.where(x < 0, 1.0, 0.1)

# Conservative variables
E = p / ((gamma - 1) * rho) + 0.5 * u**2
U = np.vstack((rho, rho * u, rho * E)).T

def compute_flux(U):
    rho = U[:,0]
    u = U[:,1] / rho
    E = U[:,2] / rho
    p = (gamma -1) * rho * (E - 0.5 * u**2)
    F = np.vstack((rho * u, rho * u**2 + p, u * (rho * E + p))).T
    return F, p, u

t = 0.0
while t < t_final:
    F, p, u = compute_flux(U)
    # Compute time step
    a = np.sqrt(gamma * p / U[:,0])
    dt = CFL * dx / np.max(np.abs(u) + a)
    if t + dt > t_final:
        dt = t_final - t
    # Predictor step
    U_pred = np.copy(U)
    U_pred[0:-1] = U[0:-1] - dt/dx * (F[1:] - F[0:-1])
    # Apply reflective boundary conditions
    U_pred[0] = U_pred[1]
    U_pred[-1] = U_pred[-2]
    F_pred, p_pred, u_pred = compute_flux(U_pred)
    # Corrector step
    U_new = np.copy(U)
    U_new[1:-1] = 0.5 * (U[1:-1] + U_pred[1:-1] - dt/dx * (F_pred[1:-1] - F_pred[0:-2]))
    # Apply reflective boundary conditions
    U_new[0] = U_new[1]
    U_new[-1] = U_new[-2]
    U = U_new
    t += dt

# Final flux and primitive variables
F, p, u = compute_flux(U)
rho = U[:,0]

# Save variables
np.save('rho.npy', rho)
np.save('u.npy', u)
np.save('p.npy', p)
np.save('U.npy', U)
np.save('F.npy', F)
```
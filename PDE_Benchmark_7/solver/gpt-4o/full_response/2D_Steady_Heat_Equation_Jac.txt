```python
import numpy as np
import matplotlib.pyplot as plt

# Constants
Lx, Ly = 5.0, 4.0
dx, dy = 0.05, 0.05
nx, ny = int(Lx / dx) + 1, int(Ly / dy) + 1
beta = dx / dy

# Boundary conditions
T_left = 10.0
T_top = 0.0
T_right = 40.0
T_bottom = 20.0

# Initialize temperature grid
T = np.zeros((ny, nx))

# Apply boundary conditions
T[:, 0] = T_left     # Left boundary
T[0, :] = T_top      # Top boundary
T[:, -1] = T_right   # Right boundary
T[-1, :] = T_bottom  # Bottom boundary

# Iterative parameters
tolerance = 1e-4
max_iterations = 10000
iteration = 0
residual = tolerance + 1

# Jacobi method
while residual > tolerance and iteration < max_iterations:
    T_new = T.copy()

    # Update temperature for the internal grid points
    for j in range(1, ny - 1):
        for i in range(1, nx - 1):
            T_new[j, i] = (T[j, i+1] + T[j, i-1] + beta**2 * (T[j+1, i] + T[j-1, i])) / (2 * (1 + beta**2))

    # Calculate the residual
    residual = np.max(np.abs(T_new - T))
    T = T_new
    iteration += 1

    if iteration % 100 == 0:  # Print progress every 100 iterations
        print(f"Iteration: {iteration}, Residual: {residual}")

print(f"Converged after {iteration} iterations with a residual of {residual}")

# Save the temperature distribution
np.save('temperature_distribution.npy', T)

# Plotting the temperature field
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)
X, Y = np.meshgrid(x, y)

plt.figure(figsize=(8, 6))
contour = plt.contourf(X, Y, T, 50, cmap='hot')
plt.colorbar(contour)
plt.title('Steady State Temperature Distribution')
plt.xlabel('x')
plt.ylabel('y')
plt.show()
```

This code implements the solution of the 2D steady-state heat equation using the Jacobi iterative method. It discretizes the domain, applies the Dirichlet boundary conditions, iterates until the residual is below a specified tolerance, and then visualizes the temperature distribution using a contour plot. The results are saved to a `.npy` file for further analysis.
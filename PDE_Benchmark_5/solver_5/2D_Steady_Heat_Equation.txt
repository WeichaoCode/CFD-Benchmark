Sure, I can create a Python program that fits your specifications using `numpy` library. Let's use an iterative approach to solve the finite difference scheme until the solution no longer changes to a specified tolerance level.

```python
import numpy as np
import matplotlib.pyplot as plt

# Define constants
Lx, Ly = 5, 4
Nx, Ny = 50, 40
dx, dy = Lx / (Nx - 1), Ly / (Ny - 1)
T_top, T_bottom, T_left, T_right = 0, 20, 10, 40
tolerance = 1e-5

# Initialize grid
T = np.zeros((Ny, Nx), dtype=float)
T[0, :], T[-1, :], T[:, 0], T[:, -1] = T_top, T_bottom, T_left, T_right

# Iterative solver
def solve(T):
    error = 1
    while error > tolerance:
        T_new = T.copy()
        T_new[1:-1, 1:-1] = ((dy**2 * (T[1:-1, 2:] + T[1:-1, :-2]) +
                               dx**2 * (T[2:, 1:-1] + T[:-2, 1:-1])) /
                              (2 * (dx**2 + dy**2)))
        error = np.max(np.abs(T_new - T))
        T = T_new
    return T

# Solve
T_final = solve(T)

# Plot
plt.figure(figsize=(8, 5))
plt.title('Temperature distribution')
plt.xlabel('x')
plt.ylabel('y')
cont = plt.contourf(T_final, cmap=plt.cm.hot, levels=np.linspace(0, 40, 21))
plt.colorbar(cont)
plt.show()
```

This program first defines the physical parameters of the problem (domain size and resolution, boundary temperatures and the convergence tolerance level). It then initializes the temperature grid and defines the iterative solver function using central differences for the grid points that are not on the boundary. Finally, it calls the solver and plots the resulting temperature distribution as a contour plot.
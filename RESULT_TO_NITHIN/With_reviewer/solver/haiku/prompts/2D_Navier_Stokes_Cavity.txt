```python
import numpy as np

# Grid parameters
nx = 41
ny = 41
dx = 2.0/(nx-1)
dy = 2.0/(ny-1)
dt = 0.0001  # Reduced time step
nt = 1000    # Reduced number of time steps

# Physical parameters
rho = 1.0
nu = 0.1

# Initialize fields
u = np.zeros((ny,nx), dtype=np.float64)
v = np.zeros((ny,nx), dtype=np.float64)
p = np.zeros((ny,nx), dtype=np.float64)
b = np.zeros((ny,nx), dtype=np.float64)

# Set lid velocity
u[-1,:] = 1.0

def pressure_poisson(p, dx, dy, b):
    pn = np.empty_like(p)
    
    for q in range(20):
        pn = p.copy()
        p[1:-1,1:-1] = 0.25*(pn[1:-1,2:] + pn[1:-1,:-2] + 
                            pn[2:,1:-1] + pn[:-2,1:-1] - 
                            dx*dy*b[1:-1,1:-1])
        
        # Boundary conditions
        p[-1,:] = p[-2,:]
        p[0,:] = p[1,:]
        p[:,0] = p[:,1]
        p[:,-1] = p[:,-2]
        
    return p

# Time stepping
for n in range(nt):
    un = u.copy()
    vn = v.copy()
    
    # Compute velocity gradients
    dudx = np.zeros_like(u)
    dudy = np.zeros_like(u)
    dvdx = np.zeros_like(v)
    dvdy = np.zeros_like(v)
    
    # Central differences for velocity gradients
    dudx[1:-1,1:-1] = np.clip((un[1:-1,2:] - un[1:-1,:-2])/(2*dx), -100, 100)
    dudy[1:-1,1:-1] = np.clip((un[2:,1:-1] - un[:-2,1:-1])/(2*dy), -100, 100)
    dvdx[1:-1,1:-1] = np.clip((vn[1:-1,2:] - vn[1:-1,:-2])/(2*dx), -100, 100)
    dvdy[1:-1,1:-1] = np.clip((vn[2:,1:-1] - vn[:-2,1:-1])/(2*dy), -100, 100)
    
    # Source term for pressure equation
    b[1:-1,1:-1] = rho/dt * (
        np.clip(dudx[1:-1,1:-1], -10, 10) * np.clip(dudx[1:-1,1:-1], -10, 10) +
        2 * np.clip(dudy[1:-1,1:-1], -10, 10) * np.clip(dvdx[1:-1,1:-1], -10, 10) +
        np.clip(dvdy[1:-1,1:-1], -10, 10) * np.clip(dvdy[1:-1,1:-1], -10, 10)
    )
    
    # Solve pressure Poisson equation
    p = pressure_poisson(p, dx, dy, b)
    
    # u-momentum equation
    u[1:-1,1:-1] = un[1:-1,1:-1] - \
        np.clip(un[1:-1,1:-1], -10, 10)*dt/dx*(un[1:-1,2:] - un[1:-1,:-2])/2 - \
        np.clip(vn[1:-1,1:-1], -10, 10)*dt/dy*(un[2:,1:-1] - un[:-2,1:-1])/2 - \
        dt/(2*rho*dx)*(p[1:-1,2:] - p[1:-1,:-2]) + \
        nu*dt*(
            (un[1:-1,2:] - 2*un[1:-1,1:-1] + un[1:-1,:-2])/dx**2 +
            (un[2:,1:-1] - 2*un[1:-1,1:-1] + un[:-2,1:-1])/dy**2
        )
    
    # v-momentum equation
    v[1:-1,1:-1] = vn[1:-1,1:-1] - \
        np.clip(un[1:-1,1:-1], -10, 10)*dt/dx*(vn[1:-1,2:] - vn[1:-1,:-2])/2 - \
        np.clip(vn[1:-1,1:-1], -10, 10)*dt/dy*(vn[2:,1:-1] - vn[:-2,1:-1])/2 - \
        dt/(2*rho*dy)*(p[2:,1:-1] - p[:-2,1:-1]) + \
        nu*dt*(
            (vn[1:-1,2:] - 2*vn[1:-1,1:-1] + vn[1:-1,:-2])/dx**2 +
            (vn[2:,1:-1] - 2*vn[1:-1,1:-1] + vn[:-2,1:-1])/dy**2
        )
    
    # Boundary conditions
    u[0,:] = 0
    u[:,-1] = 0
    u[:,0] = 0
    u[-1,:] = 1
    v[0,:] = 0
    v[-1,:] = 0
    v[:,0] = 0
    v[:,-1] = 0

# Save final solutions
np.save('u.npy', u)
np.save('v.npy', v)
np.save('p.npy', p)
```
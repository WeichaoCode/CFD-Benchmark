{
    "prompts": {
        "2D_Steady_Heat_Equation": "\n Objective \n Write a Python program to solve the steady-state two-dimensional heat equation using the Finite Difference Method (FDM). \n Governing Equation \n The problem requires computing the numerical solution for the steady-state heat equation given by: \n ∂²T/∂x² + ∂²T/∂y² = 0 \n where T(x,y) represents the temperature distribution in the domain. \n Computational Domain \n The heat equation is solved on a rectangular domain with: \n x ∈ [0,5], y ∈ [0,4] \n Boundary Conditions \n The boundary conditions imposed on the domain are: \n Left boundary (AB, x=0): T = 10°C \n Top boundary (CD, y=4): T = 0°C \n Right boundary (EF, x=5): T = 40°C \n Bottom boundary (G, y=0): T = 20°C \n Numerical Method \n Discretization: \n Use central difference approximation for the second derivatives in both x and y directions. \n The resulting finite difference equation is: \n (T_{i+1,j} - 2T_{i,j} + T_{i-1,j}) / Δx² + (T_{i,j+1} - 2T_{i,j} + T_{i,j-1}) / Δy² = 0 \n Solution Approach: \n Implement an iterative method like Gauss-Seidel or Jacobi iteration to solve for T(x,y). \n Use a convergence criterion (e.g., stopping when the change in temperature values is below a small tolerance). \n Expected Output \n Compute and visualize the temperature distribution over the domain. \n Use contour plots or a heatmap to represent the steady-state temperature.",
        "2D_Unsteady_Heat_Equation": "\n Objective \n Develop a Python program to solve the unsteady two-dimensional heat equation using the Finite Difference Method (FDM). The goal is to compare the accuracy and efficiency of explicit and implicit solution methods. \n Governing Equation \n The numerical solution is required for the following PDE: \n ∂T/∂t - α (∂²T/∂x² + ∂²T/∂y²) = q(x, y, t) \n where: \n - T(x, y, t) is the temperature field. \n - α is the thermal diffusivity. \n - q(x, y, t) is a heat source term that varies in time and space. \n Computational Domain and Boundary Conditions \n - The equation is solved in a rectangular domain: \n x ∈ [-1, 1], y ∈ [-1, 1] \n - Boundary conditions: Fixed temperature of 0°C on all sides. \n Source Term \n A steady, non-uniform heat source is imposed: \n q(x, y) = Q_0 exp(- (x² + y²) / (2σ²)) \n where: \n - Q_0 = 200°C/s (Maximum heating at the center (0,0)). \n - σ = 0.1 (Controls radial decay of heat source). \n Numerical Method \n 1. Discretization Strategy \n - Use central difference for second-order spatial derivatives. \n - Use explicit and implicit time integration methods to compare accuracy and efficiency. \n - Implement stability conditions (CFL criteria) for explicit methods. \n 2. Solution Approach \n - Define the computational grid with uniform spacing. \n - Implement both explicit and implicit time-stepping schemes. \n - Iterate over time until the solution reaches steady-state or final time. \n 3. Expected Output \n - Compute and visualize temperature evolution over time. \n - Use contour plots or heatmaps to represent the temperature field at different time steps. \n - Compare the performance of explicit vs. implicit methods. \n Implementation Guidelines \n - Use NumPy & Matplotlib for computation and visualization. \n - Ensure numerical stability by choosing an appropriate time step. \n - Compare the solutions obtained using explicit and implicit methods. \n",
        "2D_Unsteady_Heat_Equation_1": "\n Objective \n Develop a Python program to solve the unsteady two-dimensional heat equation using the Finite Difference Method (FDM). The goal is to numerically compute the temperature distribution over time using a simple explicit time-stepping scheme. \n Governing Equation \n The numerical solution is required for the following PDE: \n ∂T/∂t - α (∂²T/∂x² + ∂²T/∂y²) = q(x, y, t) \n where: \n - T(x, y, t) is the temperature field. \n - α is the thermal diffusivity. \n - q(x, y, t) is a heat source term that varies in time and space. \n Computational Domain and Boundary Conditions \n - The equation is solved in a rectangular domain: \n x ∈ [-1, 1], y ∈ [-1, 1] \n - Boundary conditions: Fixed temperature of 0°C on all sides. \n Source Term \n A steady, non-uniform heat source is imposed: \n q(x, y) = Q_0 exp(- (x² + y²) / (2σ²)) \n where: \n - Q_0 = 200°C/s (Maximum heating at the center (0,0)). \n - σ = 0.1 (Controls radial decay of heat source). \n Numerical Method \n 1. Discretization Strategy \n - Use central difference for second-order spatial derivatives. \n - Use a **Simple Explicit Method** for time integration. \n - Implement stability conditions (CFL criteria) to ensure convergence. \n 2. Solution Approach \n - Define the computational grid with uniform spacing. \n - Implement an explicit time-stepping scheme to update temperature values. \n - Iterate over time until the solution reaches steady-state or final time. \n 3. Expected Output \n - Compute and visualize temperature evolution over time. \n - Use contour plots or heatmaps to represent the temperature field at different time steps. \n Implementation Guidelines \n - Use NumPy & Matplotlib for computation and visualization. \n - Ensure numerical stability by choosing an appropriate time step based on the CFL condition. \n - Write modular code for reusability and clarity. \n",
        "2D_Unsteady_Heat_Equation_2": "\n Objective \n Develop a Python program to solve the unsteady two-dimensional heat equation using the Finite Difference Method (FDM). The goal is to numerically compute the temperature distribution over time using **Dufort-Frankel Method** and **Alternating Direction Implicit (ADI) Method** for improved stability and efficiency. \n Governing Equation \n The numerical solution is required for the following PDE: \n ∂T/∂t - α (∂²T/∂x² + ∂²T/∂y²) = q(x, y, t) \n where: \n - T(x, y, t) is the temperature field. \n - α is the thermal diffusivity. \n - q(x, y, t) is a heat source term that varies in time and space. \n Computational Domain and Boundary Conditions \n - The equation is solved in a rectangular domain: \n x ∈ [-1, 1], y ∈ [-1, 1] \n - Boundary conditions: Fixed temperature of 0°C on all sides. \n Source Term \n A steady, non-uniform heat source is imposed: \n q(x, y) = Q_0 exp(- (x² + y²) / (2σ²)) \n where: \n - Q_0 = 200°C/s (Maximum heating at the center (0,0)). \n - σ = 0.1 (Controls radial decay of heat source). \n Numerical Methods \n 1. **Dufort-Frankel Method**: \n - An explicit method that enhances stability by using a weighted time-average approach. \n - Allows for larger time steps without violating stability constraints. \n - Suitable for high Fourier number problems. \n 2. **Alternating Direction Implicit (ADI) Method**: \n - A semi-implicit scheme that splits the problem into one-dimensional steps, solving each direction sequentially. \n - Provides higher stability and allows larger time steps compared to explicit methods. \n - Efficient for solving large grid problems. \n Solution Approach \n - Implement both methods and compare their performance. \n - Choose appropriate grid spacing and time step for numerical stability. \n - Visualize and analyze temperature evolution over time. \n Expected Output \n - Compute and visualize the temperature field at different time steps. \n - Compare results obtained using **Dufort-Frankel** and **ADI** methods. \n - Use contour plots or heatmaps to represent the temperature field. \n Implementation Guidelines \n - Use NumPy & Matplotlib for computation and visualization. \n - Implement functions for both numerical schemes and allow selection between them. \n - Ensure numerical stability and efficiency by optimizing grid resolution and time step. \n",
        "1D_Linear_Convection": "\n Objective \n Develop a Python program to solve the 1D Linear Convection Equation using the Finite Difference Method (FDM). \n Governing Equation \n Solve the equation: \n ∂u/∂t + c ∂u/∂x = 0 \n Computational Domain \n The equation is solved over x ∈ [0, L], t ∈ [0, T]. \n Numerical Method \n Use second-order central differences for spatial discretization and the explicit Euler method for time integration. \n Ensure numerical stability using the CFL condition. \n Implementation Steps \n 1. Define parameters (L, T, nx, nt, c). \n 2. Discretize space and time, ensuring CFL stability. \n 3. Set up the initial wave profile. \n 4. Iterate using the finite difference scheme. \n 5. Plot the wave evolution. \n Expected Output \n Generate a visualization showing the wave propagating over time.",
        "1D_Nonlinear_Convection": "\n Objective \n Develop a Python program to solve the 1D Nonlinear Convection Equation using the Finite Difference Method (FDM). \n Governing Equation \n Solve the equation: \n ∂u/∂t + u ∂u/∂x = 0 \n Computational Domain \n The equation is solved over x ∈ [0, L], t ∈ [0, T]. \n Numerical Method \n Use a first-order upwind scheme for spatial discretization and the explicit Euler method for time integration. \n Ensure numerical stability using the CFL condition. \n Implementation Steps \n 1. Define parameters (L, T, nx, nt). \n 2. Discretize space and time, ensuring CFL stability. \n 3. Set up the initial wave profile. \n 4. Iterate using the finite difference scheme. \n 5. Plot the wave evolution. \n Expected Output \n Generate a visualization showing wave steepening due to nonlinearity.",
        "2D_Inviscid_Burgers": "\n Objective \n Develop a Python program to solve the 2D Inviscid Burgers’ Equation using the Finite Difference Method (FDM). \n Governing Equation \n Solve the coupled nonlinear system: \n ∂u/∂t + u ∂u/∂x + v ∂u/∂y = 0 \n ∂v/∂t + u ∂v/∂x + v ∂v/∂y = 0 \n Computational Domain \n The equation is solved over x ∈ [0, Lx], y ∈ [0, Ly], t ∈ [0, T]. \n Numerical Method \n Use a first-order upwind scheme for spatial discretization and the explicit Euler method for time integration. \n Ensure numerical stability using the CFL condition. \n Implementation Steps \n 1. Define parameters (Lx, Ly, T, nx, ny, nt). \n 2. Discretize space and time, ensuring CFL stability. \n 3. Set up the initial velocity field. \n 4. Iterate using the finite difference scheme. \n 5. Visualize the velocity field using quiver plots. \n Expected Output \n Generate a quiver plot showing the evolution of the velocity field over time.",
        "1D_Euler_Shock_Tube": "\n Objective \n Develop a Python program to solve the 1D Euler equations for compressible flow in a shock tube using the MacCormack method. \n Governing Equation \n Solve the conservative form of the Euler equations: \n ∂U/∂t + ∂F/∂x = 0 \n where \n U = [ρ, ρu, ρE]^T \n F = [ρu, ρu² + p, ρu(E + p)]^T \n Computational Domain \n The equation is solved over x ∈ [0, L], t ∈ [0, T]. \n The initial shock tube conditions are: \n Left region: ρ = 1.0, u = 0.0, p = 1.0 \n Right region: ρ = 0.125, u = 0.0, p = 0.1 \n Numerical Method \n Use the MacCormack method with a predictor-corrector scheme for numerical discretization. \n Ensure numerical stability using the CFL condition. \n Implementation Steps \n 1. Define parameters (L, T, nx, nt, γ, CFL). \n 2. Discretize space and time, ensuring CFL stability. \n 3. Initialize primitive variables (ρ, u, p) and convert to conserved variables (ρ, ρu, ρE). \n 4. Iterate using the MacCormack method. \n 5. Convert back to primitive variables (ρ, u, p). \n 6. Visualize the density, velocity, and pressure profiles over time. \n Expected Output \n Generate line plots showing the evolution of density, velocity, and pressure profiles over time.",
        "2D_Navier_Stokes_Cavity": "\n Objective \n Develop a Python program to solve the 2D incompressible Navier-Stokes equations in a lid-driven cavity using the Finite Difference Method (FDM). \n Governing Equations \n Solve the coupled momentum and continuity equations for an incompressible fluid: \n ∂u/∂t + u ∂u/∂x + v ∂u/∂y = - (1/ρ) ∂p/∂x + ν (∂²u/∂x² + ∂²u/∂y²) \n ∂v/∂t + u ∂v/∂x + v ∂v/∂y = - (1/ρ) ∂p/∂y + ν (∂²v/∂x² + ∂²v/∂y²) \n ∂u/∂x + ∂v/∂y = 0 \n Computational Domain \n Solve the equations on a square domain x ∈ (0,1), y ∈ (0,1). \n Boundary Conditions \n - Lid-driven top boundary (y=1): u = 1, v = 0 \n - No-slip condition on other walls: u = v = 0 \n - Pressure boundary: ∂p/∂y = 0 at y=1, ∂p/∂x = 0 at x=0,1, p = 0 at y=0 \n Numerical Method \n Use the following discretization techniques: \n - Backward finite difference for convective terms \n - Centered finite difference for diffusion terms \n - Jacobi iteration for pressure correction \n - Time integration using a simple explicit method \n Implementation Steps \n 1. Define simulation parameters (L, nx, ny, nt, Re, dt). \n 2. Discretize the equations using FDM. \n 3. Initialize velocity and pressure fields. \n 4. Implement the SIMPLE method for velocity-pressure coupling. \n 5. Iterate until convergence using a residual-based stopping criterion. \n 6. Visualize velocity fields using quiver plots and pressure contours. \n Expected Output \n Generate a quiver plot of velocity vectors and a contour plot of pressure distribution.",
        "Fully_Developed_Turbulent_Channel_Flow": "\n Objective \n Develop a Python program to solve the fully-developed turbulent flow in a channel using the Reynolds-Averaged Navier-Stokes (RANS) equations and the Finite Difference Method (FDM). \n Governing Equation \n Solve the simplified form of the RANS equation under the Boussinesq approximation: \n d/dy ( [μ + μ_t] du/dy ) = -1 \n where μ is the kinematic viscosity and μ_t is the eddy viscosity. \n Computational Domain \n The equation is solved in the vertical direction y ∈ [0, H] with appropriate boundary conditions. \n Boundary Conditions \n - No-slip condition at the walls (y=0, y=H): u = 0 \n - Prescribed eddy viscosity profile for turbulent effects. \n Numerical Method \n Use second-order finite difference discretization to approximate the derivatives. \n Solve the resulting linear system Au = -1 using a direct linear solver (e.g., NumPy’s `linalg.solve`). \n Implementation Steps \n 1. Define parameters (H, ny, μ, μ_t). \n 2. Discretize the domain using finite difference approximations. \n 3. Assemble the coefficient matrix A and right-hand side vector b. \n 4. Solve for velocity u using a linear system solver. \n 5. Visualize the velocity profile u(y). \n Expected Output \n Generate a plot showing the velocity profile u(y) across the channel height.",
        "2D_Diffusion_FVM": "\n Objective \n Develop a Python program to solve the 2D diffusion equation using the Finite Volume Method (FVM). \n Governing Equation \n Solve the diffusion equation for w-velocity in a square duct: \n ∇ · (μ ∇w) - dP/dz = 0 \n Computational Domain \n The equation is solved over a square duct with sides of length h = 0.1 m. \n Boundary Conditions \n - No-slip conditions at all solid boundaries: w = 0 \n - Constant pressure gradient dP/dz = -3.2 Pa/m \n Fluid Properties \n - Dynamic viscosity μ = 1 × 10⁻³ Pa·s \n - Density ρ = 1 kg/m³ \n Numerical Method \n Use the Finite Volume Method (FVM) with a second-order central difference scheme. \n Discretize the governing equation using a structured Cartesian grid. \n Implementation Steps \n 1. Define parameters (h, nx, ny, dP/dz, μ). \n 2. Discretize the domain into control volumes. \n 3. Assemble the system of equations using the finite volume approach. \n 4. Solve the linear system for w using an iterative solver (e.g., Gauss-Seidel, Jacobi). \n 5. Visualize the velocity distribution using a contour plot. \n Expected Output \n Generate a contour plot showing the w-velocity distribution across the square duct.",
        "1D_Burgers_Equation": "\n Objective \n Develop a Python program to solve the 1D Burgers’ Equation using the Finite Difference Method (FDM). \n Governing Equation \n Solve the nonlinear convection-diffusion equation: \n ∂u/∂t + u ∂u/∂x = ν ∂²u/∂x² \n Computational Domain \n The equation is solved over x ∈ [0, 2π], t ∈ [0, T], with periodic boundary conditions. \n Initial Condition \n The initial condition is given by: \n u = - (2ν/φ) ∂φ/∂x + 4 \n where φ = exp(-x²/4ν) + exp(-(x - 2π)²/4ν). \n Numerical Method \n Use: \n 1. Forward difference for time discretization. \n 2. Backward difference for space discretization (advection term). \n 3. Second-order central difference for diffusion term. \n Ensure numerical stability by choosing an appropriate time step based on the CFL condition. \n Implementation Steps \n 1. Define parameters (L, T, nx, nt, ν). \n 2. Discretize space and time, ensuring CFL stability. \n 3. Initialize the velocity field using the given initial condition. \n 4. Iterate using the finite difference scheme. \n 5. Apply periodic boundary conditions. \n 6. Compare the numerical solution with the analytical solution. \n 7. Plot and visualize the solution evolution over time. \n Expected Output \n Generate plots comparing numerical and exact solutions to analyze accuracy and convergence.",
        "2D_Linear_Convection": "\n Objective \n Develop a Python program to solve the 2D Linear Convection Equation using the Finite Difference Method (FDM). \n Governing Equation \n Solve the PDE: \n ∂u/∂t + c ∂u/∂x + c ∂u/∂y = 0 \n Computational Domain \n The equation is solved over a rectangular domain with x, y ∈ [0, 2]. \n Initial Condition \n The initial condition is given by: \n u(x, y) = 2 for 0.5 ≤ x, y ≤ 1 \n u(x, y) = 1 elsewhere. \n Boundary Conditions \n The boundary conditions are: \n u = 1 for x = 0, 2 \n u = 1 for y = 0, 2 \n Numerical Method \n Use: \n 1. Forward difference for time discretization. \n 2. Backward difference for spatial discretization. \n Ensure numerical stability by choosing an appropriate time step based on the CFL condition. \n Implementation Steps \n 1. Define parameters (Lx, Ly, T, nx, ny, nt, c). \n 2. Discretize space and time, ensuring CFL stability. \n 3. Initialize the field using the given initial condition. \n 4. Iterate using the finite difference scheme. \n 5. Apply boundary conditions. \n 6. Visualize the evolution of u(x, y) over time. \n Expected Output \n Generate a contour plot or surface plot showing the evolution of u(x, y) over time.",
        "2D_Convection": "\n Objective \n Develop a Python program to solve the 2D Convection Equation using the Finite Difference Method (FDM). \n Governing Equation \n Solve the coupled PDE system: \n ∂u/∂t + u ∂u/∂x + v ∂u/∂y = 0 \n ∂v/∂t + u ∂v/∂x + v ∂v/∂y = 0 \n Computational Domain \n The equation is solved over a rectangular domain with x, y ∈ [0, 2]. \n Initial Condition \n The initial condition is given by: \n u, v = 2 for x, y ∈ (0.5,1) × (0.5,1) \n u, v = 1 elsewhere. \n Boundary Conditions \n The boundary conditions are: \n u = 1, v = 1 for x = 0, 2 \n u = 1, v = 1 for y = 0, 2 \n Numerical Method \n Use: \n 1. Forward difference for time discretization. \n 2. Backward difference for spatial discretization. \n Ensure numerical stability by choosing an appropriate time step based on the CFL condition. \n Implementation Steps \n 1. Define parameters (Lx, Ly, T, nx, ny, nt). \n 2. Discretize space and time, ensuring CFL stability. \n 3. Initialize the velocity field using the given initial condition. \n 4. Iterate using the finite difference scheme for both u and v. \n 5. Apply boundary conditions. \n 6. Visualize the evolution of u(x, y) and v(x, y) over time using quiver plots. \n Expected Output \n Generate a quiver plot showing the evolution of the velocity field over time.",
        "2D_Diffusion": "\n Objective \n Develop a Python program to solve the 2D Diffusion Equation using the Finite Difference Method (FDM). \n Governing Equation \n Solve the equation: \n ∂u/∂t = ν (∂²u/∂x² + ∂²u/∂y²) \n Computational Domain \n The equation is solved over a rectangular domain with x, y ∈ [0, L]. \n Numerical Method \n Use: \n 1. Forward difference for time discretization. \n 2. Central difference for second-order spatial derivatives. \n Ensure numerical stability by choosing an appropriate time step based on the diffusion coefficient (ν) and grid spacing (Δx, Δy). \n Implementation Steps \n 1. Define parameters (Lx, Ly, T, nx, ny, nt, ν). \n 2. Discretize space and time, ensuring stability using the CFL-like condition for diffusion. \n 3. Initialize the field u(x, y) with an initial condition. \n 4. Iterate using the finite difference scheme. \n 5. Apply appropriate boundary conditions. \n 6. Visualize the evolution of u(x, y) over time using a heatmap. \n Expected Output \n Generate a heatmap showing the evolution of the scalar field u(x, y) over time.",
        "2D_Laplace_Equation": "\n Objective \n Develop a Python program to solve the 2D Laplace Equation using the Finite Difference Method (FDM). \n Governing Equation \n Solve the steady-state equation: \n ∂²p/∂x² + ∂²p/∂y² = 0 \n Computational Domain \n The equation is solved on a rectangular domain with x ∈ [0, Lx], y ∈ [0, Ly]. \n Numerical Method \n Use the second-order **central difference scheme** for spatial discretization. \n Apply the **five-point difference operator** to solve for equilibrium state iteratively. \n Implementation Steps \n 1. Define parameters (Lx, Ly, nx, ny). \n 2. Discretize the domain using grid spacing (Δx, Δy). \n 3. Initialize the solution with p = 0 everywhere. \n 4. Apply boundary conditions: \n    - p = 0 at x = 0 \n    - p = y at x = Lx \n    - ∂p/∂y = 0 at y = 0, y = Ly \n 5. Use an **iterative solver** (Jacobi or Gauss-Seidel) to update p until convergence. \n 6. Visualize the solution using a contour plot. \n Expected Output \n Generate a contour plot showing the steady-state distribution of p(x, y)."
    }
}

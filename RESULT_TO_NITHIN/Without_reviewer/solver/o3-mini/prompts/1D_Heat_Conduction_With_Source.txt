#!/usr/bin/env python3
import numpy as np

# Given parameters
k = 1000.0          # Thermal conductivity, W/(m*K)
Q = 2e6             # Uniform heat generation, W/m^3
L = 0.5             # Length of the rod, m

# Discretization parameters
N = 101             # Number of nodes
dx = L / (N - 1)    # Uniform grid spacing

# Generate spatial grid
x = np.linspace(0, L, N)

# Initialize temperature field
T = np.zeros(N)

# Apply Dirichlet boundary conditions
T[0] = 100.0        # T(x=0) = 100°C
T[-1] = 200.0       # T(x=0.5) = 200°C

# Assemble the linear system for interior nodes using the finite volume method
# For interior control volumes, the discretized equation is:
# (T[i+1] - 2*T[i] + T[i-1]) / dx^2 = - Q/k
# Multiplying through by dx^2 gives:
# T[i+1] - 2*T[i] + T[i-1] = - (Q*dx^2)/k
# We will solve for T[1] to T[N-2]
n_interior = N - 2
A = np.zeros((n_interior, n_interior))
b = np.zeros(n_interior)

for i in range(n_interior):
    # Main diagonal
    A[i, i] = -2.0
    # Lower diagonal
    if i > 0:
        A[i, i - 1] = 1.0
    # Upper diagonal
    if i < n_interior - 1:
        A[i, i + 1] = 1.0
    # Right-hand side contribution from the source term
    b[i] = - (Q * dx**2) / k

# Adjust the first and last equations to account for the boundary conditions
b[0]    -= T[0]    # Incorporate T(0)
b[-1]   -= T[-1]   # Incorporate T(L)

# Solve the linear system for the interior temperatures
T_interior = np.linalg.solve(A, b)

# Update the full temperature array with the computed interior values
T[1:-1] = T_interior

# Save the final temperature distribution as a 1D NumPy array in 'T.npy'
np.save("T.npy", T)
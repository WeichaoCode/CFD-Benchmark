#!/usr/bin/env python3
import numpy as np

# Parameters
nu = 0.3
L = 2.0
T_final = 0.0333

# Discretization parameters
nx = 201            # number of spatial points
dx = L / (nx - 1)   # spatial step size
x = np.linspace(0, L, nx)

# Stability condition: r = nu * dt / dx^2 <= 0.5 for explicit scheme
r = 0.4  # safety factor (r < 0.5)
dt = r * dx**2 / nu

# Number of time steps
nsteps = int(T_final / dt)
# Adjust dt to exactly reach T_final at final step
dt = T_final / nsteps

# Initial condition
u = np.ones(nx)
u[(x >= 0.5) & (x <= 1)] = 2.0

# Time integration using explicit finite differences (FTCS)
for step in range(nsteps):
    u_new = u.copy()
    # Update interior points
    u_new[1:-1] = u[1:-1] + nu * dt / dx**2 * (u[2:] - 2 * u[1:-1] + u[:-2])
    # Boundary conditions: keep fixed values (Dirichlet) as initial set values
    u_new[0] = u[0]
    u_new[-1] = u[-1]
    u = u_new

# Save final solution as a 1D NumPy array in 'u.npy'
np.save("u.npy", u)
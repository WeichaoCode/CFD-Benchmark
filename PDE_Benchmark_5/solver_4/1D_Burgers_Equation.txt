Here is a Python program implementing your objective:

First, import the necessary libraries.

```python
import numpy as np
from math import exp, pi
import matplotlib.pyplot as plt
```

Define the functions for initial condition and exact (analytical) solution.

```python
def initial_cond(x, nu):
    phi = np.exp(-x**2 / (4*nu)) + np.exp(-(x - 2*pi)**2 / (4*nu))
    return -2 * nu * (phi / (4 * nu)) + 4

def exact_solution(x, nu, t):
    phi = np.exp(-(x - 4*t)**2 / (4*nu*(t+1))) + np.exp(-(x - 4*t - 2*pi)**2 / (4*nu*(t+1)))
    return -2 * nu * (phi / (4*nu*(t+1))) + 4
```

Define parameters, discretize space and time, initialize velocity field and iterate.

```python
L = 2*pi
T = 0.5
nx = 101
nt = 100
nu = 0.07
dx = L / (nx - 1)
dt = T / nt
c = 1

x_space = np.linspace(0, L, nx)
t_space = np.linspace(0, T, nt)
u = np.asarray([initial_cond(x, nu) for x in x_space])

for n in range(nt):
    un = u.copy()
    for i in range(1, nx-1):
        u[i] = un[i] - un[i] * dt/dx *(un[i] - un[i-1]) + nu*dt/dx**2 * (un[i+1] - 2*un[i] + un[i-1])
    u[0] = un[0] - un[0] * dt/dx * (un[0] - un[-1]) + nu*dt/dx**2*(un[1] - 2*un[0] + un[-1])
    u[-1] = u[0]
```

Compare numerical solution with exact (analytical) solution and plot the results.

```python
u_exact = np.asarray([exact_solution(xi, nu, dt*nt) for xi in x_space])

plt.figure(figsize=(11, 7), dpi=100)
plt.plot(x_space, u, label='CFD Solution')
plt.plot(x_space, u_exact, label='Exact Solution')
plt.legend()
plt.xlim([0, 2*pi])
plt.ylim([0, 10])
plt.show()
```

Note: Make sure to always choose an appropriate time step dt and space discretization dx that fulfills the CFL condition in order to guarantee the stability of the numerical method. The Courant-Friedrichs-Lewy (CFL) condition is a necessary condition for stability while solving certain partial differential equations (numerically).
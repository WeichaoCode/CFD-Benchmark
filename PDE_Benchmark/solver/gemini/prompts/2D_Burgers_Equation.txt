```python
import numpy as np

def solve_navier_stokes():
    # Parameters
    nx = 41
    ny = 41
    nt = 50
    nu = 0.01
    dx = 2 / (nx - 1)
    dy = 2 / (ny - 1)
    dt = 0.001

    # Initialization
    u = np.ones((ny, nx))
    v = np.ones((ny, nx))
    u[int(0.5/dy):int(1/dy+1), int(0.5/dx):int(1/dx+1)] = 2
    v[int(0.5/dy):int(1/dy+1), int(0.5/dx):int(1/dx+1)] = 2

    # Time loop
    for n in range(nt):
        un = u.copy()
        vn = v.copy()

        # Spatial loop
        for j in range(1, ny - 1):
            for i in range(1, nx - 1):
                u[j, i] = un[j, i] - dt * (un[j, i] * (un[j, i] - un[j, i - 1]) / dx +
                                              vn[j, i] * (un[j, i] - un[j - 1, i]) / dy) + \
                          nu * dt * ((un[j, i + 1] - 2 * un[j, i] + un[j, i - 1]) / dx**2 +
                                       (un[j + 1, i] - 2 * un[j, i] + un[j - 1, i]) / dy**2)

                v[j, i] = vn[j, i] - dt * (un[j, i] * (vn[j, i] - vn[j, i - 1]) / dx +
                                              vn[j, i] * (vn[j, i] - vn[j - 1, i]) / dy) + \
                          nu * dt * ((vn[j, i + 1] - 2 * vn[j, i] + vn[j, i - 1]) / dx**2 +
                                       (vn[j + 1, i] - 2 * vn[j, i] + vn[j - 1, i]) / dy**2)

        # Boundary conditions
        u[:, 0] = 1
        u[:, -1] = 1
        u[0, :] = 1
        u[-1, :] = 1

        v[:, 0] = 1
        v[:, -1] = 1
        v[0, :] = 1
        v[-1, :] = 1
    
    np.save('u.npy', u)
    np.save('v.npy', v)

solve_navier_stokes()
```
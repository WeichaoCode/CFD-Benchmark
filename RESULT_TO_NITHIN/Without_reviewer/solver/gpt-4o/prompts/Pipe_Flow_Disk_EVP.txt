```python
import numpy as np
from scipy.sparse import diags
from scipy.sparse.linalg import eigs

# Parameters
Re = 1e4
s = 0  # Eigenvalue (temporal growth/decay rate)
k_z = 1  # Axial wave number

# Domain discretization
Nr = 100  # Number of radial points
Nphi = 100  # Number of azimuthal points
r = np.linspace(0, 1, Nr)
phi = np.linspace(0, 2 * np.pi, Nphi)
dr = r[1] - r[0]
dphi = phi[1] - phi[0]

# Background flow
w0 = 1 - r**2

# Construct finite difference matrices
D2r = diags([1, -2, 1], [-1, 0, 1], shape=(Nr, Nr)) / dr**2
D2r = D2r.tolil()
D2r[0, 0] = D2r[-1, -1] = 1  # Dirichlet BC at r=0 and r=1

D2phi = diags([1, -2, 1], [-1, 0, 1], shape=(Nphi, Nphi)) / dphi**2
D2phi = D2phi.tolil()
D2phi[0, -1] = D2phi[-1, 0] = 1  # Periodic BC in phi

# Laplacian operator in cylindrical coordinates
Laplacian = np.kron(np.eye(Nphi), D2r) + np.kron(D2phi, np.eye(Nr))

# Construct the linearized Navier-Stokes operator
A = np.zeros((Nr * Nphi, Nr * Nphi), dtype=complex)
B = np.zeros((Nr * Nphi, Nr * Nphi), dtype=complex)

# Fill the matrices A and B
for i in range(Nr):
    for j in range(Nphi):
        idx = i * Nphi + j
        A[idx, idx] = s + w0[i] * 1j * k_z
        B[idx, idx] = -1 / Re * Laplacian[idx, idx]

# Solve the eigenvalue problem
eigenvalues, eigenvectors = eigs(A + B, k=1, which='LR')

# Extract the eigenmode corresponding to the largest eigenvalue
u_eigenmode = eigenvectors[:, 0].real
w_eigenmode = eigenvectors[:, 0].imag

# Reshape the eigenmodes to 2D arrays
u_eigenmode_2d = u_eigenmode.reshape((Nr, Nphi))
w_eigenmode_2d = w_eigenmode.reshape((Nr, Nphi))

# Save the results
np.save('u_eigenmode.npy', u_eigenmode_2d)
np.save('w_eigenmode.npy', w_eigenmode_2d)
```
Here is a Python code snippet implementing the various stages of a finite difference solver for the 1D Burgers' Equation.

```python
import numpy as np
from matplotlib import pyplot as plt
import time, sys

# 1. Define the parameters
L = 2.0*np.pi    # length of the domain
T = 1.0          # time of the simulation
nx = 101         # number of spatial grid points
nt = 1000        # number of time steps
nu = 0.07        # viscosity

dx = L / (nx-1)  # spatial grid size
dt = T / nt      # time step size

# Ensure CFL stability
CFL = nu * dt / dx**2
if CFL >= 0.5:
    print("WARNING: CFL condition not met")

# 2. Discretize the domain
x = np.linspace(0, L, nx)

# 3. Initialize the velocity field
phi = np.exp(-x**2 / (4*nu)) + np.exp(-(x - L)**2 / (4*nu))
u = -2 * nu * (np.gradient(phi, dx)) / phi + 4

# Save the initial condition
u_analytical = np.copy(u)

# 4. Finite difference scheme
for n in range(nt): 

    # 4.1 Save the existing velocity field
    un = np.copy(u)

    # 4.2 Compute the new velocity field
    u[1:-1] = (un[1:-1] - 
               un[1:-1] * dt / dx * (un[1:-1] - un[:-2]) +
               nu * dt / dx**2 * (un[2:] - 2 * un[1:-1] + un[:-2]))

    # 5. Periodic boundary conditions
    u[0] = (un[0] -
            un[0] * dt / dx * (un[0] - un[-2]) +
            nu * dt / dx**2 * (un[1] - 2 * un[0] + un[-2]))

    u[-1] = u[0]

# 5. Analytical solution
phi = np.exp(-(x - 4 * T)**2 / (4 * nu * (T + 1))) + np.exp(-(x - 4 * T - 2 * np.pi)**2 / (4 * nu * (T + 1)))
u_analytical = -2 * nu * (np.gradient(phi, dx)) / phi + 4

# 6. Plot and visualize
plt.figure(figsize=(11, 7), dpi=100)
plt.plot(x, u, marker='o', lw=2, label='Computational')
plt.plot(x, u_analytical, marker='x', lw=2, label='Analytical')
plt.xlim([0, L])
plt.ylim([0, 10])
plt.legend();
plt.show()
```
This code begins by defining the various parameters and spatial grid, initializes the velocity field, iterates over each time step, applies the boundary conditions, and finally compares the numerical solution to the expected analytical solution.

The two methods are then plotted against each other to visualize the effectiveness of the computational model.
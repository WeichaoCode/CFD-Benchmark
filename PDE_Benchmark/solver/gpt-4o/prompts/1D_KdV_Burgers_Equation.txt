```python
import numpy as np

# Parameters
a = 1e-4
b = 2e-4
L = 10.0
T = 10.0
n = 20

# Discretization
nx = 256
nt = 1000
dx = L / nx
dt = T / nt

# Spatial and temporal grids
x = np.linspace(0, L, nx, endpoint=False)
t = np.linspace(0, T, nt)

# Initial condition
u = 0.5 / n * np.log(1 + (np.cosh(n)**2) / (np.cosh(n * (x - 0.2 * L))**2))

# Function to compute spatial derivatives using spectral methods
def spectral_derivative(u, order):
    k = np.fft.fftfreq(nx, d=dx) * 2 * np.pi
    u_hat = np.fft.fft(u)
    if order == 1:
        derivative = np.fft.ifft(1j * k * u_hat).real
    elif order == 2:
        derivative = np.fft.ifft(-k**2 * u_hat).real
    elif order == 3:
        derivative = np.fft.ifft(-1j * k**3 * u_hat).real
    return derivative

# Time-stepping using a simple explicit method
for _ in range(nt):
    u_x = spectral_derivative(u, 1)
    u_xx = spectral_derivative(u, 2)
    u_xxx = spectral_derivative(u, 3)
    
    # Update u using a forward Euler step
    u_new = u - dt * (u * u_x - a * u_xx - b * u_xxx)
    
    # Avoid overflow by clipping the values
    u_new = np.clip(u_new, -1e10, 1e10)
    
    # Update the solution
    u = u_new

# Save the final solution
np.save('u.npy', u)
```
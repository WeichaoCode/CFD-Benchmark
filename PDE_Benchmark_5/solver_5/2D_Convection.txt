Here's a Python code implementation for your instruction.

```python
import numpy as np
import matplotlib.pyplot as plt

# Computational domain
Lx = Ly = 2
nx = ny = 101
nt = 100
dx = Lx/(nx - 1)
dy = Ly/(ny - 1)
dt = 0.01

# Initial conditions
u = np.ones((ny, nx))
v = np.ones((ny, nx))

u[int(.5 / dy):int(1 / dy + 1),int(.5 / dx):int(1 / dx + 1)] = 2
v[int(.5 / dy):int(1 / dy + 1),int(.5 / dx):int(1 / dx + 1)] = 2

# Compute and apply finite difference for each time step
for n in range(nt + 1):
    un = u.copy()
    vn = v.copy()
    
    u[1:, 1:] = (un[1:, 1:] - dt/dx*un[1:, 1:]*(un[1:, 1:] - un[1:, :-1]) -
                 dt/dy*vn[1:, 1:]*(un[1:, 1:] - un[:-1, 1:]))
    v[1:, 1:] = (vn[1:, 1:] - dt/dx*un[1:, 1:]*(vn[1:, 1:] - vn[1:, :-1]) -
                 dt/dy*vn[1:, 1:]*(vn[1:, 1:] - vn[:-1, 1:]))
    
    # Apply boundary conditions
    u[0, :] = 1
    u[-1, :] = 1
    u[:, 0] = 1
    u[:, -1] = 1
    
    v[0, :] = 1
    v[-1, :] = 1
    v[:, 0] = 1
    v[:, -1] = 1

# Plotting the solution using quiver plot
Y, X = np.mgrid[0:2:(nx*1j), 0:2:(ny*1j)]
plt.quiver(X, Y, u, v)
plt.title('Evolution of velocity field')
plt.show()
```

This script computes the solution to the 2D convection equations using the finite difference method, and then plots the resulting velocity field. Note that the time step size `dt = 0.01` is chosen empirically here, but in a more rigorous setting, one would need to ensure stability by checking the CFL condition. 

Also, as per the CFL condition, this requires that `dt <= min(dx,dy)/sqrt(2)`. This scales appropriately with mesh size and is important for simulation accuracy or 'stability'. For complex simulations or multidimensional domains, an adaptive time stepping algorithm can be used as well.

This code assumes backward difference for spatial discretization and forward difference for time discretization, following the guidelines in the question. The field is then visualized using a quiver plot.
"""
2D Diffusion Equation Solver using MMS (Stable)
---------------------------------------------------------------
- MMS Solution: u(x, y, t) = exp(-t) * sin(pi * x) * sin(pi * y)
- Finite Difference Method (Explicit Scheme)
- CFL condition enforced for stability
- Dirichlet boundary conditions from MMS
- Code generated by LLM: chatgpt-4o with RAG
- The prompt and output is saved in the prompt.md
---------------------------------------------------------------
Author: Weichao Li
Date: 2025/03/31
"""
import numpy as np
import matplotlib.pyplot as plt

# ---------------- PARAMETERS ----------------
Lx, Ly = 1.0, 1.0  # Domain size
T = 0.2  # Total time
ν = 0.05  # Diffusion coefficient

# Discretization
nx, ny = 50, 50  # Number of grid points
dx = Lx / (nx - 1)
dy = Ly / (ny - 1)
dt = 0.0005  # Time step

# Stability condition for ADI method
σx = ν * dt / (2 * dx ** 2)
σy = ν * dt / (2 * dy ** 2)

# Define spatial and temporal grids
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)
t = np.arange(0, T + dt, dt)
X, Y = np.meshgrid(x, y, indexing='ij')


# ---------------- MMS Solution ----------------
def mms_solution(x_f, y_f, t_f):
    return np.exp(-t_f) * np.sin(np.pi * x_f) * np.sin(np.pi * y_f)


# ---------------- Source Term Computation ----------------
def f_source(x_f, y_f, t_f):
    return (ν * 2 * np.pi ** 2 - 1) * np.exp(-t_f) * np.sin(np.pi * x_f) * np.sin(np.pi * y_f)


# ---------------- INITIAL AND BOUNDARY CONDITIONS ----------------
u = np.zeros((nx, ny, len(t)))  # Store full time history
u[:, :, 0] = mms_solution(X, Y, 0)  # Initial condition

# ---------------- SOLVE USING ADI METHOD ----------------
for n in range(len(t) - 1):
    f_t = f_source(X, Y, t[n])  # Compute source term at current time step

    # Step 1: Implicit in x, Explicit in y
    u_star = np.copy(u[:, :, n])
    for j in range(1, ny - 1):
        A = np.zeros((nx, nx))
        b = np.zeros(nx)
        for i in range(1, nx - 1):
            A[i, i - 1] = -σx
            A[i, i] = 1 + 2 * σx
            A[i, i + 1] = -σx
            b[i] = (1 - 2 * σy) * u[i, j, n] + σy * (u[i, j - 1, n] + u[i, j + 1, n]) + dt * f_t[i, j]

        # Apply MMS boundary conditions at next time step
        A[0, 0] = A[-1, -1] = 1.0
        b[0] = mms_solution(x[0], y[j], t[n + 1])
        b[-1] = mms_solution(x[-1], y[j], t[n + 1])

        u_star[:, j] = np.linalg.solve(A, b)

    # Step 2: Implicit in y, Explicit in x
    for i in range(1, nx - 1):
        A = np.zeros((ny, ny))
        b = np.zeros(ny)
        for j in range(1, ny - 1):
            A[j, j - 1] = -σy
            A[j, j] = 1 + 2 * σy
            A[j, j + 1] = -σy
            b[j] = (1 - 2 * σx) * u_star[i, j] + σx * (u_star[i - 1, j] + u_star[i + 1, j]) + dt * f_t[i, j]

        # Apply MMS boundary conditions at next time step
        A[0, 0] = A[-1, -1] = 1.0
        b[0] = mms_solution(x[i], y[0], t[n + 1])
        b[-1] = mms_solution(x[i], y[-1], t[n + 1])

        u[i, :, n + 1] = np.linalg.solve(A, b)

# ---------------- COMPUTE EXACT SOLUTION FOR COMPARISON ----------------
u_exact = np.zeros((nx, ny, len(t)))
for n in range(len(t)):
    u_exact[:, :, n] = mms_solution(X, Y, t[n])

# ---------------- ERROR ANALYSIS ----------------
error = np.abs(u - u_exact)

# ---------------- PLOTTING RESULTS ----------------
fig, axes = plt.subplots(1, 3, figsize=(18, 5))

# Numerical solution at final time step
ax1 = axes[0]
c1 = ax1.contourf(X, Y, u[:, :, -1], cmap="viridis")
plt.colorbar(c1, ax=ax1)
ax1.set_title("Numerical Solution at t = T")
ax1.set_xlabel("x")
ax1.set_ylabel("y")

# MMS (exact) solution at final time step
ax2 = axes[1]
c2 = ax2.contourf(X, Y, u_exact[:, :, -1], cmap="viridis")
plt.colorbar(c2, ax=ax2)
ax2.set_title("MMS (Exact) Solution at t = T")
ax2.set_xlabel("x")
ax2.set_ylabel("y")

# Absolute Error at final time step
ax3 = axes[2]
c3 = ax3.contourf(X, Y, error[:, :, -1], cmap="inferno")  # Using 'inferno' to highlight errors
plt.colorbar(c3, ax=ax3)
ax3.set_title("Absolute Error |u - MMS| at t = T")
ax3.set_xlabel("x")
ax3.set_ylabel("y")

plt.suptitle(f"Comparison at t = {T}", fontsize=14)
plt.tight_layout()
plt.savefig("/opt/CFD-Benchmark/Prompt_eng/2D_diffusion/image.png")
plt.show()



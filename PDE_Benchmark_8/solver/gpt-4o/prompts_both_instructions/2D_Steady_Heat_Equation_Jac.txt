```python
import numpy as np
import matplotlib.pyplot as plt

# Domain parameters
Lx, Ly = 5.0, 4.0
dx, dy = 0.05, 0.05
nx, ny = 101, 81

# Create grid
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)

# Initialize temperature field
T = np.zeros((ny, nx))

# Boundary conditions
T[:, 0] = 10.0  # Left boundary
T[:, -1] = 40.0  # Right boundary
T[0, :] = 0.0  # Top boundary
T[-1, :] = 20.0  # Bottom boundary

# Parameters for the Jacobi iteration
beta = dx / dy
tolerance = 1e-4
max_iterations = 10000

# Jacobi iteration
for iteration in range(max_iterations):
    T_new = np.copy(T)
    
    # Update the temperature field using Jacobi method
    for j in range(1, ny-1):
        for i in range(1, nx-1):
            T_new[j, i] = (T[j, i+1] + T[j, i-1] + beta**2 * (T[j+1, i] + T[j-1, i])) / (2 * (1 + beta**2))
    
    # Enforce Dirichlet boundary conditions
    T_new[:, 0] = 10.0  # Left boundary
    T_new[:, -1] = 40.0  # Right boundary
    T_new[0, :] = 0.0  # Top boundary
    T_new[-1, :] = 20.0  # Bottom boundary
    
    # Check for convergence
    if np.max(np.abs(T_new - T)) < tolerance:
        print(f"Converged after {iteration} iterations.")
        break
    
    T = T_new

# Save the final temperature field
np.save('T.npy', T)

# Plot the final temperature distribution
plt.figure(figsize=(8, 6))
plt.contourf(x, y, T, 20, cmap='hot')
plt.colorbar(label='Temperature (Â°C)')
plt.title('Steady-State Temperature Distribution')
plt.xlabel('x')
plt.ylabel('y')
plt.gca().invert_yaxis()
plt.show()
```

This code solves the given 2D steady-state heat equation using the Jacobi iteration method. It initializes the temperature field, applies the specified Dirichlet boundary conditions, and iterates until convergence is achieved. The final temperature distribution is saved as a `.npy` file and visualized using a contour plot.
```python
import numpy as np

def solve_pde(c, epsilon, x_start, x_end, N_x, t_final):
    dx = (x_end - x_start) / (N_x - 1)
    x = np.linspace(x_start, x_end, N_x)
    
    if epsilon != 0:
        dt_conv = dx / c
        dt_diff = dx**2 / (2 * epsilon)
        dt = 0.4 * min(dt_conv, dt_diff)
    else:
        dt = 0.4 * (dx / c)
    
    N_t = int(t_final / dt) + 1
    dt = t_final / N_t
    
    u = np.exp(-x**2)
    
    for _ in range(N_t):
        # Compute F(u)
        du_dx = np.roll(u, -1) - np.roll(u, 1)
        du_dx /= (2 * dx)
        d2u_dx2 = np.roll(u, -1) - 2 * u + np.roll(u, 1)
        d2u_dx2 /= dx**2
        F = -c * du_dx + epsilon * d2u_dx2
        
        # Predictor step
        u_p = u + dt * F
        
        # Compute F(u_p)
        du_dx_p = np.roll(u_p, -1) - np.roll(u_p, 1)
        du_dx_p /= (2 * dx)
        d2u_dx2_p = np.roll(u_p, -1) - 2 * u_p + np.roll(u_p, 1)
        d2u_dx2_p /= dx**2
        F_p = -c * du_dx_p + epsilon * d2u_dx2_p
        
        # Corrector step
        u = u + 0.5 * dt * (F + F_p)
    
    return u

if __name__ == "__main__":
    c = 1
    x_start = -5
    x_end = 5
    N_x = 101
    t_final = 1.0
    epsilons = [0, 5e-4]
    
    for epsilon in epsilons:
        u_final = solve_pde(c, epsilon, x_start, x_end, N_x, t_final)
        if epsilon == 0:
            filename = 'u_epsilon0.npy'
        else:
            filename = f'u_epsilon{epsilon}.npy'
        np.save(filename, u_final)
```
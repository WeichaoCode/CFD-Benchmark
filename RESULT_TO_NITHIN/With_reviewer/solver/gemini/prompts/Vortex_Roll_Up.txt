```python
import numpy as np

def solve_cfd():
    # Parameters
    nx = 64
    ny = 64
    nt = 100
    nu = 0.001
    dt = 0.001
    dx = 1.0 / (nx - 1)
    dy = 1.0 / (ny - 1)

    # Initialize variables
    psi = np.zeros((ny, nx))
    omega = np.zeros((ny, nx))

    # Initial condition (vortex initialization)
    center_x = 0.5
    center_y = 0.5
    radius = 0.1
    strength = 10.0

    for i in range(ny):
        for j in range(nx):
            x = j * dx
            y = i * dy
            r = np.sqrt((x - center_x)**2 + (y - center_y)**2)
            if r < radius:
                omega[i, j] = strength * np.exp(-r**2 / (2 * radius**2))

    # Finite difference functions
    def laplacian(phi, dx, dy):
        return (
            (phi[2:, 1:-1] - 2 * phi[1:-1, 1:-1] + phi[:-2, 1:-1]) / dy**2
            + (phi[1:-1, 2:] - 2 * phi[1:-1, 1:-1] + phi[1:-1, :-2]) / dx**2
        )

    def solve_poisson(omega, dx, dy):
        psi = np.zeros_like(omega)
        max_iter = 1000
        tolerance = 1e-6
        for _ in range(max_iter):
            psi_old = psi.copy()
            psi[1:-1, 1:-1] = 0.25 * (
                psi[2:, 1:-1] + psi[:-2, 1:-1] + psi[1:-1, 2:] + psi[1:-1, :-2]
                + omega[1:-1, 1:-1] * dx**2
            )
            # Boundary conditions
            psi[:, 0] = psi[:, -2]
            psi[:, -1] = psi[:, 1]
            psi[0, :] = 0
            psi[-1, :] = 0

            max_diff = np.max(np.abs(psi - psi_old))
            if max_diff < tolerance:
                break
        return psi

    def calculate_velocity(psi, dx, dy):
        u = np.zeros_like(psi)
        v = np.zeros_like(psi)
        u[1:-1, 1:-1] = (psi[1:-1, 2:] - psi[1:-1, :-2]) / (2 * dx)
        v[1:-1, 1:-1] = -(psi[2:, 1:-1] - psi[:-2, 1:-1]) / (2 * dy)
        return u, v

    # Time loop
    for n in range(nt):
        # Solve Poisson equation for streamfunction
        psi = solve_poisson(omega, dx, dy)

        # Calculate velocity components
        u, v = calculate_velocity(psi, dx, dy)

        # Vorticity transport equation (explicit Euler)
        omega_old = omega.copy()
        omega[1:-1, 1:-1] = (
            omega_old[1:-1, 1:-1]
            - dt * (
                u[1:-1, 1:-1] * (omega_old[1:-1, 2:] - omega_old[1:-1, :-2]) / (2 * dx)
                + v[1:-1, 1:-1] * (omega_old[2:, 1:-1] - omega_old[:-2, 1:-1]) / (2 * dy)
            )
            + nu * dt * laplacian(omega_old, dx, dy)
        )

        # Boundary conditions
        omega[:, 0] = omega[:, -2]
        omega[:, -1] = omega[:, 1]
        omega[0, :] = (4*omega[1,:] - omega[2,:])
        omega[-1, :] = (4*omega[-2,:] - omega[-3,:])

    # Save the final solution
    np.save('psi.npy', psi)
    np.save('omega.npy', omega)

solve_cfd()
```
```python
import numpy as np

# Constants
rho = 1.0
C_mu = 0.09
C_e1 = 1.44
C_e2 = 1.92
sigma_k = 1.0
sigma_epsilon = 1.3
mu = 1e-3  # Molecular viscosity
H = 2.0
n = 100
tolerance = 1e-6
max_iterations = 10000

# Create non-uniform grid clustered near walls using cosine transformation
xi = np.linspace(0, 1, n)
y = 0.5 * H * (1 - np.cos(np.pi * xi))
dy = np.diff(y)

# Initialize variables with small positive values to avoid division by zero
k = np.ones(n) * 1e-6
epsilon = np.ones(n) * 1e-6

# Functions for near-wall effects
f_mu = 1.0
f1 = 1.0
f2 = 1.0

# Velocity gradient (assuming du/dy = 0.5)
du_dy = 0.5

# Iterative solver
for iteration in range(max_iterations):
    k_old = k.copy()
    epsilon_old = epsilon.copy()
    
    # Compute turbulent viscosity
    mu_t = C_mu * f_mu * rho * (k**2) / (epsilon + 1e-12)
    P_k = 0.25 * mu_t * (du_dy**2)
    
    # Assemble A and b for k equation
    A_k = np.zeros((n, n))
    b_k = rho * epsilon
    
    # Boundary conditions for k (assuming k=0 at walls)
    A_k[0,0] = 1.0
    b_k[0] = 0.0
    A_k[-1,-1] = 1.0
    b_k[-1] = 0.0
    
    # Interior points for k
    for i in range(1, n-1):
        dy_i = y[i+1] - y[i]
        dy_im = y[i] - y[i-1]
        a_plus = mu + mu_t[i]/sigma_k
        a_minus = mu + mu_t[i-1]/sigma_k
        A_k[i, i-1] = a_minus / dy_im
        A_k[i, i] = -(a_plus / dy_i + a_minus / dy_im)
        A_k[i, i+1] = a_plus / dy_i
        b_k[i] = rho * epsilon[i]
    
    # Solve for k
    try:
        k = np.linalg.solve(A_k, b_k)
    except np.linalg.LinAlgError:
        print('Singular matrix encountered while solving for k.')
        break
    k[k < 1e-12] = 1e-12  # Prevent negative or zero k
    
    # Update turbulent viscosity and production
    mu_t = C_mu * f_mu * rho * (k**2) / (epsilon + 1e-12)
    P_k = 0.25 * mu_t * (du_dy**2)
    
    # Assemble A and b for epsilon equation
    A_e = np.zeros((n, n))
    b_e = (epsilon / (k + 1e-12)) * (C_e1 * f1 * P_k - C_e2 * f2 * epsilon)
    
    # Boundary conditions for epsilon (assuming epsilon=0 at walls)
    A_e[0,0] = 1.0
    b_e[0] = 0.0
    A_e[-1,-1] = 1.0
    b_e[-1] = 0.0
    
    # Interior points for epsilon
    for i in range(1, n-1):
        dy_i = y[i+1] - y[i]
        dy_im = y[i] - y[i-1]
        a_plus = mu + mu_t[i]/sigma_epsilon
        a_minus = mu + mu_t[i-1]/sigma_epsilon
        A_e[i, i-1] = a_minus / dy_im
        A_e[i, i] = -(a_plus / dy_i + a_minus / dy_im)
        A_e[i, i+1] = a_plus / dy_i
        b_e[i] = (C_e1 * f1 * P_k[i] - C_e2 * f2 * epsilon[i]) * (epsilon[i] / (k[i] + 1e-12))
    
    # Solve for epsilon
    try:
        epsilon = np.linalg.solve(A_e, b_e)
    except np.linalg.LinAlgError:
        print('Singular matrix encountered while solving for epsilon.')
        break
    epsilon[epsilon < 1e-12] = 1e-12  # Prevent negative or zero epsilon
    
    # Compute residuals
    res_k = np.max(np.abs(k - k_old))
    res_e = np.max(np.abs(epsilon - epsilon_old))
    res = max(res_k, res_e)
    
    if res < tolerance:
        print(f'Converged in {iteration+1} iterations.')
        break
else:
    print('Did not converge within the maximum number of iterations.')

# Final turbulent viscosity
mu_t = C_mu * f_mu * rho * (k**2) / (epsilon + 1e-12)

# Save the variables
np.save('k.npy', k)
np.save('epsilon.npy', epsilon)
np.save('mu_t.npy', mu_t)
```
```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
nx, ny = 41, 41
x = np.linspace(-1, 1, nx)
y = np.linspace(-1, 1, ny)
dx = x[1] - x[0]
dy = y[1] - y[0]
alpha = 1.0
sigma = 0.1
Q0 = 200.0
r = 0.0001  # Further reduced r to enhance numerical stability
dt = r * dx**2 / alpha
t_max = 3.0
n_steps = int(t_max / dt)

X, Y = np.meshgrid(x, y)
q = Q0 * np.exp(-(X**2 + Y**2) / (2 * sigma**2))

# Initial condition
T_initial = 1.0 + Q0 * np.exp(-(X**2 + Y**2) / (2 * sigma**2))
T_prev = T_initial.copy()

# Compute T_current using Forward Euler for the first time step
laplacian = (
    (np.roll(T_prev, 1, axis=0) + np.roll(T_prev, -1, axis=0) +
     np.roll(T_prev, 1, axis=1) + np.roll(T_prev, -1, axis=1) -
     4 * T_prev) / dx**2
)
T_current = T_prev + dt * (alpha * laplacian + q)

# Apply Dirichlet boundary conditions
T_current[0, :] = 1.0
T_current[-1, :] = 1.0
T_current[:, 0] = 1.0
T_current[:, -1] = 1.0

# Time-stepping using DuFort-Frankel method
for step in range(1, n_steps):
    T_new = np.empty_like(T_current)
    T_new[1:-1, 1:-1] = (
        2 * r * (
            T_current[2:, 1:-1] + T_current[:-2, 1:-1] +
            T_current[1:-1, 2:] + T_current[1:-1, :-2]
        ) +
        T_prev[1:-1, 1:-1] +
        2 * dt * q[1:-1, 1:-1]
    ) / (1 + 4 * r)
    
    # Apply Dirichlet boundary conditions
    T_new[0, :] = 1.0
    T_new[-1, :] = 1.0
    T_new[:, 0] = 1.0
    T_new[:, -1] = 1.0
    
    # Update for next time step
    T_prev, T_current = T_current, T_new

# Final temperature field
T = T_current.copy()

# Save the final temperature field
save_values = ['T']
np.save('T.npy', T)

# Visualization
plt.contourf(X, Y, T, levels=50, cmap='hot')
plt.colorbar(label='Temperature')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Final Temperature Field')
plt.show()
```
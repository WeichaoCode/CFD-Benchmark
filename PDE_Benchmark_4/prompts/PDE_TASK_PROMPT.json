{
    "prompts": {
        "1D_Linear_Convection": "\n    Write a Python function to solve the given PDE: **1D Linear Convection**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_1d_linear_convection(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 1D Linear Convection using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "1D_Nonlinear_Convection": "\n    Write a Python function to solve the given PDE: **1D Nonlinear Convection**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_1d_nonlinear_convection(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 1D Nonlinear Convection using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "1D_Burgers_Equation": "\n    Write a Python function to solve the given PDE: **1D Burgers Equation**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_1d_burgers_equation(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 1D Burgers Equation using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "1D_Diffusion": "\n    Write a Python function to solve the given PDE: **1D Diffusion**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_1d_diffusion(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 1D Diffusion using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "1D_Wave_Equation": "\n    Write a Python function to solve the given PDE: **1D Wave Equation**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_1d_wave_equation(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 1D Wave Equation using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "1D_Euler_Equations": "\n    Write a Python function to solve the given PDE: **1D Euler Equations**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_1d_euler_equations(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 1D Euler Equations using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "1D_Kuramoto_Sivashinsky": "\n    Write a Python function to solve the given PDE: **1D Kuramoto Sivashinsky**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_1d_kuramoto_sivashinsky(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 1D Kuramoto Sivashinsky using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "1D_Korteweg_de_Vries": "\n    Write a Python function to solve the given PDE: **1D Korteweg de Vries**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_1d_korteweg_de_vries(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 1D Korteweg de Vries using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "2D_Linear_Convection": "\n    Write a Python function to solve the given PDE: **2D Linear Convection**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_2d_linear_convection(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 2D Linear Convection using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "2D_Nonlinear_Convection": "\n    Write a Python function to solve the given PDE: **2D Nonlinear Convection**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_2d_nonlinear_convection(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 2D Nonlinear Convection using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "2D_Burgers_Equation": "\n    Write a Python function to solve the given PDE: **2D Burgers Equation**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_2d_burgers_equation(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 2D Burgers Equation using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "2D_Diffusion": "\n    Write a Python function to solve the given PDE: **2D Diffusion**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_2d_diffusion(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 2D Diffusion using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "2D_Wave_Equation": "\n    Write a Python function to solve the given PDE: **2D Wave Equation**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_2d_wave_equation(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 2D Wave Equation using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "2D_Euler_Equations": "\n    Write a Python function to solve the given PDE: **2D Euler Equations**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_2d_euler_equations(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 2D Euler Equations using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        ",
        "2D_Navier_Stokes": "\n    Write a Python function to solve the given PDE: **2D Navier Stokes**.\n\n    ### **Requirements**\n    - Use the **Finite Difference Method (FDM)** for discretization.\n    - Implement a **Manufactured Solution (MMS)** for validation.\n    - Compute the **Mean Squared Error (MSE)** to compare the numerical solution with the exact MMS.\n    - Plot both the **numerical solution** and the **exact MMS solution** in a 2D figure for comparison.\n    - Ensure the code is **numerically stable**, and enforce appropriate **CFL conditions** if needed.\n    - The function should be **modular**, allowing users to pass in problem-specific parameters.\n    - The function must return the computed numerical solution.\n\n    ### **Function Template**\n    ```python\n    def solve_2d_navier_stokes(nx, ny, nt, dx, dy, dt, *params):\n        \"\"\"\n        Solve the 2D Navier Stokes using the Finite Difference Method (FDM).\n\n        Parameters:\n            nx, ny, nt: Grid points in x, y, and time dimensions.\n            dx, dy, dt: Grid spacing and time step.\n            *params: Additional problem-specific parameters.\n\n        Returns:\n            numpy.ndarray: Computed numerical solution.\n        \"\"\"\n        # Step 1: Define the grid and initialize solution variables\n        # Step 2: Compute source term from MMS\n        # Step 3: Apply initial and boundary conditions\n        # Step 4: Solve the PDE iteratively using FDM\n        # Step 5: Compute the exact MMS solution for comparison\n        # Step 6: Calculate Mean Squared Error (MSE)\n        # Step 7: Plot numerical vs exact solutions\n\n        return solution\n        "
    }
}
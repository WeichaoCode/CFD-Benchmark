Here is a Python code that implements the solution:

```python
import numpy as np
import matplotlib.pyplot as plt

# Define the grid parameters
nx = 81
ny = 81
nt = 100
c = 1.0
sigma = 0.2
Lx = 2.0
Ly = 2.0
dx = Lx / (nx - 1)
dy = Ly / (ny - 1)
dt = sigma * min(dx, dy) / c

# Initialize the solution array
u = np.ones((ny, nx))

# Set the initial condition
u[int(0.5 / dy):int(1 / dy + 1), int(0.5 / dx):int(1 / dx + 1)] = 2

# Time-stepping loop
for n in range(nt):
    un = u.copy()
    u[1:, 1:] = (un[1:, 1:] - (c * dt / dx * (un[1:, 1:] - un[1:, :-1])) -
                 (c * dt / dy * (un[1:, 1:] - un[:-1, 1:])))
    u[0, :] = 1
    u[-1, :] = 1
    u[:, 0] = 1
    u[:, -1] = 1

# Save the solution in .npy format
np.save('solution.npy', u)

# Plot the solution
plt.figure(figsize=(8, 5))
plt.contourf(u, cmap='viridis')
plt.colorbar()
plt.title('2D Linear Convection')
plt.xlabel('x')
plt.ylabel('y')
plt.show()
```

This code first initializes the solution array `u` and sets the initial condition. Then, it enters a time-stepping loop where it updates the solution at each grid point based on the finite difference scheme. The boundary conditions are enforced after each update. Finally, the solution is saved in `.npy` format and visualized using a contour plot.
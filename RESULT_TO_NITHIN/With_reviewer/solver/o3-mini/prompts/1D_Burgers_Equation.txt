#!/usr/bin/env python3
import numpy as np

# Parameters
nu = 0.07
L = 2 * np.pi
T_final = 0.14 * np.pi

# Discretization parameters
Nx = 256
dx = L / Nx
x = np.linspace(0, L, Nx, endpoint=False)

# Initial condition: u = - 2*nu/phi * d(phi)/dx + 4, where phi as given
phi = np.exp(-x**2/(4*nu)) + np.exp(-(x - L)**2/(4*nu))
dphi_dx = (-x/(2*nu)) * np.exp(-x**2/(4*nu)) + (-(x - L)/(2*nu)) * np.exp(-(x - L)**2/(4*nu))
u = -2 * nu / phi * dphi_dx + 4

# Time stepping parameters
dt_fixed = 0.0001
nt = int(T_final / dt_fixed)
dt = T_final / nt  # adjust dt so that final time equals T_final exactly

# Time integration using explicit time stepping (forward Euler)
for n in range(nt):
    # Compute spatial derivatives using central differences with periodic BC using np.roll.
    u_x = (np.roll(u, -1) - np.roll(u, 1)) / (2 * dx)
    u_xx = (np.roll(u, -1) - 2*u + np.roll(u, 1)) / (dx**2)
    
    # Update u (u_t = - u u_x + nu u_xx)
    u = u + dt * (- u * u_x + nu * u_xx)

# Save the final solution as a 1D NumPy array in a file named 'u.npy'
np.save("u.npy", u)
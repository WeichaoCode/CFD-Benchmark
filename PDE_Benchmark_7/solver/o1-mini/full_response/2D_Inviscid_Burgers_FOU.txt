```python
import numpy as np
import matplotlib.pyplot as plt

# Computational domain
Lx = 2.0
Ly = 2.0
nx = 151
ny = 151
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)
dx = Lx / (nx - 1)
dy = Ly / (ny - 1)

X, Y = np.meshgrid(x, y, indexing='ij')

# Initial condition: u and v are 1 everywhere
u = np.ones((nx, ny))
v = np.ones((nx, ny))

# Set u and v to 2 in the region 0.5 <= x <= 1 and 0.5 <= y <= 1
mask = (X >= 0.5) & (X <= 1.0) & (Y >= 0.5) & (Y <= 1.0)
u[mask] = 2.0
v[mask] = 2.0

# Time-stepping parameters
nt = 300
sigma = 0.2
dt = sigma * min(dx, dy) / 2

# Time-stepping loop
for n in range(nt):
    u_new = u.copy()
    v_new = v.copy()
    
    # Compute interior points using first-order upwind scheme
    u_new[1:, 1:] = u[1:, 1:] - dt * (
        u[1:, 1:] * (u[1:, 1:] - u[:-1, 1:]) / dx +
        v[1:, 1:] * (u[1:, 1:] - u[1:, :-1]) / dy
    )
    
    v_new[1:, 1:] = v[1:, 1:] - dt * (
        u[1:, 1:] * (v[1:, 1:] - v[:-1, 1:]) / dx +
        v[1:, 1:] * (v[1:, 1:] - v[1:, :-1]) / dy
    )
    
    # Apply Dirichlet boundary conditions: u and v are 1 on all boundaries
    u_new[0, :] = 1.0
    u_new[-1, :] = 1.0
    u_new[:, 0] = 1.0
    u_new[:, -1] = 1.0
    
    v_new[0, :] = 1.0
    v_new[-1, :] = 1.0
    v_new[:, 0] = 1.0
    v_new[:, -1] = 1.0
    
    # Update u and v for the next time step
    u, v = u_new, v_new

# Visualization of the final velocity field using quiver plot
plt.figure(figsize=(8, 6))
skip = 5  # to reduce the number of arrows in the quiver plot for better visibility
plt.quiver(X[::skip, ::skip], Y[::skip, ::skip],
           u[::skip, ::skip], v[::skip, ::skip],
           pivot='mid', color='r', scale=50)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Velocity Field at Final Time Step')
plt.grid()
plt.show()

# Save the final velocity fields to .npy files
np.save('u_final.npy', u)
np.save('v_final.npy', v)
```
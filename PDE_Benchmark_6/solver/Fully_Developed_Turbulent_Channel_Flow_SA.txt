Here is a Python code that implements the solution:

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

# Constants
mu = 1.0e-5  # molecular viscosity
rho = 1.0  # density
y_max = 1.0  # channel height
n = 100  # number of grid points
dy = y_max / (n - 1)  # grid resolution

# Turbulence model constants
cv1 = 7.1
cb1 = 0.1355
cb2 = 0.622
cb3 = 2.0 / 3.0
kappa = 0.41
cw1 = cb1 / kappa**2 + (1.0 + cb2) / cb3

# Grid
y = np.linspace(0, y_max, n)

# Initialize tilde_nu and u
tilde_nu = np.zeros(n)
u = np.zeros(n)

# Iteration parameters
max_iter = 1000
tol = 1e-6

# Solve for tilde_nu and u
for iter in range(max_iter):
    # Compute eddy viscosity
    chi = tilde_nu / mu
    fv1 = chi**3 / (chi**3 + cv1**3)
    mu_t = rho * tilde_nu * fv1
    mu_eff = mu + mu_t

    # Discretize the RANS equation
    a = mu_eff[:-2] / dy**2
    b = -2.0 * mu_eff[1:-1] / dy**2
    c = mu_eff[2:] / dy**2
    A = diags([a, b, c], [-1, 0, 1], shape=(n-2, n-2)).tocsc()
    rhs = -np.ones(n-2)

    # Solve the linear system
    u_new = np.zeros(n)
    u_new[1:-1] = spsolve(A, rhs)

    # Check convergence
    if np.linalg.norm(u_new - u) < tol:
        break

    # Update tilde_nu and u
    tilde_nu = mu_t / rho
    u = u_new

# Plot the velocity profile
plt.figure()
plt.plot(u, y)
plt.xlabel('Velocity')
plt.ylabel('y')
plt.title('Velocity profile in a turbulent channel flow')
plt.grid(True)
plt.show()

# Save the velocity profile
np.save('velocity_profile.npy', u)
```

This code first initializes the grid and the variables. It then enters a loop where it computes the eddy viscosity using the Spalart-Allmaras model, discretizes the RANS equation using finite differences, and solves the resulting linear system. The loop continues until the solution converges. Finally, the code plots the velocity profile and saves it in a `.npy` file.
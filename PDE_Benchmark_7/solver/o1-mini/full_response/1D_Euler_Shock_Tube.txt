```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
L = 2.0                      # Tube length
N_x = 81                     # Number of spatial points
CFL = 1.0                    # CFL number
T = 0.25                     # Total simulation time
gamma = 1.4                  # Ratio of specific heats

# Spatial grid
x = np.linspace(-1, 1, N_x)
dx = x[1] - x[0]

# Initial Conditions
rho = np.where(x < 0, 1.0, 0.125)
u = np.zeros(N_x)
p = np.where(x < 0, 1.0, 0.1)

# Compute Total Energy
E = p / ((gamma - 1) * rho) + 0.5 * u**2

# Conservative Variables U = [rho, rho*u, rho*E]
U = np.vstack((rho, rho * u, rho * E))

def compute_flux(U):
    """Compute the flux vector F from conservative variables U."""
    rho = U[0]
    u = U[1] / rho
    E = U[2] / rho
    p = (gamma - 1) * rho * (E - 0.5 * u**2)
    F = np.zeros_like(U)
    F[0] = rho * u
    F[1] = rho * u**2 + p
    F[2] = u * (rho * E + p)
    return F

def apply_reflective_boundary(U):
    """Apply reflective boundary conditions."""
    # Left boundary
    U[:,0] = U[:,1]
    U[1,0] = -U[1,1]
    # Right boundary
    U[:,-1] = U[:,-2]
    U[1,-1] = -U[1,-2]
    return U

# Time integration
t = 0.0
while t < T:
    # Compute primitive variables
    rho = U[0]
    u = U[1] / rho
    E = U[2] / rho
    p = (gamma - 1) * rho * (E - 0.5 * u**2)
    
    # Compute speed of sound
    c = np.sqrt(gamma * p / rho)
    
    # Compute time step based on CFL condition
    max_speed = np.max(np.abs(u) + c)
    dt = CFL * dx / max_speed
    if t + dt > T:
        dt = T - t
    
    # Compute fluxes
    F = compute_flux(U)
    
    # Predictor step
    U_star = np.copy(U)
    U_star[:, :-1] = U[:, :-1] - (dt/dx) * (F[:, 1:] - F[:, :-1])
    
    # Apply boundary conditions to U_star
    U_star = apply_reflective_boundary(U_star)
    
    # Compute fluxes from U_star
    F_star = compute_flux(U_star)
    
    # Corrector step
    U_new = np.copy(U)
    U_new[:,1:] = 0.5 * (U[:,1:] + U_star[:,1:] - (dt/dx) * (F_star[:,1:] - F_star[:, :-1]))
    
    # Apply boundary conditions to U_new
    U_new = apply_reflective_boundary(U_new)
    
    # Update U and time
    U = U_new
    t += dt

# Final primitive variables
rho_final = U[0]
u_final = U[1] / rho_final
E_final = U[2] / rho_final
p_final = (gamma - 1) * rho_final * (E_final - 0.5 * u_final**2)

# Save the results
np.save('rho_final.npy', rho_final)
np.save('u_final.npy', u_final)
np.save('p_final.npy', p_final)
np.save('U_final.npy', U)
np.save('F_final.npy', compute_flux(U))

# Visualization (Optional)
plt.figure(figsize=(15,4))

plt.subplot(1,3,1)
plt.plot(x, rho_final, label='Density')
plt.xlabel('x')
plt.ylabel('Density')
plt.title('Density at t = {:.2f}'.format(T))
plt.grid()
plt.legend()

plt.subplot(1,3,2)
plt.plot(x, u_final, label='Velocity', color='g')
plt.xlabel('x')
plt.ylabel('Velocity')
plt.title('Velocity at t = {:.2f}'.format(T))
plt.grid()
plt.legend()

plt.subplot(1,3,3)
plt.plot(x, p_final, label='Pressure', color='r')
plt.xlabel('x')
plt.ylabel('Pressure')
plt.title('Pressure at t = {:.2f}'.format(T))
plt.grid()
plt.legend()

plt.tight_layout()
plt.show()
```
```python
import numpy as np

# Parameters
c = 1.0
epsilon_values = [0, 5e-4]
x_start, x_end = -5, 5
Nx = 101
dx = (x_end - x_start) / (Nx - 1)
x = np.linspace(x_start, x_end, Nx)
dt = 0.8 * dx / c  # CFL condition
T_final = 2.0  # Final time
Nt = int(T_final / dt)

# Initial condition
u_initial = np.exp(-x**2)

# Save values
save_values = ['u_epsilon_0', 'u_epsilon_5e-4']

# Function to compute spatial derivatives
def compute_derivatives(u, dx, epsilon):
    # Periodic boundary conditions
    u_x = np.roll(u, -1) - np.roll(u, 1)
    u_xx = np.roll(u, -1) - 2 * u + np.roll(u, 1)
    return -c * u_x / (2 * dx) + epsilon * u_xx / (dx**2)

# Time integration using Adams-Bashforth method
for epsilon, save_name in zip(epsilon_values, save_values):
    u = u_initial.copy()
    # First step using Explicit Euler
    u_new = u + dt * compute_derivatives(u, dx, epsilon)
    
    for _ in range(1, Nt):
        # Compute derivatives
        du_dt = compute_derivatives(u, dx, epsilon)
        du_dt_new = compute_derivatives(u_new, dx, epsilon)
        
        # Adams-Bashforth step
        u_next = u_new + dt * (1.5 * du_dt_new - 0.5 * du_dt)
        
        # Update for next step
        u = u_new
        u_new = u_next
    
    # Save the final solution
    np.save(f'{save_name}.npy', u_new)
```
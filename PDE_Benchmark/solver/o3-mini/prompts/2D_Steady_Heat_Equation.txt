#!/usr/bin/env python3
import numpy as np

# Domain parameters
width = 5.0
height = 4.0
Nx = 51  # number of grid points in x-direction
Ny = 41  # number of grid points in y-direction
dx = width / (Nx - 1)
dy = height / (Ny - 1)

# Create the grid
x = np.linspace(0, width, Nx)
y = np.linspace(0, height, Ny)

# Initialize temperature field T, note that T[j, i] corresponds to (x[i], y[j])
T = np.zeros((Ny, Nx))

# Set Dirichlet boundary conditions
T[:, 0]   = 10.0   # Left boundary: x = 0
T[:, -1]  = 40.0   # Right boundary: x = 5
T[-1, :]  = 0.0    # Top boundary: y = 4
T[0, :]   = 20.0   # Bottom boundary: y = 0

# Parameters for the iterative method
tolerance = 1e-6
max_iter = 10000

# Precompute constant
dx2 = dx * dx
dy2 = dy * dy
denom = 2 * (dx2 + dy2)

for iteration in range(max_iter):
    T_old = T.copy()
    
    # Update interior points using finite difference (Jacobi method)
    # Loop through interior nodes
    for j in range(1, Ny-1):
        for i in range(1, Nx-1):
            T[j, i] = ((T_old[j, i+1] + T_old[j, i-1]) * dy2 + (T_old[j+1, i] + T_old[j-1, i]) * dx2) / denom
    
    # Compute maximum error
    err = np.max(np.abs(T - T_old))
    if err < tolerance:
        break

# Save the final solution as a .npy file with the variable name "T"
np.save('T.npy', T)
```python
import numpy as np

def solve_pde():
    # Parameters
    nx = 41
    ny = 41
    nt = 100
    dx = 2 / (nx - 1)
    dy = 2 / (ny - 1)
    dt = 0.001
    
    # Initialize arrays
    u = np.ones((ny, nx))
    v = np.ones((ny, nx))

    # Initial conditions
    for i in range(ny):
        for j in range(nx):
            x = j * dx
            y = i * dy
            if 0.5 <= x <= 1 and 0.5 <= y <= 1:
                u[i, j] = 2
                v[i, j] = 2

    # Boundary conditions (applied at each time step)
    u[0, :] = 1
    u[-1, :] = 1
    u[:, 0] = 1
    u[:, -1] = 1
    
    v[0, :] = 1
    v[-1, :] = 1
    v[:, 0] = 1
    v[:, -1] = 1

    # Time loop
    for n in range(nt):
        un = u.copy()
        vn = v.copy()
        
        for i in range(1, ny - 1):
            for j in range(1, nx - 1):
                u[i, j] = un[i, j] - dt * (un[i, j] * (un[i, j] - un[i, j-1]) / dx + vn[i, j] * (un[i, j] - un[i-1, j]) / dy)
                v[i, j] = vn[i, j] - dt * (un[i, j] * (vn[i, j] - vn[i, j-1]) / dx + vn[i, j] * (vn[i, j] - vn[i-1, j]) / dy)

        # Boundary conditions (applied at each time step)
        u[0, :] = 1
        u[-1, :] = 1
        u[:, 0] = 1
        u[:, -1] = 1
        
        v[0, :] = 1
        v[-1, :] = 1
        v[:, 0] = 1
        v[:, -1] = 1
        
    # Save the final solution
    np.save('u.npy', u)
    np.save('v.npy', v)

solve_pde()
```
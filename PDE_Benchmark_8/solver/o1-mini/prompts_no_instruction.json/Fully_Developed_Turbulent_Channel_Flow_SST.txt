```python
import numpy as np

# Parameters
H = 2.0
n = 100
max_iter = 10000
tolerance = 1e-6
epsilon = 1e-8  # Small number to prevent division by zero

# Physical constants (example values, should be set appropriately)
rho = 1.225  # kg/m^3
mu = 1.81e-5  # Pa.s
beta_star = 0.09
beta = 0.0828
sigma_k = 1.0
C_D = 0.09
F1 = 0.92
F2 = 1.0
a1 = 7.1

# Create non-uniform mesh clustered near the walls
xi = np.linspace(0, 1, n)
stretch_factor = 3
y = H * (xi ** stretch_factor)
dy = np.diff(y)

# Initialize variables with small positive values to avoid division by zero
k = np.full(n, 1e-6)
omega = np.full(n, 1.0)

# Boundary conditions (assuming non-zero values at walls)
k_left = 1e-6
k_right = 1e-6
omega_left = 1.0
omega_right = 1.0

k[0] = k_left
k[-1] = k_right
omega[0] = omega_left
omega[-1] = omega_right

# Strain rate tensor S (assumed constant for fully developed flow)
S = np.ones(n) * 1.0  # Example value, should be defined based on velocity gradient

# Iterative solver for steady-state
for iteration in range(max_iter):
    k_old = k.copy()
    omega_old = omega.copy()
    
    # Compute mu_t with safety to prevent division by zero
    inv_omega = 1.0 / (omega + epsilon)
    mu_t = rho * k * np.minimum(inv_omega, a1 / (np.abs(S) * F2))
    
    # Update k
    for i in range(1, n-1):
        dy_plus = y[i+1] - y[i]
        dy_minus = y[i] - y[i-1]
        a_plus = (mu + mu_t[i] / sigma_k) / dy_plus
        a_minus = (mu + mu_t[i] / sigma_k) / dy_minus
        a_p = a_plus + a_minus
        P_k = mu_t[i] * S[i]**2  # Turbulent production term
        k[i] = (P_k + a_plus * k[i+1] + a_minus * k[i-1]) / (a_p + beta_star * rho * omega[i])
    
    # Apply boundary conditions for k
    k[0] = k_left
    k[-1] = k_right
    
    # Compute mu_t again after updating k
    inv_omega = 1.0 / (omega + epsilon)
    mu_t = rho * k * np.minimum(inv_omega, a1 / (np.abs(S) * F2))
    
    # Update omega
    for i in range(1, n-1):
        dy_plus = y[i+1] - y[i]
        dy_minus = y[i] - y[i-1]
        a_plus = (mu + mu_t[i] * omega[i]) / dy_plus
        a_minus = (mu + mu_t[i] * omega[i]) / dy_minus
        a_p = a_plus + a_minus
        P_k = mu_t[i] * S[i]**2  # Turbulent production term
        omega[i] = (
            (rho * P_k) 
            + a_plus * omega[i+1] 
            + a_minus * omega[i-1] 
            + (1 - F1) * C_D * k[i] * omega[i]
        ) / (a_p + beta * omega[i])
        
    # Apply boundary conditions for omega
    omega[0] = omega_left
    omega[-1] = omega_right
    
    # Check convergence
    delta_k = np.max(np.abs(k - k_old))
    delta_omega = np.max(np.abs(omega - omega_old))
    if delta_k < tolerance and delta_omega < tolerance:
        print(f'Converged in {iteration+1} iterations.')
        break
else:
    print('Did not converge within the maximum number of iterations.')

# Save the final solutions
np.save('k.npy', k)
np.save('omega.npy', omega)
```
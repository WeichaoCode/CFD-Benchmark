Below is the Python code to solve the given partial differential equation (PDE) problem using the specified numerical method. The code initializes the velocity fields, applies the finite difference scheme, and saves the final solution to `.npy` files.

```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
nx, ny = 41, 41
nt = 120
nu = 0.01
sigma = 0.0009
dx = dy = 2 / (nx - 1)
dt = sigma * dx * dy / nu

# Initialize velocity fields
u = np.ones((ny, nx))
v = np.ones((ny, nx))

# Initial condition: u = v = 2 for 0.5 <= x, y <= 1
u[int(0.5 / dy):int(1 / dy + 1), int(0.5 / dx):int(1 / dx + 1)] = 2
v[int(0.5 / dy):int(1 / dy + 1), int(0.5 / dx):int(1 / dx + 1)] = 2

# Time-stepping loop
for n in range(nt):
    un = u.copy()
    vn = v.copy()
    
    # Update u and v using central differences and Explicit Euler
    u[1:-1, 1:-1] = (un[1:-1, 1:-1] -
                     dt / dx * un[1:-1, 1:-1] * (un[1:-1, 1:-1] - un[1:-1, :-2]) -
                     dt / dy * vn[1:-1, 1:-1] * (un[1:-1, 1:-1] - un[:-2, 1:-1]) +
                     nu * dt / dx**2 * (un[1:-1, 2:] - 2 * un[1:-1, 1:-1] + un[1:-1, :-2]) +
                     nu * dt / dy**2 * (un[2:, 1:-1] - 2 * un[1:-1, 1:-1] + un[:-2, 1:-1]))

    v[1:-1, 1:-1] = (vn[1:-1, 1:-1] -
                     dt / dx * un[1:-1, 1:-1] * (vn[1:-1, 1:-1] - vn[1:-1, :-2]) -
                     dt / dy * vn[1:-1, 1:-1] * (vn[1:-1, 1:-1] - vn[:-2, 1:-1]) +
                     nu * dt / dx**2 * (vn[1:-1, 2:] - 2 * vn[1:-1, 1:-1] + vn[1:-1, :-2]) +
                     nu * dt / dy**2 * (vn[2:, 1:-1] - 2 * vn[1:-1, 1:-1] + vn[:-2, 1:-1]))

    # Apply Dirichlet boundary conditions
    u[0, :] = 1
    u[-1, :] = 1
    u[:, 0] = 1
    u[:, -1] = 1

    v[0, :] = 1
    v[-1, :] = 1
    v[:, 0] = 1
    v[:, -1] = 1

# Save final solution to .npy files
np.save('u_final.npy', u)
np.save('v_final.npy', v)

# Visualization
x = np.linspace(0, 2, nx)
y = np.linspace(0, 2, ny)
X, Y = np.meshgrid(x, y)

fig = plt.figure(figsize=(12, 6))
ax = fig.add_subplot(121, projection='3d')
ax.plot_surface(X, Y, u, cmap='viridis')
ax.set_title('Velocity field u')
ax.set_xlabel('x')
ax.set_ylabel('y')

ax = fig.add_subplot(122, projection='3d')
ax.plot_surface(X, Y, v, cmap='viridis')
ax.set_title('Velocity field v')
ax.set_xlabel('x')
ax.set_ylabel('y')

plt.tight_layout()
plt.show()
```

This code initializes the velocity fields `u` and `v` with the specified initial conditions, applies the finite difference scheme for 120 time steps, and enforces the Dirichlet boundary conditions at each step. The final velocity fields are saved as `.npy` files, and a 3D surface plot is generated to visualize the results.
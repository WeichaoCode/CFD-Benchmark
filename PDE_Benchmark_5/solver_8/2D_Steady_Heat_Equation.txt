Sure, here's a way you can solve it using Numpy and Matplotlib in Python:

```python
import numpy as np
import matplotlib.pyplot as plt

# params
nx, ny = 50, 50  # number of grid points in x/y direction
dx, dy = 5 / (nx - 1), 4 / (ny - 1) # distance between two grid points
max_iter = 1_000  # maximum number of iterations
conv_threshold = 1e-4  # convergence threshold

# Initialise the grid with zeros
T = np.zeros((nx, ny))

# Set boundary conditions
T[:, 0] = 10  # AB
T[:, -1] = 40  # EF
T[0, :] = 0  # CD
T[-1, :] = 20  # GH

# Iteratively compute
for _ in range(max_iter):
    T_old = T.copy()
    T[1:-1, 1:-1] = (dy**2 * (T_old[2:, 1:-1] + T_old[:-2, 1:-1]) + dx**2 * (T_old[1:-1, 2:] + T_old[1:-1, :-2])) / (2 * (dx**2 + dy**2))
    
    if np.abs(T - T_old).max() < conv_threshold:
        break

# plot
x = np.linspace(0, 5, num=nx)
y = np.linspace(0, 4, num=ny)
X, Y = np.meshgrid(x, y, indexing='ij')

plt.contourf(X, Y, T, cmap='hot')
plt.title("Temperature Distribution in a Rectangle (Units in Â°C)")
plt.colorbar(label='Temperature')
plt.show()
```
Here we're using a relaxation method: we start with a guess, i.e. the grid initialized at zero temperature, then repeat the calculations to get an updated temperature at each point. We do this iteratively until we get a result that's good enough, i.e. until the difference between two iterations falls below a predefined threshold.
#!/usr/bin/env python3
import numpy as np

# Physical parameters
gamma = 1.4

# Domain parameters
x_min = -1.0
x_max = 1.0
Nx = 400            # number of cells for interior
ng = 2              # number of ghost cells (1 on each side)
N = Nx + 2          # total number of cells
dx = (x_max - x_min) / Nx
x = np.linspace(x_min - dx, x_max + dx, N)  # including ghost cells

# Time parameters
t_final = 0.25
CFL = 0.5

# Conservative variable indices
# U[0] -> density, U[1] -> momentum, U[2] -> energy

# Initialize conserved variables array: shape (N, 3)
U = np.zeros((N, 3))

# Initial conditions for interior cells (indices 1 to N-2)
for i in range(1, N-1):
    if x[i] < 0.0:
        rho = 1.0
        u   = 0.0
        p   = 1.0
    else:
        rho = 0.125
        u   = 0.0
        p   = 0.1
    E = p/((gamma - 1)*rho) + 0.5*u**2
    U[i, 0] = rho
    U[i, 1] = rho*u
    U[i, 2] = rho*E

def compute_flux(U):
    # U: shape (N,3)
    # returns flux array of shape (N,3)
    flux = np.zeros_like(U)
    rho = U[:,0]
    rhou = U[:,1]
    rhoE = U[:,2]
    u = np.where(rho != 0, rhou / rho, 0.0)
    E = np.where(rho != 0, rhoE / rho, 0.0)
    p = (gamma - 1)*(rho*E - 0.5*rho*u**2)
    flux[:, 0] = rhou
    flux[:, 1] = rhou*u + p
    flux[:, 2] = u*(rhoE + p)
    return flux

def max_wave_speed(U):
    # Compute maximum wave speed for given state U (excluding ghosts)
    rho = U[1:-1,0]
    u = U[1:-1,1] / rho
    E = U[1:-1,2] / rho
    p = (gamma - 1)*(rho*E - 0.5*rho*u**2)
    c = np.sqrt(np.abs(gamma * p / rho))
    return np.max(np.abs(u) + c)

def apply_boundary_conditions(U):
    # Reflective BC
    # Left boundary: cell 0 is ghost; reflect interior cell 1.
    U[0,0] = U[1,0]        # density remains same
    U[0,1] = -U[1,1]       # momentum reversed sign
    U[0,2] = U[1,2]        # energy remains same
    # Right boundary: cell N-1 is ghost; reflect interior cell N-2.
    U[-1,0] = U[-2,0]
    U[-1,1] = -U[-2,1]
    U[-1,2] = U[-2,2]

# Time stepping loop (explicit finite volume method with Rusanov flux)
t = 0.0
while t < t_final:
    apply_boundary_conditions(U)
    
    # Compute time step from CFL condition
    smax = max_wave_speed(U)
    dt = CFL * dx / smax
    if t + dt > t_final:
        dt = t_final - t
    
    # Compute fluxes at interfaces using Rusanov (local Lax-Friedrichs) flux
    flux = compute_flux(U)
    F_interface = np.zeros((N-1, 3))
    for i in range(N-1):
        # Compute maximum signal speed at interface between U[i] and U[i+1]
        # Compute speeds for left state
        rho_L = U[i,0]
        u_L = U[i,1] / rho_L if rho_L != 0 else 0.0
        E_L = U[i,2] / rho_L if rho_L != 0 else 0.0
        p_L = (gamma - 1)*(rho_L*E_L - 0.5*rho_L*u_L**2)
        c_L = np.sqrt(np.abs(gamma * p_L / rho_L)) if rho_L != 0 else 0.0
        # Right state
        rho_R = U[i+1,0]
        u_R = U[i+1,1] / rho_R if rho_R != 0 else 0.0
        E_R = U[i+1,2] / rho_R if rho_R != 0 else 0.0
        p_R = (gamma - 1)*(rho_R*E_R - 0.5*rho_R*u_R**2)
        c_R = np.sqrt(np.abs(gamma * p_R / rho_R)) if rho_R != 0 else 0.0
        s_max = max(np.abs(u_L) + c_L, np.abs(u_R) + c_R)
        # Rusanov flux
        F_interface[i] = 0.5 * (flux[i] + flux[i+1]) - 0.5 * s_max * (U[i+1] - U[i])
    
    # Update U in interior cells
    # U_new[i] = U_old[i] - dt/dx*(F_interface[i] - F_interface[i-1])
    U_new = U.copy()
    for i in range(1, N-1):
        U_new[i] = U[i] - dt/dx * (F_interface[i] - F_interface[i-1])
    
    U = U_new
    t += dt

# Final solution in interior cells (1D arrays)
rho_final = U[1:-1, 0]
rhou_final = U[1:-1, 1]
rhoE_final = U[1:-1, 2]

# Save the final solution for each variable
np.save("rho.npy", rho_final)
np.save("rhou.npy", rhou_final)
np.save("rhoE.npy", rhoE_final)
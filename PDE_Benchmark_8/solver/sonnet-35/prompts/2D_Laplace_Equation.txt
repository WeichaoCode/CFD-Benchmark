```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla

# Domain parameters
Lx, Ly = 2.0, 1.0
nx, ny = 100, 50  # Grid resolution
dx = Lx / (nx - 1)
dy = Ly / (ny - 1)

# Create grid
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)
X, Y = np.meshgrid(x, y)

# Finite difference matrix assembly
def assemble_matrix(nx, ny, dx, dy):
    # Create sparse matrix for Laplacian operator
    n = nx * ny
    row = []
    col = []
    data = []
    
    for j in range(ny):
        for i in range(nx):
            k = j * nx + i
            
            # Diagonal term
            row.append(k)
            col.append(k)
            data.append(-2 * (1/dx**2 + 1/dy**2))
            
            # X-direction terms
            if i > 0:
                row.append(k)
                col.append(k-1)
                data.append(1/dx**2)
            
            if i < nx - 1:
                row.append(k)
                col.append(k+1)
                data.append(1/dx**2)
            
            # Y-direction terms
            if j > 0:
                row.append(k)
                col.append(k-nx)
                data.append(1/dy**2)
            
            if j < ny - 1:
                row.append(k)
                col.append(k+nx)
                data.append(1/dy**2)
    
    # Create sparse matrix
    A = sp.csr_matrix((data, (row, col)), shape=(n, n))
    return A

# Boundary condition handling
def apply_boundary_conditions(A, b, nx, ny, dx, dy, x, y):
    # Convert to LIL format for easier modification
    A = A.tolil()
    
    # Left boundary (x = 0): p = 0
    for j in range(ny):
        idx = j * nx
        A[idx, :] = 0
        A[idx, idx] = 1
        b[idx] = 0
    
    # Right boundary (x = 2): p = y
    for j in range(ny):
        idx = j * nx + (nx - 1)
        A[idx, :] = 0
        A[idx, idx] = 1
        b[idx] = y[j]
    
    # Convert back to CSR for solving
    return A.tocsr(), b

# Solve Poisson equation
A = assemble_matrix(nx, ny, dx, dy)
b = np.zeros(nx * ny)

# Apply boundary conditions
A, b = apply_boundary_conditions(A, b, nx, ny, dx, dy, x, y)

# Solve linear system
p = spla.spsolve(A, b).reshape((ny, nx))

# Save solution
np.save('p.npy', p)
```

Key changes:
1. Completely rewrote matrix assembly to use CSR matrix construction
2. Modified boundary condition application to:
   - Use LIL format for easier modification
   - Explicitly pass `x` and `y` arrays to the boundary condition function
3. Simplified matrix assembly logic to directly create sparse matrix
4. Ensures boundary conditions are applied correctly without item assignment issues

This approach should resolve the previous TypeError and correctly solve the 2D Laplace equation with the specified boundary conditions.
```python
import numpy as np
from scipy.linalg import solve

# Parameters
H = 2.0
n = 100
rho = 1.0
mu = 1.0
sigma_k = 1.0
sigma_omega = 1.0
beta = 0.09
beta_star = 0.075
a1 = 0.31
F1 = 0.4
F2 = 0.5
C_D = 0.6
max_iter = 1000
tol = 1e-6
relaxation = 0.3

# Mesh generation with clustering near walls
y_lin = np.linspace(0, 1, n)
y = H * (np.tanh(3 * (y_lin - 0.5)) / np.tanh(1.5) + 1) / 2
dy = np.diff(y)
dy = np.append(dy, dy[-1])

# Initialize k and omega with small positive values
k = 1e-6 * np.ones(n)
omega = 1e-6 * np.ones(n)

# Boundary conditions for velocity (Dirichlet)
u_wall = 0.0
u_center = 1.0
u = np.linspace(u_wall, u_center, n)

# Iterative solver
for it in range(max_iter):
    k_old = k.copy()
    omega_old = omega.copy()

    # Compute strain rate |S|
    du_dy = np.gradient(u, y)
    S = np.abs(du_dy) + 1e-8  # Avoid division by zero

    # Compute mu_t
    mu_t_1 = 1.0 / omega
    mu_t_2 = a1 / (S * F2)
    mu_t = rho * k * np.minimum(mu_t_1, mu_t_2 + 1e-8)

    # Assemble equations for k
    Pk = mu_t * S**2
    A_k = np.zeros((n, n))
    b_k = beta_star * rho * k * omega - Pk

    for i in range(1, n-1):
        A_k[i, i-1] = (mu + mu_t[i]) / dy[i-1]**2
        A_k[i, i] = -2 * (mu + mu_t[i]) * (1 / dy[i-1]**2 + 1 / dy[i]**2)
        A_k[i, i+1] = (mu + mu_t[i]) / dy[i]**2

    # Boundary conditions for k
    A_k[0, 0] = 1
    b_k[0] = 0
    A_k[-1, -1] = 1
    b_k[-1] = 0

    # Solve for k
    k_new = solve(A_k, b_k)
    k = relaxation * k_new + (1 - relaxation) * k_old

    # Assemble equations for omega
    P_omega = (rho * Pk) / (mu_t + 1e-8)
    A_omega = np.zeros((n, n))
    b_omega = beta * omega**2 - P_omega - (1 - F1) * C_D * k * omega

    for i in range(1, n-1):
        A_omega[i, i-1] = (mu + mu_t[i] * omega[i]) / dy[i-1]**2
        A_omega[i, i] = -2 * (mu + mu_t[i] * omega[i]) * (1 / dy[i-1]**2 + 1 / dy[i]**2) - beta * omega[i]
        A_omega[i, i+1] = (mu + mu_t[i] * omega[i]) / dy[i]**2

    # Boundary conditions for omega
    A_omega[0, 0] = 1
    b_omega[0] = 0
    A_omega[-1, -1] = 1
    b_omega[-1] = 0

    # Solve for omega
    omega_new = solve(A_omega, b_omega)
    omega = relaxation * omega_new + (1 - relaxation) * omega_old

    # Check convergence
    if np.linalg.norm(k - k_old, ord=2) < tol and np.linalg.norm(omega - omega_old, ord=2) < tol:
        break

# Save the final solutions
np.save('k.npy', k)
np.save('omega.npy', omega)
np.save('u.npy', u)
```
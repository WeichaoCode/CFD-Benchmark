```python
import numpy as np
import matplotlib.pyplot as plt

# Problem Parameters
Lx, Ly = 2, 2  # Domain size
T = 0.32       # Total simulation time
nx, ny = 100, 100  # Grid points
nt = 200       # Time steps

# Grid generation
dx = Lx / (nx - 1)
dy = Ly / (ny - 1)
dt = T / (nt - 1)

x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)

# Initial Conditions
u = np.ones((ny, nx))
v = np.ones((ny, nx))

# Modify initial condition in specified region
mask = ((x >= 0.5) & (x <= 1))[:, np.newaxis] & ((y >= 0.5) & (y <= 1))
u[mask] = 2
v[mask] = 2

# Boundary Conditions
u[0,:] = u[-1,:] = u[:,0] = u[:,-1] = 1
v[0,:] = v[-1,:] = v[:,0] = v[:,-1] = 1

# Lax-Wendroff Method for 2D Advection
def lax_wendroff_2d(u, v, dx, dy, dt):
    u_new = np.copy(u)
    v_new = np.copy(v)
    
    # Interior points
    for i in range(1, ny-1):
        for j in range(1, nx-1):
            # u-velocity update
            u_fx_plus = 0.5 * (u[i,j+1] + u[i,j]) - 0.5 * dt/dx * (u[i,j+1]**2 - u[i,j-1]**2)
            u_fx_minus = 0.5 * (u[i,j] + u[i,j-1]) - 0.5 * dt/dx * (u[i,j]**2 - u[i,j-1]**2)
            
            u_fy_plus = 0.5 * (u[i+1,j] + u[i,j]) - 0.5 * dt/dy * (v[i,j] * u[i+1,j] - v[i-1,j] * u[i-1,j])
            u_fy_minus = 0.5 * (u[i,j] + u[i-1,j]) - 0.5 * dt/dy * (v[i,j] * u[i,j] - v[i-1,j] * u[i-1,j])
            
            u_new[i,j] = u[i,j] - dt/dx * (u_fx_plus - u_fx_minus) - dt/dy * (u_fy_plus - u_fy_minus)
            
            # v-velocity update
            v_fx_plus = 0.5 * (v[i,j+1] + v[i,j]) - 0.5 * dt/dx * (u[i,j] * v[i,j+1] - u[i,j-1] * v[i,j-1])
            v_fx_minus = 0.5 * (v[i,j] + v[i,j-1]) - 0.5 * dt/dx * (u[i,j] * v[i,j] - u[i,j-1] * v[i,j-1])
            
            v_fy_plus = 0.5 * (v[i+1,j] + v[i,j]) - 0.5 * dt/dy * (v[i+1,j]**2 - v[i-1,j]**2)
            v_fy_minus = 0.5 * (v[i,j] + v[i-1,j]) - 0.5 * dt/dy * (v[i,j]**2 - v[i-1,j]**2)
            
            v_new[i,j] = v[i,j] - dt/dx * (v_fx_plus - v_fx_minus) - dt/dy * (v_fy_plus - v_fy_minus)
    
    # Enforce boundary conditions
    u_new[0,:] = u_new[-1,:] = u_new[:,0] = u_new[:,-1] = 1
    v_new[0,:] = v_new[-1,:] = v_new[:,0] = v_new[:,-1] = 1
    
    return u_new, v_new

# Time integration
for _ in range(nt-1):
    u, v = lax_wendroff_2d(u, v, dx, dy, dt)

# Save variables
np.save('u.npy', u)
np.save('v.npy', v)
```
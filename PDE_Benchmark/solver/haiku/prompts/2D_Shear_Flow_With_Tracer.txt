```python
import numpy as np
from scipy.fft import fft2, ifft2, fftfreq

# Grid parameters
Nx = 64
Nz = 128
Lx = 1.0
Lz = 2.0
dx = Lx/Nx
dz = Lz/Nz
x = np.linspace(0, Lx-dx, Nx)
z = np.linspace(-1, 1-dz, Nz)
X, Z = np.meshgrid(x, z)

# Time parameters
dt = 0.0001  # Further reduced timestep
t_final = 20.0
Nt = int(t_final/dt)

# Physical parameters
nu = 1/(5e4)
D = nu/1

# Wavenumbers
kx = 2*np.pi*fftfreq(Nx, dx)
kz = 2*np.pi*fftfreq(Nz, dz)
KX, KZ = np.meshgrid(kx, kz)
K2 = KX**2 + KZ**2

# Initial conditions
u = 0.5*(1 + np.tanh((Z-0.5)/0.1) - np.tanh((Z+0.5)/0.1))
w = 0.01*np.sin(2*np.pi*X)*np.exp(-(Z-0.5)**2/0.1**2) + 0.01*np.sin(2*np.pi*X)*np.exp(-(Z+0.5)**2/0.1**2)
s = u.copy()

# FFT of initial fields
u_hat = fft2(u).astype(np.complex128)
w_hat = fft2(w).astype(np.complex128)
s_hat = fft2(s).astype(np.complex128)

# Dealiasing mask
dealias = np.ones_like(K2)
dealias[np.abs(KX) > 2/3*np.max(np.abs(kx))] = 0
dealias[np.abs(KZ) > 2/3*np.max(np.abs(kz))] = 0

# Time stepping
for n in range(Nt):
    # Real space fields
    u = np.real(ifft2(u_hat)).astype(np.float64)
    w = np.real(ifft2(w_hat)).astype(np.float64)
    
    # Compute derivatives
    dudx = np.real(ifft2(1j*KX*u_hat)).astype(np.float64)
    dudz = np.real(ifft2(1j*KZ*u_hat)).astype(np.float64)
    dwdx = np.real(ifft2(1j*KX*w_hat)).astype(np.float64)
    dwdz = np.real(ifft2(1j*KZ*w_hat)).astype(np.float64)
    dsdx = np.real(ifft2(1j*KX*s_hat)).astype(np.float64)
    dsdz = np.real(ifft2(1j*KZ*s_hat)).astype(np.float64)
    
    # Compute nonlinear terms
    NLu = fft2(-u*dudx - w*dudz).astype(np.complex128)
    NLw = fft2(-u*dwdx - w*dwdz).astype(np.complex128)
    NLs = fft2(-u*dsdx - w*dsdz).astype(np.complex128)
    
    # Apply dealiasing
    NLu *= dealias
    NLw *= dealias
    NLs *= dealias
    
    # Pressure projection
    div_hat = 1j*KX*u_hat + 1j*KZ*w_hat
    p_hat = div_hat/(K2 + (K2==0))
    p_hat[0,0] = 0
    
    # Update fields
    u_hat_new = (u_hat + dt*NLu - dt*1j*KX*p_hat)/(1 + dt*nu*K2)
    w_hat_new = (w_hat + dt*NLw - dt*1j*KZ*p_hat)/(1 + dt*nu*K2)
    s_hat_new = (s_hat + dt*NLs)/(1 + dt*D*K2)
    
    # Apply dealiasing and update
    u_hat = u_hat_new * dealias
    w_hat = w_hat_new * dealias
    s_hat = s_hat_new * dealias

# Get final fields
u = np.real(ifft2(u_hat))
w = np.real(ifft2(w_hat))
s = np.real(ifft2(s_hat))
p = np.real(ifft2(p_hat))

# Save final fields
np.save('u.npy', u)
np.save('w.npy', w)
np.save('p.npy', p)
np.save('s.npy', s)
```
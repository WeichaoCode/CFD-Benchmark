Below is the Python code to solve the given 2D unsteady Navier-Stokes problem using the Finite Difference Method. The code initializes the velocity and pressure fields, iterates over time steps to update these fields, and applies the specified boundary conditions. Finally, it saves the solution at the final time step in `.npy` format.

```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
nx, ny = 41, 41
nt = 10
dx = dy = 2 / (nx - 1)
dt = 0.01
rho = 1
nu = 0.1
F = 1

# Initialize fields
u = np.zeros((ny, nx))
v = np.zeros((ny, nx))
p = np.zeros((ny, nx))
b = np.zeros((ny, nx))

# Helper function to apply boundary conditions
def apply_boundary_conditions(u, v, p):
    # Periodic BCs in x-direction
    u[:, 0] = u[:, -2]
    u[:, -1] = u[:, 1]
    v[:, 0] = v[:, -2]
    v[:, -1] = v[:, 1]
    p[:, 0] = p[:, -2]
    p[:, -1] = p[:, 1]
    
    # No-slip BCs in y-direction
    u[0, :] = 0
    u[-1, :] = 0
    v[0, :] = 0
    v[-1, :] = 0
    
    # Pressure gradient BCs in y-direction
    p[0, :] = p[1, :]
    p[-1, :] = p[-2, :]

# Pressure Poisson equation solver
def pressure_poisson(p, dx, dy):
    pn = np.empty_like(p)
    for _ in range(50):  # Iterative solver
        pn = p.copy()
        p[1:-1, 1:-1] = (((pn[1:-1, 2:] + pn[1:-1, :-2]) * dy**2 +
                          (pn[2:, 1:-1] + pn[:-2, 1:-1]) * dx**2) /
                         (2 * (dx**2 + dy**2)) -
                         dx**2 * dy**2 / (2 * (dx**2 + dy**2)) *
                         b[1:-1, 1:-1])
        apply_boundary_conditions(u, v, p)
    return p

# Time-stepping loop
for n in range(nt):
    un = u.copy()
    vn = v.copy()
    
    # Build up the RHS of the pressure Poisson equation
    b[1:-1, 1:-1] = (rho * (1 / dt *
                            ((un[1:-1, 2:] - un[1:-1, :-2]) / (2 * dx) +
                             (vn[2:, 1:-1] - vn[:-2, 1:-1]) / (2 * dy)) -
                            ((un[1:-1, 2:] - un[1:-1, :-2]) / (2 * dx))**2 -
                            2 * ((un[2:, 1:-1] - un[:-2, 1:-1]) / (2 * dy) *
                                 (vn[1:-1, 2:] - vn[1:-1, :-2]) / (2 * dx)) -
                            ((vn[2:, 1:-1] - vn[:-2, 1:-1]) / (2 * dy))**2))
    
    # Solve for pressure
    p = pressure_poisson(p, dx, dy)
    
    # Update velocity fields
    u[1:-1, 1:-1] = (un[1:-1, 1:-1] -
                     un[1:-1, 1:-1] * dt / dx *
                     (un[1:-1, 1:-1] - un[1:-1, :-2]) -
                     vn[1:-1, 1:-1] * dt / dy *
                     (un[1:-1, 1:-1] - un[:-2, 1:-1]) -
                     dt / (2 * rho * dx) * (p[1:-1, 2:] - p[1:-1, :-2]) +
                     nu * (dt / dx**2 *
                           (un[1:-1, 2:] - 2 * un[1:-1, 1:-1] + un[1:-1, :-2]) +
                           dt / dy**2 *
                           (un[2:, 1:-1] - 2 * un[1:-1, 1:-1] + un[:-2, 1:-1])) +
                     F * dt)
    
    v[1:-1, 1:-1] = (vn[1:-1, 1:-1] -
                     un[1:-1, 1:-1] * dt / dx *
                     (vn[1:-1, 1:-1] - vn[1:-1, :-2]) -
                     vn[1:-1, 1:-1] * dt / dy *
                     (vn[1:-1, 1:-1] - vn[:-2, 1:-1]) -
                     dt / (2 * rho * dy) * (p[2:, 1:-1] - p[:-2, 1:-1]) +
                     nu * (dt / dx**2 *
                           (vn[1:-1, 2:] - 2 * vn[1:-1, 1:-1] + vn[1:-1, :-2]) +
                           dt / dy**2 *
                           (vn[2:, 1:-1] - 2 * vn[1:-1, 1:-1] + vn[:-2, 1:-1])))
    
    apply_boundary_conditions(u, v, p)

# Save the final solution
np.save('final_solution.npy', {'u': u, 'v': v, 'p': p})

# Visualization
X, Y = np.meshgrid(np.linspace(0, 2, nx), np.linspace(0, 2, ny))

plt.figure(figsize=(11, 7), dpi=100)
plt.contourf(X, Y, p, alpha=0.5, cmap='viridis')
plt.colorbar()
plt.contour(X, Y, p, cmap='viridis')
plt.quiver(X, Y, u, v)
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Velocity field and pressure contours')
plt.show()
```

This code initializes the velocity and pressure fields, iteratively solves the Navier-Stokes equations using finite differences, applies the specified boundary conditions, and saves the final state of the fields. The visualization at the end provides a quiver plot of the velocity field and a contour plot of the pressure field.
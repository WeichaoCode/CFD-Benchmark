#!/usr/bin/env python3
import numpy as np

def pressure_poisson(p, b, dx, dy, nit):
    ny, nx = p.shape
    for it in range(nit):
        pn = p.copy()
        # Update interior points
        p[1:-1, 1:-1] = (((pn[1:-1, 2:] + pn[1:-1, 0:-2]) * dy**2 + 
                          (pn[2:, 1:-1] + pn[0:-2, 1:-1]) * dx**2 - 
                          b[1:-1, 1:-1] * dx**2 * dy**2) / 
                         (2 * (dx**2 + dy**2)))
        # Periodic BC in x for pressure
        p[:, 0] = p[:, -2]
        p[:, -1] = p[:, 1]
        # Neumann BC in y (dp/dy=0)
        p[0, :] = p[1, :]
        p[-1, :] = p[-2, :]
    return p

if __name__ == "__main__":
    # Domain parameters
    nx = 41
    ny = 41
    lx = 2.0
    ly = 2.0
    dx = lx / (nx - 1)
    dy = ly / (ny - 1)

    # Temporal domain
    t_final = 0.1
    dt = 0.001
    nt = int(t_final / dt)

    # Physical parameters
    rho = 1.0
    nu = 0.1
    F = 1.0

    # Pressure Poisson iterations per time step
    nit = 50

    # Initialize fields: using 2D arrays shape (ny, nx)
    u = np.zeros((ny, nx))
    v = np.zeros((ny, nx))
    p = np.zeros((ny, nx))
    b = np.zeros((ny, nx))

    # Time-stepping loop
    for n in range(nt):
        un = u.copy()
        vn = v.copy()

        # Compute the source term for the pressure Poisson eq.
        # Use central differences; note interior points only.
        dudx = (un[1:-1, 2:] - un[1:-1, 0:-2]) / (2 * dx)
        dudy = (un[2:, 1:-1] - un[0:-2, 1:-1]) / (2 * dy)
        dvdx = (vn[1:-1, 2:] - vn[1:-1, 0:-2]) / (2 * dx)
        dvdy = (vn[2:, 1:-1] - vn[0:-2, 1:-1]) / (2 * dy)
        b[1:-1, 1:-1] = dudx**2 + 2 * dudy * dvdx + dvdy**2

        # Update u field
        u[1:-1, 1:-1] = (un[1:-1, 1:-1] -
                         un[1:-1, 1:-1] * dt / dx * (un[1:-1, 1:-1] - un[1:-1, 0:-2]) -
                         vn[1:-1, 1:-1] * dt / dy * (un[1:-1, 1:-1] - un[0:-2, 1:-1]) -
                         dt / (2 * dx) * (p[1:-1, 2:] - p[1:-1, 0:-2]) +
                         nu * dt * ((un[1:-1, 2:] - 2 * un[1:-1, 1:-1] + un[1:-1, 0:-2]) / dx**2 +
                                    (un[2:, 1:-1] - 2 * un[1:-1, 1:-1] + un[0:-2, 1:-1]) / dy**2) +
                         F * dt)
        # Update v field
        v[1:-1, 1:-1] = (vn[1:-1, 1:-1] -
                         un[1:-1, 1:-1] * dt / dx * (vn[1:-1, 1:-1] - vn[1:-1, 0:-2]) -
                         vn[1:-1, 1:-1] * dt / dy * (vn[1:-1, 1:-1] - vn[0:-2, 1:-1]) -
                         dt / (2 * dy) * (p[2:, 1:-1] - p[0:-2, 1:-1]) +
                         nu * dt * ((vn[1:-1, 2:] - 2 * vn[1:-1, 1:-1] + vn[1:-1, 0:-2]) / dx**2 +
                                    (vn[2:, 1:-1] - 2 * vn[1:-1, 1:-1] + vn[0:-2, 1:-1]) / dy**2))

        # Enforce boundary conditions for u and v
        # Periodic BC in x-direction
        u[:, 0] = u[:, -2]
        u[:, -1] = u[:, 1]
        v[:, 0] = v[:, -2]
        v[:, -1] = v[:, 1]
        # No-slip BC in y-direction for velocity
        u[0, :] = 0
        u[-1, :] = 0
        v[0, :] = 0
        v[-1, :] = 0

        # Solve pressure Poisson equation
        p = pressure_poisson(p, b, dx, dy, nit)
        # Pressure boundary conditions
        p[:, 0] = p[:, -2]        # periodic in x
        p[:, -1] = p[:, 1]
        p[0, :] = p[1, :]         # Neumann in y: dp/dy = 0
        p[-1, :] = p[-2, :]

    # Save the final solution fields as separate 2D numpy arrays
    np.save("u.npy", u)
    np.save("v.npy", v)
    np.save("p.npy", p)
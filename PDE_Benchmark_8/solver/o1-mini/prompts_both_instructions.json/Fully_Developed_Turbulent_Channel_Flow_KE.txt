```python
import numpy as np
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve

# Parameters
H = 2.0
n = 100
rho = 1.0  # Density
mu = 1.0   # Dynamic viscosity
C_e1 = 1.44
C_e2 = 1.92
C_mu = 0.09
sigma_k = 1.0
sigma_epsilon = 1.3
f_mu = 1.0
f1 = 1.0
f2 = 1.0

# Create non-uniform mesh clustered near walls
beta = 1.5
y = H * (np.linspace(0, 1, n))**beta
dy = np.diff(y)

# Initialize variables
k = np.zeros(n)
epsilon = np.zeros(n)
u = np.zeros(n)

# Boundary conditions for velocity (no-slip at walls)
u[0] = 0.0
u[-1] = 0.0

# Iterative solver parameters
max_iter = 1000
tolerance = 1e-6

for iteration in range(max_iter):
    k_old = k.copy()
    epsilon_old = epsilon.copy()
    
    # Compute mu_t
    mu_t = C_mu * f_mu * rho * (k**2) / (epsilon + 1e-12)
    
    # Assemble A and b for k equation
    A_k = lil_matrix((n, n))
    b_k = np.zeros(n)
    
    for i in range(1, n-1):
        dyl = y[i] - y[i-1]
        dyu = y[i+1] - y[i]
        
        mu_eff_lower = mu + 0.5 * (mu_t[i-1] + mu_t[i])
        mu_eff_upper = mu + 0.5 * (mu_t[i] + mu_t[i+1])
        
        A_k[i, i-1] = mu_eff_lower / dyl**2
        A_k[i, i] = -(mu_eff_lower / dyl**2 + mu_eff_upper / dyu**2)
        A_k[i, i+1] = mu_eff_upper / dyu**2
        
        b_k[i] = rho * epsilon[i]
    
    # Boundary conditions for k
    A_k[0, 0] = 1.0
    b_k[0] = 0.0
    A_k[-1, -1] = 1.0
    b_k[-1] = 0.0
    
    # Convert A_k to CSC format for solver
    A_k_csc = A_k.tocsc()
    
    # Solve for k
    k = spsolve(A_k_csc, b_k)
    
    # Assemble A and b for epsilon equation
    A_e = lil_matrix((n, n))
    b_e = np.zeros(n)
    
    for i in range(1, n-1):
        dyl = y[i] - y[i-1]
        dyu = y[i+1] - y[i]
        
        mu_eff_lower = mu + 0.5 * (mu_t[i-1] + mu_t[i])
        mu_eff_upper = mu + 0.5 * (mu_t[i] + mu_t[i+1])
        
        A_e[i, i-1] = mu_eff_lower / dyl**2
        A_e[i, i] = -(mu_eff_lower / dyl**2 + mu_eff_upper / dyu**2)
        A_e[i, i+1] = mu_eff_upper / dyu**2
        
        # Production and dissipation terms
        if k[i] > 1e-12:
            production = (epsilon[i] / k[i]) * (C_e1 * f1 * (mu_t[i] * (u[i+1] - u[i]) / dyu) - C_e2 * f2 * epsilon[i])
        else:
            production = 0.0
        b_e[i] = -production + (mu_eff_lower * epsilon[i-1] / dyl**2 + mu_eff_upper * epsilon[i+1] / dyu**2)
    
    # Boundary conditions for epsilon
    A_e[0, 0] = 1.0
    b_e[0] = 0.0
    A_e[-1, -1] = 1.0
    b_e[-1] = 0.0
    
    # Convert A_e to CSC format for solver
    A_e_csc = A_e.tocsc()
    
    # Solve for epsilon
    epsilon = spsolve(A_e_csc, b_e)
    
    # Check for convergence
    if np.linalg.norm(k - k_old, np.inf) < tolerance and np.linalg.norm(epsilon - epsilon_old, np.inf) < tolerance:
        break

# Compute mu_t with final k and epsilon
mu_t = C_mu * f_mu * rho * (k**2) / (epsilon + 1e-12)

# Assemble A and b for velocity equation
A_u = lil_matrix((n, n))
b_u = np.zeros(n)

for i in range(1, n-1):
    dyl = y[i] - y[i-1]
    dyu = y[i+1] - y[i]
    
    mu_eff_lower = mu + 0.5 * (mu_t[i-1] + mu_t[i])
    mu_eff_upper = mu + 0.5 * (mu_t[i] + mu_t[i+1])
    
    A_u[i, i-1] = mu_eff_lower / dyl**2
    A_u[i, i] = -(mu_eff_lower / dyl**2 + mu_eff_upper / dyu**2)
    A_u[i, i+1] = mu_eff_upper / dyu**2
    b_u[i] = 0.0

# Boundary conditions for velocity
A_u[0, 0] = 1.0
b_u[0] = 0.0
A_u[-1, -1] = 1.0
b_u[-1] = 0.0

# Convert A_u to CSC format for solver
A_u_csc = A_u.tocsc()

# Solve for velocity
u = spsolve(A_u_csc, b_u)

# Save variables
save_values = ['k', 'epsilon', 'u']
np.save('k.npy', k)
np.save('epsilon.npy', epsilon)
np.save('u.npy', u)
```
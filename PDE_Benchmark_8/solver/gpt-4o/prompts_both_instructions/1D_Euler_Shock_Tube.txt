```python
import numpy as np

# Constants
gamma = 1.4
CFL = 1.0
L = 2.0
Nx = 81
x = np.linspace(-1, 1, Nx)
dx = x[1] - x[0]

# Initial conditions
rho = np.where(x < 0, 1.0, 0.125)
u = np.zeros(Nx)
p = np.where(x < 0, 1.0, 0.1)

# Compute initial conservative variables
E = p / ((gamma - 1) * rho) + 0.5 * u**2
U = np.array([rho, rho * u, rho * E])

# Time-stepping parameters
t = 0.0
t_end = 0.25

# Function to compute flux
def compute_flux(U):
    rho = U[0]
    rho_u = U[1]
    rho_E = U[2]
    u = rho_u / rho
    p = (gamma - 1) * (rho_E - 0.5 * rho * u**2)
    F = np.array([rho_u, rho_u * u + p, u * (rho_E + p)])
    return F

# Time-stepping loop
while t < t_end:
    # Compute time step
    u = U[1] / U[0]
    p = (gamma - 1) * (U[2] - 0.5 * U[0] * u**2)
    c = np.sqrt(gamma * p / U[0])
    dt = CFL * dx / np.max(np.abs(u) + c)
    if t + dt > t_end:
        dt = t_end - t

    # Predictor step
    F = compute_flux(U)
    U_pred = U.copy()
    U_pred[:, :-1] = U[:, :-1] - dt / dx * (F[:, 1:] - F[:, :-1])

    # Apply reflective boundary conditions
    U_pred[:, 0] = U_pred[:, 1]
    U_pred[:, -1] = U_pred[:, -2]

    # Corrector step
    F_pred = compute_flux(U_pred)
    U[:, 1:-1] = 0.5 * (U[:, 1:-1] + U_pred[:, 1:-1] - dt / dx * (F_pred[:, 1:-1] - F_pred[:, :-2]))

    # Apply reflective boundary conditions
    U[:, 0] = U[:, 1]
    U[:, -1] = U[:, -2]

    # Update time
    t += dt

# Convert back to primitive variables
rho = U[0]
u = U[1] / U[0]
p = (gamma - 1) * (U[2] - 0.5 * U[0] * u**2)

# Save final fields as .npy files
np.save('rho.npy', rho)
np.save('u.npy', u)
np.save('p.npy', p)
np.save('U.npy', U)
np.save('F.npy', compute_flux(U))
```

This code implements the MacCormack method to solve the 1D Euler equations for a shock tube problem. It initializes the problem with the given initial conditions, applies reflective boundary conditions, and uses a predictor-corrector scheme to advance the solution in time. The final solution fields for density (`rho`), velocity (`u`), pressure (`p`), conservative variables (`U`), and fluxes (`F`) are saved as `.npy` files.
import numpy as np

# Domain parameters
Lx, Ly = 2.0, 1.0
Nx, Ny = 101, 51  # number of grid points in x and y
dx = Lx / (Nx - 1)
dy = Ly / (Ny - 1)

# Create mesh
x = np.linspace(0, Lx, Nx)
y = np.linspace(0, Ly, Ny)

# Initialize potential field with initial condition p = 0
p = np.zeros((Nx, Ny))

# Boundary conditions
# Left boundary: p=0 at x=0
p[0, :] = 0.0
# Right boundary: p=y at x=2, so set using corresponding y values
p[-1, :] = y

# Tolerance and maximum iterations for iterative method (Gauss-Seidel)
tol = 1e-6
max_iter = 10000

# Coefficients for finite difference (using central difference)
dx2 = dx**2
dy2 = dy**2
denom = 2*(dx2 + dy2)

for it in range(max_iter):
    p_old = p.copy()
    
    # Update interior points using finite difference laplace equation
    for i in range(1, Nx-1):
        for j in range(1, Ny-1):
            p[i,j] = ((p[i+1,j] + p[i-1,j])*dy2 + (p[i,j+1] + p[i,j-1])*dx2) / denom
    
    # Apply Neumann BC at bottom (y=0): dp/dy=0 => p[i,0] = p[i,1]
    p[:,0] = p[:,1]
    # Apply Neumann BC at top (y=Ly): dp/dy=0 => p[i,Ny-1] = p[i,Ny-2]
    p[:,-1] = p[:,-2]
    
    # Re-impose Dirichlet BC on left and right boundaries in case of updates from neighbors
    p[0, :] = 0.0
    p[-1, :] = y
    
    # Check convergence
    error = np.linalg.norm(p - p_old, ord=np.inf)
    if error < tol:
        break

# Save final solution p as a 2D numpy array in a file "p.npy"
np.save("p.npy", p)
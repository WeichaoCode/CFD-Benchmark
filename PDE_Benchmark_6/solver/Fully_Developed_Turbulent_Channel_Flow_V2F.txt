Here is a simplified implementation for the task given in Python. This code implements a simple central difference scheme to discretize the RANS equation and uses a simple constant eddy viscosity for the turbulence modeling. The solution is saved in .npy format and the velocity profile is plotted using “matplotlib”:

```Python
import numpy as np
import matplotlib.pyplot as plt

#Computation parameters
N = 100    #Number of points in y direction
L = 1.0    #Length of the channel in y direction

#Physical parameters
mu = 1.0   #Viscocity
mu_t = 0.1 #Turbulent visocity

#Discretization
y = np.linspace(0, L, N)   #y co-ordinates
dy = y[1] - y[0]           #Size of y step

#Initialize velocity
u = np.zeros(N)

#Iterative solver
for iter in range(1000):
    #Copy the old values
    old_u = np.copy(u)

    #Inner points
    for i in range(1, N - 1):
        mueff_up = 0.5 * (mu + mu_t) + 0.5 * (mu + mu_t)
        mueff_down = 0.5 * (mu + mu_t) + 0.5 * (mu + mu_t)
        u[i] = ((mueff_up * old_u[i+1] + mueff_down * old_u[i-1] + dy*dy) / 
                (mueff_up + mueff_down))

    #Boundary points
    u[0] = u[1]   #Bottom
    u[-1] = u[-2] #Top

    #Check for convergence
    if np.max(np.abs(u - old_u)) < 1e-6:
        break

#Save the velocity profile to a file
np.save('channel.npy', u)

#Plot the velocity profile
plt.figure()
plt.plot(y, u, label="Channel flow")
plt.xlabel("y")
plt.ylabel("u")
plt.legend()
plt.show()
```

Note that this is a oversimplified model, and it assumes that the turbulence is isotropic and homogeneous, which is not the case in real world turbulent channel flows. Furthermore, this model does not take into account the non-linearity of the turbulent eddy viscosity. For a more accurate prediction of the flow, you should use a more advanced turbulence model, such as k-epsilon or k-omega, or a direct numerical simulation (DNS). Each of these methods will involve significantly more complex implementations and high computational complexity.
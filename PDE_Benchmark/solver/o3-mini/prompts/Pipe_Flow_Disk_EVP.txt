#!/usr/bin/env python3
import numpy as np
from scipy import linalg

# Chebyshev differentiation matrix on [0,1]
def cheb(N):
    if N == 1:
        D = np.array([[0]], dtype=float)
        x = np.array([1.0], dtype=float)
        return D, x
    n = np.arange(0, N)
    x = np.cos(np.pi * n/(N-1))  # Chebyshev nodes on [-1,1]
    # Map x from [-1,1] to r in [0,1]
    r = (x+1)/2
    c = np.ones(N)
    c[0] = 2
    c[-1] = 2
    c = c * ((-1)**n)
    X = np.tile(x, (N,1))
    dX = X - X.T
    D = (np.outer(c,1/c))/(dX+np.eye(N))
    D = D - np.diag(np.sum(D,axis=1))
    # Chain rule: if x -> r = (x+1)/2, then d/dr = 2 d/dx.
    D = 2*D
    # Also compute D2 (second derivative matrix)
    D2 = np.dot(D, D)
    return D, r, D2

# Parameters
N = 50           # Number of radial collocation points
Re = 1e4
kz = 1.0
im = 1j

# Get Chebyshev differentiation matrices and nodes in r
D, r, D2 = cheb(N)

# Prepare 1/r and 1/r^2 terms as diagonal matrices.
# Avoid singularity at r=0 by assigning limiting value 0.
one_over_r = np.zeros(N)
one_over_r2 = np.zeros(N)
for i in range(N):
    if r[i] != 0:
        one_over_r[i] = 1.0/r[i]
        one_over_r2[i] = 1.0/(r[i]**2)
    else:
        one_over_r[i] = 0.0
        one_over_r2[i] = 0.0
Dr_inv = np.diag(one_over_r)
Dr2_inv = np.diag(one_over_r2)

# Background flow and its radial derivative: w0 = 1 - r^2, w0' = -2r
w0 = 1 - r**2
dw0 = -2*r

I = np.eye(N)
Z = np.zeros((N,N))

# --- Assemble block matrices ---
# The full system has 3N unknowns:
# X = [ u (radial perturbation, length N); w (axial perturbation, length N); p (pressure, length N) ]
# Equations are arranged in 3 blocks (each N rows):
# Block 1 (rows 0...N-1): Continuity: u_r' + (1/r) u + i*kz*w = 0.
# Block 2 (rows N...2N-1): Radial momentum:
#       s*u + i*kz*w0*u + p_r - (1/Re)*( u_r'' + (1/r)u_r' - (1/r^2)u - kz^2*u ) = 0.
# Block 3 (rows 2N...3N-1): Axial momentum:
#       s*w + i*kz*w0*w + (dw0/dr)*u + i*kz*p - (1/Re)*( w'' + (1/r)w' - kz^2*w ) = 0.
#
# We want to cast it into a generalized eigenvalue problem A X = s B X.
# Note: s appears only multiplying u (in block2) and w (in block3).

# Blocks for continuity (Block1):
# For u: D u + (1/r)*u   => (D + diag(1/r)) * u.
A11 = D + np.diag(one_over_r)
# For w: i*kz*I.
A12 = im * kz * I
# For p: no term.
A13 = np.zeros((N,N))

# B block for eq1 is zero.
B1 = np.zeros((N, 3*N))

# Blocks for radial momentum (Block2):
# Terms not multiplied by s:
# u: i*kz*w0*u - (1/Re)*( u'' + (1/r)u' - (1/r^2)u - kz^2*u ).
# p: p_r term -> D applied to p.
A21_u = im * kz * np.diag(w0) - (1/Re) * ( D2 + Dr_inv @ D - np.diag(one_over_r2) - kz**2 * I )
A21 = A21_u
A22 = np.zeros((N,N))  # w not in eq2
A23 = D.copy()       # derivative of p: use D

# B2: s multiplies u in eq2.
B2 = np.hstack([I, np.zeros((N,2*N))])

# Blocks for axial momentum (Block3):
# Terms not multiplied by s:
# w: i*kz*w0*w - (1/Re)*( w'' + (1/r)w' - kz^2*w )
A31_w = im * kz * np.diag(w0) - (1/Re) * ( D2 + Dr_inv @ D - kz**2 * I )
A31 = np.zeros((N,N))  # coupling from u in eq3: (dw0/dr)*u = -2*r * u.
A32 = A31_w
A33 = im * kz * I  # from i*kz*p term
# Also, add coupling from u: (dw0/dr)*u, with dw0/dr = -2*r.
A31 = np.diag(dw0)  # note: dw0 = -2*r

# B3: s multiplies w in eq3.
B3 = np.hstack([np.zeros((N,N)), I, np.zeros((N,N))])

# Assemble full A and B matrices
A_top = np.hstack([A11, A12, A13])   # block1
A_mid = np.hstack([A21, np.zeros((N,N)), A23])  # block2: u and p parts (w block is zero)
A_bot = np.hstack([A31, A32, A33])   # block3

A = np.vstack([A_top, A_mid, A_bot])
B = np.vstack([B1, B2, B3])

# --- Impose Boundary Conditions ---
# We have five BCs to impose:
# 1. u( r=0 ) = 0       => impose at i=0 in Block2 (radial momentum eq)
# 2. u( r=1 ) = 0       => impose at i=N-1 in Block2.
# 3. w'( r=0 ) = 0      => impose at i=0 in Block3 (replace row with derivative of w)
# 4. w( r=1 ) = 0       => impose at i=N-1 in Block3.
# 5. p( r=1 ) = 0       => impose at r=1; here we set it in Block1 (replace row i=N-1).

# For convenience, the rows corresponding to grid index i for each block are:
# Block1 (continuity): rows 0 ... N-1.
# Block2 (radial momentum for u): rows N ... 2N-1.
# Block3 (axial momentum for w): rows 2N ... 3N-1.

# 1. u(0)=0 in Block2, i=0 => row index = N + 0.
row = N + 0
A[row, :] = 0
# In the unknown vector, u occupies columns 0...N-1.
A[row, 0] = 1.0
B[row, :] = 0

# 2. u(1)=0 in Block2, i=N-1 => row index = N + (N-1)
row = N + (N-1)
A[row, :] = 0
A[row, (N-1)] = 1.0
B[row, :] = 0

# 3. w'(0)=0 in Block3, i=0 => row index = 2N + 0.
# Replace this row with the derivative condition w'(0)=0.
row = 2*N + 0
A[row, :] = 0
# For w, which occupies columns N to 2N, set the row to the D matrix row at index 0.
A[row, N:2*N] = D[0, :]
B[row, :] = 0

# 4. w(1)=0 in Block3, i=N-1 => row index = 2N + (N-1)
row = 2*N + (N-1)
A[row, :] = 0
A[row, N+(N-1)] = 1.0
B[row, :] = 0

# 5. p(1)=0 in Block1, i=N-1 => row index = (N-1) in Block1.
row = (N-1)
A[row, :] = 0
# p occupies columns 2N to 3N.
A[row, 2*N + (N-1)] = 1.0
B[row, :] = 0

# --- Solve the generalized eigenvalue problem A x = s B x ---
eigvals, eigvecs = linalg.eig(A, B)

# Pick the eigenvalue with largest real part and its eigenvector
idx = np.argmax(eigvals.real)
s_eig = eigvals[idx]
X = eigvecs[:, idx]

# Extract solution fields
u_sol = X[0:N].real
w_sol = X[N:2*N].real
p_sol = X[2*N:3*N].real

# Save the final solution for each variable (1D arrays)
np.save("u.npy", u_sol)
np.save("w.npy", w_sol)
np.save("p.npy", p_sol)
```python
import numpy as np

# Parameters
L = 0.1  # domain length [m]
N = 100  # number of control volumes
Gamma = 1e-4  # diffusion coefficient [m^2/s]

# Grid
dx = L/N  # control volume size
x = np.linspace(dx/2, L-dx/2, N)  # cell centers
xf = np.linspace(0, L, N+1)  # face locations

# Initialize arrays
phi = np.zeros(N)  # solution array
a_W = np.zeros(N)  # west coefficients 
a_E = np.zeros(N)  # east coefficients
a_P = np.zeros(N)  # center coefficients
b = np.zeros(N)    # source terms

# Set coefficients
for i in range(N):
    if i == 0:  # west boundary
        a_W[i] = 0
        a_E[i] = Gamma/dx
        a_P[i] = a_W[i] + a_E[i]
        b[i] = (Gamma/dx)*10  # west BC
    elif i == N-1:  # east boundary
        a_W[i] = Gamma/dx
        a_E[i] = 0
        a_P[i] = a_W[i] + a_E[i]
        b[i] = (Gamma/dx)*100  # east BC
    else:  # internal nodes
        a_W[i] = Gamma/dx
        a_E[i] = Gamma/dx
        a_P[i] = a_W[i] + a_E[i]
        b[i] = 0

# Solve system using Thomas algorithm
def TDMA(a_W, a_E, a_P, b):
    n = len(b)
    P = np.zeros(n)
    Q = np.zeros(n)
    
    # Forward substitution
    P[0] = a_E[0]/a_P[0]
    Q[0] = b[0]/a_P[0]
    for i in range(1,n):
        denom = a_P[i] - a_W[i]*P[i-1]
        P[i] = a_E[i]/denom
        Q[i] = (b[i] + a_W[i]*Q[i-1])/denom
    
    # Back substitution
    phi = np.zeros(n)
    phi[-1] = Q[-1]
    for i in range(n-2,-1,-1):
        phi[i] = P[i]*phi[i+1] + Q[i]
        
    return phi

# Solve and save solution
phi = TDMA(a_W, a_E, a_P, b)
np.save('phi', phi)
```
Here is a Python code that implements the Alternating Direction Implicit (ADI) method for the given problem. The code uses NumPy for array computations and Matplotlib for visualization.

```python
import numpy as np
import matplotlib.pyplot as plt

# Problem parameters
alpha = 1.0
Q0 = 200.0
sigma = 0.1
t_max = 3.0

# Grid parameters
nx, ny = 41, 41
dx = 2.0 / (nx - 1)
dy = 2.0 / (ny - 1)
beta = dx / dy

# Compute the adjusted stability parameter and time step size
r = 1.0 / (1.0 + beta**2)
dt = r * dx**2 / alpha

# Initialize the grid
x = np.linspace(-1, 1, nx)
y = np.linspace(-1, 1, ny)
T = np.zeros((nx, ny))

# Source term
def q(x, y):
    return Q0 * np.exp(-(x**2 + y**2) / (2*sigma**2))

# ADI method
def ADI(T, dt):
    T_new = np.zeros_like(T)
    
    # First step: solve implicitly in x-direction, explicitly in y-direction
    for i in range(1, nx-1):
        for j in range(1, ny-1):
            T_new[i,j] = 0.5*r*(T[i+1,j] - 2*T[i,j] + T[i-1,j]) + 0.5*beta**2*r*(T[i,j+1] - 2*T[i,j] + T[i,j-1]) + T[i,j] + 0.5*dt*q(x[i], y[j])
    
    # Second step: solve implicitly in y-direction, explicitly in x-direction
    T[:] = T_new
    for i in range(1, nx-1):
        for j in range(1, ny-1):
            T_new[i,j] = 0.5*r*(T[i+1,j] - 2*T[i,j] + T[i-1,j]) + 0.5*beta**2*r*(T_new[i,j+1] - 2*T_new[i,j] + T_new[i,j-1]) + T_new[i,j] + 0.5*dt*q(x[i], y[j])
    
    return T_new

# Time-stepping loop
t = 0.0
while t < t_max:
    T = ADI(T, dt)
    t += dt

# Save the solution in .npy format
np.save('solution.npy', T)

# Plot the solution
plt.figure(figsize=(8,6))
plt.contourf(x, y, T, cmap='hot')
plt.colorbar()
plt.title('Temperature Distribution at t = {:.2f} s'.format(t_max))
plt.xlabel('x')
plt.ylabel('y')
plt.show()
```

This code implements the ADI method using two nested loops for the x and y directions. The first loop solves the heat equation implicitly in the x-direction and explicitly in the y-direction. The second loop then solves the equation implicitly in the y-direction and explicitly in the x-direction. The temperature distribution is updated at each time step until the maximum simulation time is reached. The final temperature distribution is saved in .npy format and also plotted using Matplotlib.
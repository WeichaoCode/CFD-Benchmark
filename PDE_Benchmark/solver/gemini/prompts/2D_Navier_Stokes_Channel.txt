```python
import numpy as np

def solve_cfd():
    # Parameters
    rho = 1.0
    nu = 0.1
    F = 1.0
    Lx = 2.0
    Ly = 2.0
    T = 0.1
    nx = 21
    ny = 21
    nt = 100
    dx = Lx / (nx - 1)
    dy = Ly / (ny - 1)
    dt = T / (nt - 1)

    # Initialize variables
    u = np.zeros((nx, ny))
    v = np.zeros((nx, ny))
    p = np.zeros((nx, ny))

    # Functions for derivatives
    def central_diff(f, dx, dy):
        df_dx = np.zeros_like(f)
        df_dy = np.zeros_like(f)
        for i in range(1, nx - 1):
            for j in range(ny):
                df_dx[i, j] = (f[i + 1, j] - f[i - 1, j]) / (2 * dx)
        for i in range(nx):
            for j in range(1, ny - 1):
                df_dy[i, j] = (f[i, j + 1] - f[i, j - 1]) / (2 * dy)
        return df_dx, df_dy

    def laplacian(f, dx, dy):
        laplace_f = np.zeros_like(f)
        for i in range(1, nx - 1):
            for j in range(1, ny - 1):
                laplace_f[i, j] = (f[i + 1, j] - 2 * f[i, j] + f[i - 1, j]) / dx**2 + \
                                  (f[i, j + 1] - 2 * f[i, j] + f[i, j - 1]) / dy**2
        return laplace_f

    # Time loop
    for n in range(nt):
        # Calculate nonlinear terms
        u_dx, u_dy = central_diff(u, dx, dy)
        v_dx, v_dy = central_diff(v, dx, dy)

        # Calculate pressure gradient
        p_dx, p_dy = central_diff(p, dx, dy)

        # Update velocities
        u_laplacian = laplacian(u, dx, dy)
        v_laplacian = laplacian(v, dx, dy)

        u_new = np.copy(u)
        v_new = np.copy(v)

        for i in range(1, nx - 1):
            for j in range(1, ny - 1):
                u_new[i, j] = u[i, j] + dt * (-u[i, j] * u_dx[i, j] - v[i, j] * u_dy[i, j] - (1 / rho) * p_dx[i, j] + nu * u_laplacian[i, j] + F)
                v_new[i, j] = v[i, j] + dt * (-u[i, j] * v_dx[i, j] - v[i, j] * v_dy[i, j] - (1 / rho) * p_dy[i, j] + nu * v_laplacian[i, j])

        # Boundary conditions for u and v
        u_new[:, 0] = 0.0
        u_new[:, ny - 1] = 0.0
        v_new[:, 0] = 0.0
        v_new[:, ny - 1] = 0.0

        # Periodic boundary conditions for u and v
        u_new[0, :] = u_new[nx - 2, :]
        u_new[nx - 1, :] = u_new[1, :]
        v_new[0, :] = v_new[nx - 2, :]
        v_new[nx - 1, :] = v_new[1, :]

        u = np.copy(u_new)
        v = np.copy(v_new)

        # Calculate RHS of Poisson equation
        u_dx, u_dy = central_diff(u, dx, dy)
        v_dx, v_dy = central_diff(v, dx, dy)

        RHS = np.zeros((nx, ny))
        for i in range(1, nx - 1):
            for j in range(1, ny - 1):
                RHS[i, j] = -rho * (u_dx[i, j]**2 + 2 * u_dy[i, j] * v_dx[i, j] + v_dy[i, j]**2)

        # Solve Poisson equation for pressure
        p_new = np.zeros((nx, ny))
        for iter in range(50):
            p_laplacian = laplacian(p, dx, dy)
            for i in range(1, nx - 1):
                for j in range(1, ny - 1):
                    p_new[i, j] = 0.25 * ((p[i + 1, j] + p[i - 1, j]) + (p[i, j + 1] + p[i, j - 1]) - dx**2 * RHS[i, j])

            # Boundary conditions for pressure
            p_new[:, 0] = p_new[:, 1]
            p_new[:, ny - 1] = p_new[:, ny - 2]

            # Periodic boundary conditions for pressure
            p_new[0, :] = p_new[nx - 2, :]
            p_new[nx - 1, :] = p_new[1, :]

            p = np.copy(p_new)

    # Save the results
    np.save('u.npy', u)
    np.save('v.npy', v)
    np.save('p.npy', p)

solve_cfd()
```
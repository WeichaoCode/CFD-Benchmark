{
    "prompts": {
        "Fully_Developed_Turbulent_Channel_Flow_KE": "\n    You are tasked with solving a **fully-developed turbulent flow in a channel** using the **Reynolds-Averaged Navier-Stokes (RANS) equations** \n    and the **Myong and Kasagi k-ε turbulence model**. The goal is to numerically compute the velocity profile using the **finite difference method (FDM)** \n    and solve the resulting system of equations.\n    \n    ---\n    \n    ### **Governing Equations**\n    The RANS equation for this problem simplifies to:\n    \n    #### **Turbulent Kinetic Energy** \\( k \\):\n    \n    \\[\n    0 = P_k - \rho \\epsilon + \frac{d}{dy} \\left[ \\left( \\mu + \frac{\\mu_t}{\\sigma_k} \right) \frac{dk}{dy} \right]\n    \\]\n    \n    where \\( P_k \\) is the turbulent production term, and \\( \\mu_t \\) is the turbulent eddy viscosity.\n    \n    #### **Turbulent Dissipation** \\( \\epsilon \\):\n    \n    \\[\n    0 = \frac{\\epsilon}{k} \\left( C_{e1} f_1 P_k - C_{e2} f_2 \\epsilon \right) + \frac{d}{dy} \\left[ \\left( \\mu + \frac{\\mu_t}{\\sigma_\\epsilon} \right) \frac{d \\epsilon}{dy} \right]\n    \\]\n    \n    where:\n    - \\( C_{e1}, C_{e2} \\) are model constants.\n    - \\( f_1, f_2 \\) are functions used to account for the near-wall effect.\n    \n    #### **Eddy Viscosity** \\( \\mu_t \\):\n    \n    \\[\n    \\mu_t = C_{\\mu} f_\\mu \rho \frac{k^2}{\\epsilon}\n    \\]\n    \n    where:\n    - \\( C_{\\mu} \\) and \\( f_\\mu \\) are model constants.\n    \n    ---\n    \n    ### **Tasks**\n    #### **1️⃣ Generate a Non-Uniform Mesh**\n    - Use a **MESH class** to compute **y-direction mesh points** and **finite difference matrices**:\n      - \\( n = 100 \\): Number of mesh points.\n      - \\( H = 2 \\): Channel height.\n      - **Cluster mesh points near the walls** using an appropriate stretching function.\n    - Implement the **MESH class**, including:\n      - \\( y \\) coordinates.\n      - First derivative matrix \\( d/dy \\).\n      - Second derivative matrix \\( d^2/dy^2 \\).\n    \n    #### **2️⃣ Compute Turbulent Kinetic Energy and Dissipation**\n    - Implement the **Myong and Kasagi k-ε model** for computing \\( k \\) and \\( \\epsilon \\).\n    \n    #### **3️⃣ Discretize the Governing Equation Using Finite Difference Method**\n    - Use **central difference discretization** for \\( d/dy \\) and \\( d^2/dy^2 \\).\n    \n    - Formulate the **linear system** \\( A u = b \\).\n    \n    #### **4️⃣ Solve the Linear System**\n    - Solve the system using:\n      - **Direct solvers** (e.g., LU decomposition).\n      - **Under-relaxation iterative solvers** (if needed).\n    \n    #### **5️⃣ Plot the Velocity Profile**\n    - Plot the velocity distribution \\( u(y) \\).\n    - Compare the **turbulent velocity profile** to a **laminar parabolic profile**.\n    \n    ### **User-Defined Inputs**\n    - Reynolds number based on friction velocity: \\( Re_\\tau = 395 \\)\n    - Density: \\( \\rho = 1.0 \\)\n    - Dynamic viscosity: \\( \\mu = \\frac{1}{Re_\\tau} \\)\n    \n    ---\n    \n    ### **Requirements**\n    - Implement the solution in **Python**.\n    - Use **NumPy** for numerical operations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed velocity profile in `.npy` format.\n    - Structure the code modularly, including:\n      - A `Mesh` class for grid generation.\n      - A function to compute turbulent viscosity.\n      - A function to solve the linear system.\n    \n    ---\n    \n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Diffusion_FVM": "\n        You are given the **two-dimensional diffusion equation**, which models the steady-state diffusion of velocity in a square duct using the **Finite Volume Method (FVM)**.\n\n    ### **Governing Equation**\n    The equation governing the flow field is derived from the incompressible **Navier-Stokes equations** for the velocity component **w** in the z-direction:\n\n    \\[\n    \\nabla \\cdot ( \\mu \\nabla w ) - \\frac{dP}{dz} = 0\n    \\]\n\n    where:\n    - \\( w(x, y) \\) represents the velocity component in the z-direction.\n    - \\( \\mu \\) is the fluid's dynamic viscosity.\n    - \\( P \\) is the pressure.\n    - \\( \\nabla \\) is the two-dimensional gradient operator.\n\n    ### **Computational Domain**\n    - The flow is considered **steady** (\\( \\partial w / \\partial t = 0 \\)).\n    - The flow occurs in a **square duct** with sides of length \\( h = 0.1m \\).\n    - The **no-slip** boundary condition applies at all walls.\n    - The **fluid properties** are given as:\n      - Dynamic viscosity: \\( \\mu = 1 \\times 10^{-3} \\) Pa·s.\n      - Density: \\( \\rho = 1 \\) kg/m³.\n    - The **pressure gradient** is \\( dP/dz = -3.2 \\) Pa/m.\n\n    ### **Numerical Method**\n    - Use the **Finite Volume Method (FVM)** for discretization.\n    - Apply the **Gauss divergence theorem** to convert the governing PDE into a system of algebraic equations over **control volumes**.\n    - Use **centered finite differences** to approximate derivatives.\n    - Solve the resulting algebraic system iteratively using **Jacobi iteration**.\n\n    ### **Discretization**\n    - The domain is discretized into a **uniform Cartesian grid**.\n    - The control volume is centered at **P** with neighboring points **E, W, N, S**.\n    - The resulting algebraic equation at each grid point is:\n\n      \\[\n      a_P w_P = a_E w_E + a_W w_W + a_N w_N + a_S w_S - S_u\n      \\]\n\n    - Coefficients:\n\n      \\[\n      a_E = a_W = \\frac{\\mu \\Delta y}{\\Delta x}, \\quad a_N = a_S = \\frac{\\mu \\Delta x}{\\Delta y}\n      \\]\n\n      \\[\n      a_P = a_E + a_W + a_N + a_S\n      \\]\n\n    - The pressure gradient source term is:\n\n      \\[\n      S_u = \\frac{dP}{dz} \\Delta x \\Delta y\n      \\]\n\n    ### **Implementation Steps**\n    1. **Define the computational grid:**\n       - Grid points: **nx × ny**\n       - nx = ny = 80\n       - Grid spacing: **Δx = Δy = h / (nx - 1)**\n    \n    2. **Discretize the governing equation using the Finite Volume Method.**\n    \n    3. **Construct the coefficient matrix for the algebraic system.**\n    \n    4. **Solve for w using an iterative solver (Jacobi iteration).**\n    \n    5. **Visualize the solution**:\n       - Plot the velocity field \\( w(x,y) \\) using contour plots.\n\n    ### **Expected Output**\n    - A **contour plot** showing the velocity distribution in the square duct.\n    - Save the computed velocity field as a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "1D_Linear_Convection_corr": "\n    You are given the **one-dimensional linear convection equation**, which models wave propagation with convection and damping:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = \\epsilon \\frac{\\partial^2 u}{\\partial x^2}\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( c \\) is the convection speed,\n    - \\( \\epsilon \\) is a damping factor.\n\n    ### **Computational Domain**\n    - Solve the equation in a **periodic domain**:  \n      \\[\n      x \\in (-5, 5)\n      \\]\n    - The **initial condition** is given by:  \n      \\[\n      u_0 = e^{-x^2}\n      \\]\n    - Consider two cases:  \n      - **Undamped case**: \\( \\epsilon = 0 \\)  \n      - **Damped case**: \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    ### **Numerical Method**\n    - Use the **Predictor-Corrector Method** for **time discretization**.  \n    - Apply **2nd-order central differences** for **spatial discretization** of the derivatives.  \n    - Ensure numerical stability by choosing an appropriate time step.  \n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Spatial domain: \\( x \\in (-5,5) \\)  \n       - Number of grid points: \\( N_x = 101 \\)  \n       - Time step: \\( \\Delta t \\) determined using CFL condition  \n       - Convection speed: \\( c = 1 \\)  \n       - Damping factor: \\( \\epsilon = 0 \\) or \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    2. **Discretize the Domain:**\n       - Spatial grid: \\( x = \\{x_0, x_1, ..., x_{N_x-1}\\} \\)  \n       - Time steps: \\( t = \\{t_0, t_1, ..., t_{N_t-1}\\} \\)  \n\n    3. **Initialize Variables:**\n       - Set initial wave profile \\( u(x,0) = e^{-x^2} \\).  \n\n    4. **Time Integration using Predictor-Corrector Method:**\n       - **Predictor Step** (Explicit Euler Method):\n         \\[\n         u^{*} = u^n + \\Delta t f(t_n, u^n)\n         \\]\n       - **Corrector Step** (Trapezoidal Rule):\n         \\[\n         u^{n+1} = u^n + \\frac{\\Delta t}{2} \\left[ f(t_n, u^n) + f(t_{n+1}, u^{*}) \\right]\n         \\]\n       - Apply **periodic boundary conditions**.  \n\n    5. **Visualization:**\n       - Plot the **wave profile** at different time steps.  \n       - Compare the **damped** and **undamped** cases.  \n\n    ### **Expected Output**\n    The simulation should capture and visualize the following:  \n    - **Wave propagation over time**.  \n    - **Comparison between damped and undamped cases**.  \n    - **Final wave profile at \\( t = T \\)**.  \n\n    ### **Requirements**\n    - Use **NumPy** for numerical operations.  \n    - Use **Matplotlib** for visualization.  \n    - Save the computed solution in a `.npy` file.  \n\n    **Return only the Python code that implements this solution.**\n    ",
        "1D_Burgers_Equation": "You are given the **one-dimensional Burgers' equation**, a fundamental PDE that models **nonlinear convection** and **diffusion**:\n\n\\[\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n\\]\n\nwhere:\n- \\( u(x,t) \\) is the velocity field,\n- \\( \\nu \\) is the viscosity coefficient,\n- \\( x \\) is the spatial coordinate,\n- \\( t \\) is time.\nvariable declarations: \n- number of grid points in x: nx = 101\n- number of time steps: nt = 100\n- dx = 2 * numpy.pi / (nx - 1)\n- viscosity coefficient: nu = .07\n- dt = dx * nu\n\n### **Task:**\n1. **Numerically solve Burgers' equation** over a given spatial and temporal domain.\n2. Apply **periodic boundary conditions**:\n   \\[\n   u(0) = u(2\\pi)\n   \\]\n3. Use the following **initial condition**:\n   \\[\n   u = -\\frac{2\\nu}{\\phi} \\frac{\\partial \\phi}{\\partial x} + 4\n   \\]\n   where:\n   \\[\n   \\phi = \\exp{\\left(\\frac{-x^2}{4\\nu}\\right)} + \\exp{\\left(\\frac{-(x - 2\\pi)^2}{4\\nu}\\right)}\n   \\]\n4. Compare the numerical solution to the **analytical solution** given by:\n   \\[\n   u = -\\frac{2\\nu}{\\phi} \\frac{\\partial \\phi}{\\partial x} + 4\n   \\]\n   where:\n   \\[\n   \\phi = \\exp{\\left(\\frac{-(x - 4t)^2}{4\\nu(t + 1)}\\right)} + \\exp{\\left(\\frac{-(x - 4t - 2\\pi)^2}{4\\nu(t + 1)}\\right)}\n   \\]\n\n### **Requirements:**\n- Use an appropriate **finite difference scheme** for the numerical solution.\n- Ensure **stability and accuracy** of the scheme.\n- Output the numerical solution in a format that allows easy comparison with the analytical solution.\n- Save the velocity field at last time step in a .npy file.\n\n**Return only the Python code that implements this solution.**\n",
        "1D_Nonlinear_Convection_MK": "\n    You are given the **one-dimensional nonlinear convection equation**, a fundamental PDE that models **advection**:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( x \\) is the spatial coordinate,\n    - \\( t \\) is time.\n\n    ### **Computational Domain**\n    - Solve the equation in a periodic domain \\( x \\in [0, 2\\pi] \\)\n    - The initial condition is given by:\n      \\[\n      u(x,0) = \\sin(x) + 0.5 \\sin(0.5x)\n      \\]\n    - The domain has **periodic boundary conditions**.\n\n    ### Choose parameters\n    - CFL number: `nu = 0.5`\n    - Time step: `dt = 0.01`\n    - Maximum number of time steps: `T = 500`\n    - Space step: `dx = dt / nu`\n    \n    ### **Numerical Method**\n    - Use the **MacCormack Method**, a predictor-corrector scheme:\n      - **Predictor Step**:\n        \\[\n        u^*_j = u^n_j - \\frac{\\Delta t}{\\Delta x} (F^n_{j+1} - F^n_j)\n        \\]\n      - **Corrector Step**:\n        \\[\n        u^{n+1}_j = \\frac{1}{2} \\left[ u^n_j + u^*_j - \\frac{\\Delta t}{\\Delta x} (F^*_j - F^*_{j-1}) \\right]\n        \\]\n    - Choose an appropriate time step \\( \\Delta t = 0.1 \\) to ensure numerical stability.\n\n    ### **Tasks**\n    1. Implement the MacCormack method to update \\( u(x,t) \\).\n    2. Apply periodic boundary conditions.\n    3. Simulate wave propagation over time.\n    4. Compare the solution with those from the Lax and Lax-Wendroff methods.\n\n    ### **Requirements**\n    - Use NumPy for numerical operations.\n    - Use Matplotlib to visualize the results.\n    - Save the computed solution in a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Laplace_Equation": "\n    You are given the **two-dimensional Laplace equation**, which describes steady-state diffusion phenomena and is used to model equilibrium solutions for various physical systems:\n\n    \\[\n    \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = 0\n    \\]\n\n    ### **Objective**\n    Solve this equation numerically using the **Finite Difference Method (FDM)**.\n\n    ### **Numerical Method**\n    - Use **central differencing** for the second derivatives in both spatial directions.\n    - The discretized form of the equation using a structured grid is:\n\n      \\[\n      \\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{\\Delta x^2} + \\frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{\\Delta y^2} = 0\n      \\]\n\n      Rearranging for \\( p_{i,j} \\):\n\n      \\[\n      p_{i,j} = \\frac{\\Delta y^2(p_{i+1,j} + p_{i-1,j}) + \\Delta x^2(p_{i,j+1} + p_{i,j-1})}{2(\\Delta x^2 + \\Delta y^2)}\n      \\]\n\n      This discretization is known as the **five-point difference operator**, which is iteratively solved until the solution converges.\n\n    ### **Initial and Boundary Conditions**\n    - **Initial Condition:** Assume \\( p = 0 \\) everywhere in the computational domain.\n    - **Boundary Conditions:**\n      - **Left boundary (\\( x = 0 \\))**: \\( p = 0 \\)\n      - **Right boundary (\\( x = 2 \\))**: \\( p = y \\)\n      - **Top and Bottom boundaries (\\( y = 0, 1 \\))**: Neumann boundary condition: \\( \\frac{\\partial p}{\\partial y} = 0 \\)\n\n    ### **Computational Domain and Parameters**\n    - Solve over a **rectangular domain** where:\n      - \\( x \\in [0, 2] \\), \\( y \\in [0, 1] \\)\n    - Grid resolution:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 31\\)\n      - Number of grid points in \\( y \\)-direction: \\( ny = 31\\)\n      - Spatial step sizes:\n        - \\( dx = \\frac{L_x}{nx - 1} \\)\n        - \\( dy = \\frac{L_y}{ny - 1} \\)\n\n    ### **Tasks**\n    1. Implement an **iterative finite difference solver** to compute the equilibrium solution of the 2D Laplace equation.\n    2. Use a **structured Cartesian grid** with uniform spacing.\n    3. Iterate until the solution converges, ensuring that the maximum change between iterations is below a predefined tolerance.\n    4. Visualize the computed solution using a **contour plot**.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** to generate contour plots of the solution.\n    - Implement iterative solvers such as **Jacobi iteration, Gauss-Seidel, or Successive Over-Relaxation (SOR)**.\n    - Ensure convergence and stability of the numerical scheme.\n    - Save the final p(x,y) in `.npy` format.\n    - Compare the numerical solution with the analytical solution:\n\n      \\[\n      p(x, y) = \\frac{x}{4} - \\frac{4}{\\pi} \\sum_{n=1, odd}^{\\infty} \\frac{1}{(n \\pi)^2} \\sinh(2 n \\pi) \\cos(n \\pi y)\n      \\]\n\n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Linear_Convection": "\n    You are given the **two-dimensional linear convection equation**, which governs the transport of a scalar field in two spatial dimensions:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} + c \\frac{\\partial u}{\\partial y} = 0\n    \\]\n\n    where:\n    - \\( u(x, y, t) \\) is the scalar quantity being transported.\n    - \\( c \\) is the convection speed in both \\( x \\) and \\( y \\) directions.\n\n    ### **Objective**\n    Solve this equation numerically using the **Finite Difference Method (FDM)**.\n\n    ### **Numerical Method**\n    - Use **forward differencing** for the time derivative.\n    - Use **backward differencing** for the spatial derivatives.\n    - The numerical scheme is given by:\n\n      \\[\n      \\frac{u_{i,j}^{n+1} - u_{i,j}^{n}}{\\Delta t} + c \\frac{u_{i,j}^{n} - u_{i-1,j}^{n}}{\\Delta x} + c \\frac{u_{i,j}^{n} - u_{i,j-1}^{n}}{\\Delta y} = 0\n      \\]\n\n      Rearranging for \\( u_{i,j}^{n+1} \\):\n\n      \\[\n      u_{i,j}^{n+1} = u_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x} c (u_{i,j}^{n} - u_{i-1,j}^{n}) - \\frac{\\Delta t}{\\Delta y} c (u_{i,j}^{n} - u_{i,j-1}^{n})\n      \\]\n\n    ### **Initial Condition**\n    The initial condition is defined using a **hat function**, where:\n    - \\( u(x, y) = 2 \\) for \\( 0.5 \\leq x \\leq 1 \\) and \\( 0.5 \\leq y \\leq 1 \\).\n    - \\( u(x, y) = 1 \\) everywhere else.\n\n    ### **Boundary Conditions**\n    The value of \\( u(x, y) \\) is set to **1** on all boundaries:\n    - \\( u = 1 \\) for \\( x = 0, 2 \\).\n    - \\( u = 1 \\) for \\( y = 0, 2 \\).\n\n    ### **Computational Domain and Parameters**\n    - The equation is solved over a **square domain**:\n      - \\( x \\in [0, 2] \\), \\( y \\in [0, 2] \\).\n    - The **grid resolution** is:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 81 \\).\n      - Number of grid points in \\( y \\)-direction: \\( ny = 81 \\).\n      - Spatial step sizes:\n        - \\( dx = \\frac{L_x}{nx - 1} \\).\n        - \\( dy = \\frac{L_y}{ny - 1} \\).\n    - **Time-stepping parameters**:\n      - Number of time steps: \\( nt = 100\\).\n      - Stability parameter: \\( \\sigma = 0.2 \\).\n      - Time step:  \n        \\[\n        dt = \\sigma \\cdot \\frac{\\min(dx, dy)}{c}\n        \\]\n\n    ### **Tasks**\n    1. Implement the **Finite Difference Method** for solving the **2D Linear Convection Equation**.\n    2. Use a structured grid with uniform spacing.\n    3. Simulate the **propagation of the wave** over time.\n    4. Visualize the computed **solution field** using contour plots.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for visualization.\n    - Ensure **numerical stability** by choosing an appropriate time step based on the CFL condition.\n    - Save the computed solution \\( u(x, y) \\) in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "Fully_Developed_Turbulent_Channel_Flow_CESS": "\n    You are tasked with solving a **fully-developed turbulent flow in a channel** using the **Reynolds-Averaged Navier-Stokes (RANS) equations** \n    and the **Cess algebraic turbulence model**. The goal is to numerically compute the velocity profile using the **finite difference method (FDM)** and \n    solve the resulting system of equations.\n    ---\n    \n    ### **Governing Equation**\n    The RANS equation for this problem simplifies to:\n    \n    \\[\n    \frac{d}{dy} \\left( (\\mu + \\mu_t) \frac{d\bar{u}}{dy} \right) = -1.\n    \\]\n    \n    where:\n    - \\( \\mu \\) is the molecular viscosity.\n    - \\( \\mu_t \\) is the turbulent eddy viscosity (computed using the Cess turbulence model).\n    - The effective viscosity is defined as \\( \\mu_{\text{eff}} = \\mu + \\mu_t \\).\n    \n    By applying the product rule, we rewrite it as:\n    \n    \\[\n    \\left[ \frac{d\\mu_{\text{eff}}}{dy} \frac{d}{dy} + \\mu_{\text{eff}} \frac{d^2}{dy^2} \right] u = -1.\n    \\]\n    \n    This can be expressed as a **linear system**:\n    \n    \\[\n    A u = b\n    \\]\n    \n    which will be solved numerically.\n    \n    ---\n    \n    ### **Tasks**\n    #### **1️⃣ Generate a Non-Uniform Mesh**\n    - Use a **MESH class** to compute **y-direction mesh points** and **finite difference matrices**:\n      - \\( n = 100 \\): Number of mesh points.\n      - \\( H = 2 \\): Channel height.\n      - **Cluster mesh points near the walls** using an appropriate stretching function.\n    - Implement the **MESH class**, including:\n      - \\( y \\) coordinates.\n      - First derivative matrix \\( d/dy \\).\n      - Second derivative matrix \\( d^2/dy^2 \\).\n    \n    #### **2️⃣ Compute Effective Viscosity**\n    - Implement the **Cess algebraic turbulence model**:\n    \n      \\[\n      \frac{\\mu_{\text{eff}}}{\\mu} = \frac{1}{2} \\left(1 + \frac{1}{9} \\kappa^2 Re_{\tau}^2 (2y - y^2)^2 (3 - 4y + 2y^2)^2 \\left[ 1 - \\exp\\left(-\frac{y^+}{A}\right) \right] \right)^{1/2} - \frac{1}{2}\n      \\]\n    \n      where:\n      - \\( \\kappa = 0.42 \\) (von Kármán constant).\n      - \\( A = 25.4 \\) (constant).\n      - \\( y^+ = y Re_{\tau} \\).\n      - \\( Re_{\tau} = \frac{\rho u_{\tau} H}{\\mu} \\).\n    \n    #### **3️⃣ Discretize the Governing Equation Using Finite Difference Method**\n    - Use **central difference discretization** for \\( d/dy \\) and \\( d^2/dy^2 \\):\n    \n      \\[\n      \frac{1}{\\Delta y} \\left( \\mu_{\text{eff},i+\frac{1}{2}} \frac{u_{i+1} - u_i}{\\Delta y} - \\mu_{\text{eff},i-\frac{1}{2}} \frac{u_i - u_{i-1}}{\\Delta y} \right) = -1.\n      \\]\n    \n    - Formulate the **linear system** \\( A u = b \\).\n    \n    #### **4️⃣ Solve the Linear System**\n    - Solve the system using:\n      - **Direct solvers** (e.g., LU decomposition).\n      - **Under-relaxation iterative solvers** (if needed).\n    \n    #### **5️⃣ Plot the Velocity Profile**\n    - Plot the velocity distribution \\( u(y) \\).\n    - Compare the **turbulent velocity profile** to a **laminar parabolic profile**.\n    \n    ### **User-Defined Inputs**\n    - Reynolds number based on friction velocity: \\( Re_\\tau = 395 \\)\n    - Density: \\( \\rho = 1.0 \\)\n    - Dynamic viscosity: \\( \\mu = \\frac{1}{Re_\\tau} \\)\n    ---\n    \n    ### **Requirements**\n    - Implement the solution in **Python**.\n    - Use **NumPy** for numerical operations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed velocity profile in `.npy` format.\n    - Structure the code modularly, including:\n      - A `Mesh` class for grid generation.\n      - A function to compute turbulent viscosity.\n      - A function to solve the linear system.\n    ---\n    \n    **Return only the Python code that implements this solution.**\n    ",
        "1D_Nonlinear_Convection_LW": "\n    You are given the **one-dimensional nonlinear convection equation**, a fundamental PDE that models **advection**:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( x \\) is the spatial coordinate,\n    - \\( t \\) is time.\n\n    ### **Computational Domain**\n    - Solve the equation in a periodic domain \\( x \\in [0, 2\\pi] \\)\n    - The initial condition is given by:\n      \\[\n      u(x,0) = \\sin(x) + 0.5 \\sin(0.5x)\n      \\]\n    - The domain has **periodic boundary conditions**.\n    \n        ### Choose parameters\n    - CFL number: `nu = 0.5`\n    - Time step: `dt = 0.01`\n    - Maximum number of time steps: `T = 500`\n    - Space step: `dx = dt / nu`\n    \n    ### **Numerical Method**\n    - Use the **Lax-Wendroff Method**, which is second-order accurate in time:\n      \\[\n      u^{n+1}_j = u^n_j - \\frac{\\Delta t}{2 \\Delta x} (F^n_{j+1} - F^n_{j-1}) \n      + \\frac{\\Delta t^2}{2 \\Delta x^2} \\left(A_{j+1/2} (F^n_{j+1} - F^n_j) - A_{j-1/2} (F^n_j - F^n_{j-1}) \\right)\n      \\]\n    - Choose an appropriate time step \\( \\Delta t = 0.1 \\) to ensure numerical stability.\n\n    ### **Tasks**\n    1. Implement the Lax-Wendroff method to update \\( u(x,t) \\).\n    2. Apply periodic boundary conditions.\n    3. Simulate wave propagation over time.\n    4. Plot the solution and observe the difference compared to the Lax method.\n\n    ### **Requirements**\n    - Use NumPy for numerical operations.\n    - Use Matplotlib to visualize the results.\n    - Save the computed solution in a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "1D_Linear_Convection_adams": "\n    You are given the **one-dimensional linear convection equation**, which models wave propagation with convection and damping:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = \\epsilon \\frac{\\partial^2 u}{\\partial x^2}\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( c \\) is the convection speed,\n    - \\( \\epsilon \\) is a damping factor.\n\n    ### **Computational Domain**\n    - Solve the equation in a **periodic domain**:  \n      \\[\n      x \\in (-5, 5)\n      \\]\n    - The **initial condition** is given by:  \n      \\[\n      u_0 = e^{-x^2}\n      \\]\n    - Consider two cases:  \n      - **Undamped case**: \\( \\epsilon = 0 \\)  \n      - **Damped case**: \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    ### **Numerical Method**\n    - Use the **Adams-Bashforth Method** for **time discretization**.  \n    - Apply **2nd-order central differences** for **spatial discretization** of the derivatives.  \n    - Ensure numerical stability by choosing an appropriate time step.  \n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Spatial domain: \\( x \\in (-5,5) \\)  \n       - Number of grid points: \\( N_x = 101 \\)  \n       - Time step: \\( \\Delta t \\) determined using CFL condition  \n       - Convection speed: \\( c = 1 \\)  \n       - Damping factor: \\( \\epsilon = 0 \\) or \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    2. **Discretize the Domain:**\n       - Spatial grid: \\( x = \\{x_0, x_1, ..., x_{N_x-1}\\} \\)  \n       - Time steps: \\( t = \\{t_0, t_1, ..., t_{N_t-1}\\} \\)  \n\n    3. **Initialize Variables:**\n       - Set initial wave profile \\( u(x,0) = e^{-x^2} \\).  \n       - Use **Explicit Euler Method** to compute the first step since Adams-Bashforth requires prior time values.\n\n    4. **Time Integration using Adams-Bashforth Method:**\n       - For each time step:\n         - Compute the spatial derivatives using **central difference scheme**.  \n         - Apply the **2-step Adams-Bashforth Method**:\n           \\[\n           u^{n+1} = u^n + \\frac{\\Delta t}{2} \\left( 3 f(t_n, u^n) - f(t_{n-1}, u^{n-1}) \\right)\n           \\]\n         - Apply **periodic boundary conditions**.  \n\n    5. **Visualization:**\n       - Plot the **wave profile** at different time steps.  \n       - Compare the **damped** and **undamped** cases.  \n\n    ### **Expected Output**\n    The simulation should capture and visualize the following:  \n    - **Wave propagation over time**.  \n    - **Comparison between damped and undamped cases**.  \n    - **Final wave profile at \\( t = T \\)**.  \n\n    ### **Requirements**\n    - Use **NumPy** for numerical operations.  \n    - Use **Matplotlib** for visualization.  \n    - Save the computed solution in a `.npy` file.  \n\n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Navier_Stokes_Channel": "\n    You are given the **two-dimensional channel flow problem** governed by the **Navier-Stokes equations**. The flow is driven by a constant source term \\( F \\) in the \\( u \\)-momentum equation to mimic pressure-driven channel flow.\n\n    ### **Governing Equations**\n    The modified incompressible Navier-Stokes equations are:\n\n    \\[\n    \frac{\\partial u}{\\partial t} + u \frac{\\partial u}{\\partial x} + v \frac{\\partial u}{\\partial y} = -\frac{1}{\rho} \frac{\\partial p}{\\partial x} + \nu \\left( \frac{\\partial^2 u}{\\partial x^2} + \frac{\\partial^2 u}{\\partial y^2} \right) + F\n    \\]\n\n    \\[\n    \frac{\\partial v}{\\partial t} + u \frac{\\partial v}{\\partial x} + v \frac{\\partial v}{\\partial y} = -\frac{1}{\rho} \frac{\\partial p}{\\partial y} + \nu \\left( \frac{\\partial^2 v}{\\partial x^2} + \frac{\\partial^2 v}{\\partial y^2} \right)\n    \\]\n\n    \\[\n    \frac{\\partial^2 p}{\\partial x^2} + \frac{\\partial^2 p}{\\partial y^2} = -\rho \\left( \frac{\\partial u}{\\partial x} \frac{\\partial u}{\\partial x} + 2 \frac{\\partial u}{\\partial y} \frac{\\partial v}{\\partial x} + \frac{\\partial v}{\\partial y} \frac{\\partial v}{\\partial y} \right)\n    \\]\n\n    where:\n    - \\( u(x,y,t) \\) and \\( v(x,y,t) \\) are the velocity components in the \\( x \\) and \\( y \\) directions.\n    - \\( p(x,y,t) \\) is the pressure field.\n    - \\( \rho \\) is the fluid density.\n    - \\( \nu \\) is the kinematic viscosity.\n    - \\( F \\) is the constant external force applied in the \\( x \\)-direction.\n\n    ### **Initial Condition:**\n    - The velocity components \\( u, v \\) and pressure \\( p \\) are initialized to **zero everywhere** in the domain.\n\n    ### **Boundary Conditions:**\n    - **Periodic boundary conditions** for \\( u, v, p \\) in the \\( x \\)-direction at \\( x = 0, 2 \\).\n    - **No-slip boundary condition** for \\( u, v \\) at \\( y = 0, 2 \\) (i.e., \\( u = 0, v = 0 \\)).\n    - **Pressure gradient condition:** \\( \frac{\\partial p}{\\partial y} = 0 \\) at \\( y = 0, 2 \\).\n    - **Source term:** \\( F = 1 \\) applied uniformly throughout the domain.\n\n    ### **Computational Domain and Parameters:**\n    - The equation is solved over a **rectangular domain** with spatial extent:\n      - \\( x \\in [0, 2] \\), \\( y \\in [0, 2] \\)\n    - The **fluid properties** are:\n      - Density: \\( \rho = 1 \\)\n      - Kinematic viscosity: \\( \nu = 0.1 \\)\n    - The equation is solved over a **rectangular grid** with:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 41 \\)\n      - Number of grid points in \\( y \\)-direction: \\( ny = 41 \\)\n      - Number of time steps: \\( nt = 10 \\)\n\n    ### **Tasks**\n    1. Implement the **Navier-Stokes solver** for **channel flow**.\n    2. Use a structured grid with uniform spacing.\n    3. Apply periodic and no-slip boundary conditions as specified.\n    4. Simulate the velocity and pressure field evolution over time.\n    5. Visualize the computed **velocity field** using quiver plots.\n\n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Ensure **numerical stability** by choosing an appropriate time step.\n    - Save the final velocity field (u, v) and pressure field (p) in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Diffusion": "\n    You are tasked with solving the **two-dimensional diffusion equation**, which models the spreading of a scalar field due to diffusion.\n\n    ### **Governing Equation**\n    The 2D diffusion equation is given by:\n\n    \\[\n    \frac{\\partial u}{\\partial t} = \nu \\left( \frac{\\partial^2 u}{\\partial x^2} + \frac{\\partial^2 u}{\\partial y^2} \right)\n    \\]\n\n    where:\n    - \\( u(x,y,t) \\) represents the diffused quantity (e.g., temperature or concentration),\n    - \\( nu \\) is the diffusion coefficient,\n    - \\( x, y \\) are the spatial coordinates,\n    - \\( t \\) is time.\n\n    ### **Computational Domain**\n    - **Spatial domain:** \\( x \\) and \\( y \\) both range from 0 to 2.\n    - **Grid parameters:**\n      - Number of grid points: \\( n_x = n_y = 31 \\).\n      - Grid spacing: \\( \\Delta x = \\Delta y = \frac{2}{n_x - 1} \\).\n    - **Temporal domain:**\n    - number of time steps: nt = 50\n    - sigma = .25\n    - dt = sigma * dx * dy / nu\n\n    ### **Initial and Boundary Conditions**\n    - **Initial condition:** \\( u = 2 \\) in the region \\( 0.5 \\leq x, y \\leq 1 \\), and \\( u = 1 \\) elsewhere.\n    - **Boundary conditions:** Fixed Dirichlet boundary conditions with \\( u = 1 \\) at all domain boundaries.\n\n    ### **Numerical Method**\n    - **Time integration:** Utilize the **Explicit Euler Method**.\n    - **Spatial discretization:** Use **second-order central differences** for the diffusion terms.\n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Set the domain size, grid resolution, diffusion coefficient, time step, and total simulation time.\n    2. **Initialize Variables:**\n       - Create a 2D array for \\( u \\) with the specified initial condition.\n    3. **Time Integration Loop:**\n       - For each time step until \\( t_{\text{final}} \\):\n         - Compute the temporary array \\( u_{\text{temp}} \\) using the current values of \\( u \\).\n         - Update \\( u \\) using the Explicit Euler formula:\n           \\[\n           u^{n+1}_{i,j} = u^n_{i,j} + \nu \\Delta t \\left( \frac{u^n_{i+1,j} - 2u^n_{i,j} + u^n_{i-1,j}}{\\Delta x^2} + \frac{u^n_{i,j+1} - 2u^n_{i,j} + u^n_{i,j-1}}{\\Delta y^2} \right)\n           \\]\n         - Apply boundary conditions to maintain \\( u = 1 \\) at the domain boundaries.\n    4. **Visualization:**\n       - Generate contour plots of \\( u \\) at selected time intervals to observe the evolution of the diffused field.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for plotting and visualization.\n    - Save the final solution \\( u \\) in a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Steady_Heat_Equation_Gauss": "\n    You are given the **steady two-dimensional heat equation**, which models heat distribution over a rectangular domain:\n\n    \\[\n    \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = 0\n    \\]\n\n    ### **Computational Domain**\n    The equation is solved in a **rectangular domain** with spatial coordinates:\n    - \\( x \\in [0, 5] \\), \\( y \\in [0, 4] \\)\n    \n    The domain is discretized using **finite difference methods** with a structured uniform grid:\n    - Grid spacing in the \\( x \\)-direction: \\( \\Delta x = 0.05 \\)\n    - Grid spacing in the \\( y \\)-direction: \\( \\Delta y = 0.05 \\)\n    \n    The number of grid points in each direction is computed as:\n    - Number of grid points in the \\( x \\)-direction: \\( n_x = \frac{5.0}{0.05} + 1 = 101 \\)\n    - Number of grid points in the \\( y \\)-direction: \\( n_y = \frac{4.0}{0.05} + 1 = 81 \\)\n    \n    Thus, the total grid consists of a uniform grid of **101 points** in the \\( x \\)-direction and **81 points** in the \\( y \\)-direction.\n\n    ### **Boundary Conditions**\n    The temperature values along the boundaries of the domain are fixed:\n    - **Left boundary (AB)**: \\( T = 10^\\circ C \\)\n    - **Top boundary (CD)**: \\( T = 0^\\circ C \\)\n    - **Right boundary (EF)**: \\( T = 40^\\circ C \\)\n    - **Bottom boundary (G)**: \\( T = 20^\\circ C \\)\n\n    ### **Numerical Methods**\n    Solve the steady-state heat equation using the following iterative methods:\n    Gauss-Seidel Method**  \n    - Similar to the Jacobi method but updates each point immediately using newly computed values:\n      \\[\n      T_{i,j}^{k+1} = \\frac{T_{i+1,j}^{k} + T_{i-1,j}^{k} + \\beta^2 (T_{i,j+1}^{k+1} + T_{i,j-1}^{k+1})}{2(1 + \\beta^2)}\n      \\]\n\n    ### **Tasks**\n    1. Implement the selected iterative method (Jacobi, Gauss-Seidel, or SOR) for solving the **2D steady heat equation**.\n    2. Discretize the computational domain using a uniform structured grid.\n    3. Apply the given **Dirichlet boundary conditions**.\n    4. Iterate until convergence, using a stopping criterion based on **residual reduction**.\n    5. Visualize the **steady-state temperature distribution** as a contour plot.\n\n    ### **Requirements**\n    - Use **NumPy** for matrix computations.\n    - Use **Matplotlib** to generate contour plots of the temperature field.\n    - Save the final computed temperature field \\( T(x, y) \\) as a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "1D_Euler_Shock_Tube": "\n   You are given the **one-dimensional Euler equations**, which govern compressible flow dynamics in a **shock tube**. \n   \n   Your task is to numerically solve these equations using the **MacCormack method**.\n\n   ### **Governing Equations**\n   The Euler equations in conservative form are:\n\n   \\[\n   \\frac{\\partial \\mathbf{U}}{\\partial t} + \\frac{\\partial \\mathbf{F}}{\\partial x} = 0\n   \\]\n\n   where:\n\n   \\[\n   \\mathbf{U} = \n   \\begin{bmatrix} \n   \\rho \\\\ \n   \\rho u \\\\ \n   \\rho E \n   \\end{bmatrix}, \n   \\quad \n   \\mathbf{F} = \n   \\begin{bmatrix} \n   \\rho u \\\\ \n   \\rho u^2 + p \\\\ \n   u(\\rho E + p) \n   \\end{bmatrix}\n   \\]\n\n   with:\n\n   - \\( \\rho \\): Density  \n   - \\( u \\): Velocity  \n   - \\( p \\): Pressure  \n   - \\( E \\): Total energy per unit mass,  \n     \\( E = \\frac{p}{(\\gamma - 1)\\rho} + \\frac{u^2}{2} \\)  \n   - \\( \\gamma \\): Ratio of specific heats (typically 1.4 for air)\n\n   ### **Computational Domain**\n   - Spatial domain: \\( x \\in [-1, 1] \\)\n   - Temporal domain: \\( t \\in [0, 0.25] \\)\n\n   ### **Initial Conditions**\n   The shock tube is initially divided into two regions:\n\n   - **Left region** (\\( 0 \\leq x < x_0 \\)):\n     - \\( \\rho_L = 1.0 \\)\n     - \\( u_L = 0.0 \\)\n     - \\( p_L = 1.0 \\)\n\n   - **Right region** (\\( x_0 \\leq x \\leq L \\)):\n     - \\( \\rho_R = 0.125 \\)\n     - \\( u_R = 0.0 \\)\n     - \\( p_R = 0.1 \\)\n\n   ### **Boundary Conditions**\n   - **Reflective (no-flux) boundary conditions** at both ends of the tube.\n\n   ### **Numerical Method**\n   - Implement the **MacCormack Method**, a two-step predictor-corrector approach for hyperbolic systems.\n\n   ### **Implementation Steps**\n   1. **Define Parameters:**\n      - Tube length \\( L \\) 2\n      - Number of spatial points \\( N_x \\) N_x = 81\n      - Time step \\( \\Delta t \\) determined using CFL, CFL = 1\n      - Total simulation time \\( T \\) 0.25\n      - Ratio of specific heats \\( \\gamma \\) gamma = 1.4\n\n   2. **Discretize the Domain:**\n      - Spatial grid: \\( x = \\{x_0, x_1, ..., x_{N_x-1}\\} \\)\n      - Time steps: \\( t = \\{t_0, t_1, ..., t_{N_t-1}\\} \\)\n\n   3. **Initialize Variables:**\n      - Set initial \\( \\rho \\), \\( u \\), and \\( p \\) based on the initial conditions.\n      - Compute initial conservative variables \\( \\mathbf{U} \\).\n\n   4. **Time Integration:**\n      - For each time step:\n        - Compute flux \\( \\mathbf{F} \\) from \\( \\mathbf{U} \\).\n        - Apply the predictor step to estimate \\( \\mathbf{U}^{*} \\).\n        - Compute flux \\( \\mathbf{F}^{*} \\) from \\( \\mathbf{U}^{*} \\).\n        - Apply the corrector step to update \\( \\mathbf{U}^{n+1} \\).\n        - Update primitive variables \\( \\rho \\), \\( u \\), and \\( p \\) from \\( \\mathbf{U}^{n+1} \\).\n\n   5. **Visualization:**\n      - Plot the **density** (\\( \\rho \\)), **velocity** (\\( u \\)), and **pressure** (\\( p \\)) profiles at various time steps.\n      - Observe the formation of shock waves, contact discontinuities, and expansion fans.\n\n   ### **Expected Output**\n   The simulation should capture and visualize the following flow features over time:\n   - **Shock wave propagation**\n   - **Contact discontinuity movement**\n   - **Expansion fan formation**\n\n   ### **Requirements**\n   - Use an appropriate **finite difference scheme**.\n   - Ensure **stability and accuracy** using a suitable time step.\n   - Save the computed density, velocity, and pressure profiles in `.npy` format.\n   - Save mathbf{U}, mathbf{F} in `.npy` format.\n\n   **Return only the Python code that implements this solution.**\n",
        "2D_Unsteady_Heat_Equation_SE": "\n        You are given the **two-dimensional unsteady heat equation** with a source term:\n        \n        \\[\n        \\frac{\\partial T}{\\partial t} - \\alpha \\left( \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} \\right) = q(x, y, t).\n        \\]\n        \n        where:\n        - \\( T(x, y, t) \\) represents the temperature field,\n        - \\( \\alpha \\) is the thermal diffusivity,\n        - \\( q(x, y, t) \\) is a heat source.\n        \n        ### **Objective**\n        Solve the equation numerically using the **Simple Explicit Method**.\n        \n        ### **Numerical Method**\n        - Use a **forward difference** for the time derivative.\n        - Use a **central difference** for the spatial derivatives.\n        - The explicit scheme is given by:\n        \n          \\[\n          T_{i,j}^{n+1} = r (T_{i+1,j}^{n} - 2T_{i,j}^{n} + T_{i-1,j}^{n}) + \\beta^2 r (T_{i,j+1}^{n} - 2T_{i,j}^{n} + T_{i,j-1}^{n}) + T_{i,j}^{n} + \\Delta t q\n          \\]\n        \n        - The stability condition requires: \\( (1 + \\beta^2) r \\leq \\frac{1}{2} \\).\n        \n        ### **Computational Domain and Parameters**\n        - The equation is solved on a rectangular domain: \\( x, y \\in [-1,1] \\).\n        - Boundary conditions: **Fixed at 0°C on all sides**.\n        - Source term:\n        \n          \\[\n          q(x,y) = Q_0 \\exp\\left(-\\frac{x^2 + y^2}{2\\sigma^2} \\right)\n          \\]\n        \n          where \\( \\sigma = 0.1 \\) and \\( Q_0 = 200°C/s \\).\n          \n        ### **Computational Domain and Parameters**\n        - Grid resolution: \\( nx = 41, ny = 41 \\) (41 points in the x and y directions).\n        - Maximum simulation time: \\( t_{max} = 3 \\) seconds.\n        - Thermal diffusivity coefficient: \\( \\alpha = 1 \\).\n        - Grid spacing relationships:\n          - \\( \\beta = \\frac{dx}{dy} \\) (ratio of grid spacing).\n          - \\( r = \\frac{r}{1 + \\beta^2} \\) (adjusted stability parameter).\n        - Time step size:\n          - \\( dt = r \\cdot \\frac{dx^2}{\\alpha} \\).\n          \n        ### **Tasks**\n        1. Implement the **Explicit Method** to solve the **2D unsteady heat equation**.\n        2. Use a structured grid with uniform spacing.\n        3. Apply **Dirichlet boundary conditions**.\n        4. Visualize the temperature evolution.\n        \n        ### **Requirements**\n        - Use **NumPy** for array computations.\n        - Use **Matplotlib** for visualization.\n        - Save the computed solution in `.npy` format.\n        \n        **Return only the Python code that implements this solution.**\n    ",
        "2D_Steady_Heat_Equation_Jac": "\n    You are given the **steady two-dimensional heat equation**, which models heat distribution over a rectangular domain:\n\n    \\[\n    \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = 0\n    \\]\n\n    ### **Computational Domain**\n    The equation is solved in a **rectangular domain** with spatial coordinates:\n    - \\( x \\in [0, 5] \\), \\( y \\in [0, 4] \\)\n    \n    The domain is discretized using **finite difference methods** with a structured uniform grid:\n    - Grid spacing in the \\( x \\)-direction: \\( \\Delta x = 0.05 \\)\n    - Grid spacing in the \\( y \\)-direction: \\( \\Delta y = 0.05 \\)\n    \n    The number of grid points in each direction is computed as:\n    - Number of grid points in the \\( x \\)-direction: \\( n_x = \frac{5.0}{0.05} + 1 = 101 \\)\n    - Number of grid points in the \\( y \\)-direction: \\( n_y = \frac{4.0}{0.05} + 1 = 81 \\)\n    \n    Thus, the total grid consists of a uniform grid of **101 points** in the \\( x \\)-direction and **81 points** in the \\( y \\)-direction.\n\n    ### **Boundary Conditions**\n    The temperature values along the boundaries of the domain are fixed:\n    - **Left boundary (AB)**: \\( T = 10^\\circ C \\)\n    - **Top boundary (CD)**: \\( T = 0^\\circ C \\)\n    - **Right boundary (EF)**: \\( T = 40^\\circ C \\)\n    - **Bottom boundary (G)**: \\( T = 20^\\circ C \\)\n\n    ### **Numerical Methods**\n    Solve the steady-state heat equation usingthe following iterative methods:\n\n     Jacobi Method**  \n    - Update the temperature at each grid point using the average of its four neighboring points:\n      \\[\n      T_{i,j}^{k+1} = \\frac{T_{i+1,j}^{k} + T_{i-1,j}^{k} + \\beta^2 (T_{i,j+1}^{k} + T_{i,j-1}^{k})}{2(1 + \\beta^2)}\n      \\]\n      where \\( \\beta \\) is the grid aspect ratio \\( \\beta = \\frac{\\Delta x}{\\Delta y} \\).\n\n    ### **Tasks**\n    1. Implement the selected iterative method (Jacobi, Gauss-Seidel, or SOR) for solving the **2D steady heat equation**.\n    2. Discretize the computational domain using a uniform structured grid.\n    3. Apply the given **Dirichlet boundary conditions**.\n    4. Iterate until convergence, using a stopping criterion based on **residual reduction**.\n    5. Visualize the **steady-state temperature distribution** as a contour plot.\n\n    ### **Requirements**\n    - Use **NumPy** for matrix computations.\n    - Use **Matplotlib** to generate contour plots of the temperature field.\n    - Save the final computed temperature field \\( T(x, y) \\) as a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Inviscid_Burgers_FOU": "\n    You are given the **two-dimensional inviscid Burgers' equation**, which governs nonlinear convection of a velocity field in two spatial dimensions:\n\n    \\[\n    \\frac{\\partial \\mathbf{U}}{\\partial t} + \\mathbf{U} \\frac{\\partial \\mathbf{U}}{\\partial x} = 0\n    \\]\n\n    where:\n\n    \\[\n    \\mathbf{U} = \\begin{bmatrix} u \\\\ v \\end{bmatrix}, \\quad\n    \\mathbf{x} = \\begin{bmatrix} x \\\\ y \\end{bmatrix}\n    \\]\n\n    This system consists of two coupled nonlinear PDEs:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} + v \\frac{\\partial u}{\\partial y} = 0\n    \\]\n    \\[\n    \\frac{\\partial v}{\\partial t} + u \\frac{\\partial v}{\\partial x} + v \\frac{\\partial v}{\\partial y} = 0\n    \\]\n\n    ### **Objective**\n    Solve this equation numerically using the **First-Order Upwind Method**.\n\n    ### **Numerical Method**\n    - Use **forward differencing** for the time derivative.\n    - Use **backward differencing** for the spatial derivatives.\n    - The numerical scheme is given by:\n\n      \\[\n      \\frac{u_{i,j}^{n+1} - u_{i,j}^{n}}{\\Delta t} + u_{i,j}^{n} \\frac{u_{i,j}^{n} - u_{i-1,j}^{n}}{\\Delta x} + v_{i,j}^{n} \\frac{u_{i,j}^{n} - u_{i,j-1}^{n}}{\\Delta y} = 0\n      \\]\n\n      \\[\n      \\frac{v_{i,j}^{n+1} - v_{i,j}^{n}}{\\Delta t} + u_{i,j}^{n} \\frac{v_{i,j}^{n} - v_{i-1,j}^{n}}{\\Delta x} + v_{i,j}^{n} \\frac{v_{i,j}^{n} - v_{i,j-1}^{n}}{\\Delta y} = 0\n      \\]\n    ### **Initial Condition:**\n    The initial condition is defined using a **hat function**, where the velocity components \\( u(x,y) \\) and \\( v(x,y) \\) are initialized to **1** everywhere in the domain, \n    except in the region \\( 0.5 \\leq x \\leq 1 \\) and \\( 0.5 \\leq y \\leq 1 \\), where they are set to **2**.\n    \n    ### **Boundary Conditions:**\n    The velocity components \\( u(x,y) \\) and \\( v(x,y) \\) are set to **1** on all boundaries of the domain. \n    This represents **Dirichlet boundary conditions**, ensuring that the velocity remains fixed at 1 along the edges:\n    - **Top boundary** (\\( y = \\max \\)): \\( u = 1 \\), \\( v = 1 \\)\n    - **Bottom boundary** (\\( y = \\min \\)): \\( u = 1 \\), \\( v = 1 \\)\n    - **Left boundary** (\\( x = \\min \\)): \\( u = 1 \\), \\( v = 1 \\)\n    - **Right boundary** (\\( x = \\max \\)): \\( u = 1 \\), \\( v = 1 \\)\n    \n    ### **Computational Domain and Parameters:**\n    - The equation is solved over a **square domain** with spatial extent:\n      - \\( x \\in [0, 2] \\), \\( y \\in [0, 2] \\)\n    - The **grid resolution** is:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 151 \\)\n      - Number of grid points in \\( y \\)-direction: \\( ny = 151 \\)\n      - Spatial step sizes: \n        - \\( dx = \frac{L_x}{nx - 1} \\)\n        - \\( dy = \frac{L_y}{ny - 1} \\)\n    - **Time-stepping parameters:**\n      - Number of time steps: \\( nt = 300 \\)\n      - Stability parameter: \\( \\sigma = 0.2 \\)\n      - Time step:  \n        \\[\n        dt = \\sigma \\cdot \frac{\\min(dx, dy)}{2}\n        \\]\n\n    \n    ### **Tasks**\n    1. Implement the First-Order Upwind Method for solving the **2D Inviscid Burgers' equation**.\n    2. Use a structured grid with uniform spacing.\n    4. Simulate the velocity field evolution over time.\n    5. Visualize the computed **velocity field** using quiver plots.\n\n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Ensure **numerical stability** by choosing an appropriate time step based on the CFL condition.\n    - Save the final velocity field (u, v) in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "Fully_Developed_Turbulent_Channel_Flow_SA": "\n    You are tasked with solving a **fully-developed turbulent flow in a channel** using the **Reynolds-Averaged Navier-Stokes (RANS) equations** \n    and the **Spalart-Allmaras (SA) turbulence model**. The goal is to numerically compute the velocity profile using the **finite difference method (FDM)** and \n    solve the resulting system of equations.\n    ---\n    \n    ### **Governing Equation**\n    The RANS equation for this problem simplifies to:\n    \n    \\[\n    \frac{d}{dy} \\left( (\\mu + \\mu_t) \frac{d\bar{u}}{dy} \right) = -1.\n    \\]\n    \n    where:\n    - \\( \\mu \\) is the molecular viscosity.\n    - \\( \\mu_t \\) is the turbulent eddy viscosity (computed using the Spalart-Allmaras turbulence model).\n    - The effective viscosity is defined as \\( \\mu_{\text{eff}} = \\mu + \\mu_t \\).\n    \n    By applying the product rule, we rewrite it as:\n    \n    \\[\n    \\left[ \frac{d\\mu_{\text{eff}}}{dy} \frac{d}{dy} + \\mu_{\text{eff}} \frac{d^2}{dy^2} \right] u = -1.\n    \\]\n    \n    This can be expressed as a **linear system**:\n    \n    \\[\n    A u = b\n    \\]\n    \n    which will be solved numerically.\n    \n    ---\n    \n    ### **Turbulence Model: Spalart-Allmaras**\n    Implement the **Spalart-Allmaras turbulence model**, which consists of a transport equation for an eddy viscosity-like variable \\( \tilde{\nu} \\):\n\n    \\[\n    0 = c_{b1} \\hat{S} \tilde{\nu} - c_{w1} f_w \\left( \frac{\tilde{\nu}}{y} \right)^2 + \frac{1}{c_{b3}} \frac{d}{dy} \\left[ \\left( \nu + \tilde{\nu} \right) \frac{d \tilde{\nu}}{dy} \right] + \frac{c_{b2}}{c_{b3}} \\left( \frac{d \tilde{\nu}}{dy} \right)^2\n    \\]\n\n    where the eddy viscosity is given by:\n\n    \\[\n    \\mu_t = \rho \tilde{\nu} f_{\nu 1}\n    \\]\n\n    with:\n\n    \\[\n    f_{\nu 1} = \frac{\\chi^3}{\\chi^3 + c_{\nu 1}^3}, \\quad \\chi = \frac{\tilde{\nu}}{\nu}\n    \\]\n\n    and the constants:\n\n    \\[\n    c_{v1} = 7.1, \\quad c_{b1} = 0.1355, \\quad c_{b2} = 0.622, \\quad c_{b3} = \frac{2}{3}\n    \\]\n\n    \\[\n    c_{w1} = \frac{c_{b1}}{\\kappa^2} + \frac{1.0 + c_{b2}}{c_{b3}}, \\quad c_{\nu 2} = 0.3, \\quad c_{\nu 3} = 2.0, \\quad \\kappa = 0.41\n    \\]\n\n    ---\n    \n    ### **Tasks**\n    #### **1️⃣ Generate a Non-Uniform Mesh**\n    - Use a **MESH class** to compute **y-direction mesh points** and **finite difference matrices**:\n      - \\( n = 100 \\): Number of mesh points.\n      - \\( H = 2 \\): Channel height.\n      - **Cluster mesh points near the walls** using an appropriate stretching function.\n    - Implement the **MESH class**, including:\n      - \\( y \\) coordinates.\n      - First derivative matrix \\( d/dy \\).\n      - Second derivative matrix \\( d^2/dy^2 \\).\n    \n    #### **2️⃣ Compute Effective Viscosity**\n    - Solve the **Spalart-Allmaras model** for \\( \tilde{\nu} \\) and compute \\( \\mu_t \\).\n    \n    #### **3️⃣ Discretize the Governing Equation Using Finite Difference Method**\n    - Use **central difference discretization** for \\( d/dy \\) and \\( d^2/dy^2 \\).\n    \n    - Formulate the **linear system** \\( A u = b \\).\n    \n    #### **4️⃣ Solve the Linear System**\n    - Solve the system using:\n      - **Direct solvers** (e.g., LU decomposition).\n      - **Under-relaxation iterative solvers** (if needed).\n    \n    #### **5️⃣ Plot the Velocity Profile**\n    - Plot the velocity distribution \\( u(y) \\).\n    - Compare the **turbulent velocity profile** to a **laminar parabolic profile**.\n    \n    ### **User-Defined Inputs**\n    - Reynolds number based on friction velocity: \\( Re_\\tau = 395 \\)\n    - Density: \\( \\rho = 1.0 \\)\n    - Dynamic viscosity: \\( \\mu = \\frac{1}{Re_\\tau} \\)\n    ---\n    \n    ### **Requirements**\n    - Implement the solution in **Python**.\n    - Use **NumPy** for numerical operations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed velocity profile in `.npy` format.\n    - Structure the code modularly, including:\n      - A `Mesh` class for grid generation.\n      - A function to compute turbulent viscosity.\n      - A function to solve the linear system.\n    ---\n    \n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Burgers_Equation": "\n    You are given the **two-dimensional Burgers' equations**, which describe nonlinear convection and diffusion processes in fluid dynamics.\n\n    ### **Governing Equations**\n    The 2D Burgers' equations are expressed as:\n\n    \\[\n    \begin{align*}\n    \frac{\\partial u}{\\partial t} + u \frac{\\partial u}{\\partial x} + v \frac{\\partial u}{\\partial y} &= \nu \\left( \frac{\\partial^2 u}{\\partial x^2} + \frac{\\partial^2 u}{\\partial y^2} \right) \\\n    \frac{\\partial v}{\\partial t} + u \frac{\\partial v}{\\partial x} + v \frac{\\partial v}{\\partial y} &= \nu \\left( \frac{\\partial^2 v}{\\partial x^2} + \frac{\\partial^2 v}{\\partial y^2} \right)\n    \\end{align*}\n    \\]\n\n    where:\n    - \\( u(x,y,t) \\) and \\( v(x,y,t) \\) are the velocity components in the \\( x \\) and \\( y \\) directions, respectively.\n    - \\( nu \\) is the kinematic viscosity.\n\n    ### **Computational Domain**\n    - **Spatial domain:** \\( x \\) and \\( y \\) both range from 0 to 2.\n    - **Grid parameters:**\n      - Number of grid points in each direction: \\( n_x = n_y = 41 \\).\n      - Grid spacing: \\( \\Delta x = \\Delta y = \frac{2}{n_x - 1} \\).\n    - **Temporal domain:**\n    - number of time steps: nt = 120\n    - sigma = .0009\n    - nu = 0.01\n    - dt = sigma * dx * dy / nu\n\n    ### **Initial and Boundary Conditions**\n    - **Initial condition:** Both \\( u \\) and \\( v \\) are initialized to 1 throughout the domain, except in the region \\( 0.5 \\leq x, y \\leq 1 \\), where they are set to 2.\n    - **Boundary conditions:** All boundaries are subject to Dirichlet conditions with \\( u = 1 \\) and \\( v = 1 \\).\n\n    ### **Numerical Method**\n    - **Time integration:** Utilize the **Explicit Euler Method**.\n    - **Spatial discretization:** Apply **second-order central differences** for the spatial derivatives.\n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Set the domain size, grid resolution, time step, and viscosity.\n    2. **Initialize Variables:**\n       - Create 2D arrays for \\( u \\) and \\( v \\) with the specified initial conditions.\n    3. **Time Integration Loop:**\n       - For each time step until \\( t_{\text{final}} \\):\n         - Compute the temporary arrays \\( u_{\text{temp}} \\) and \\( v_{\text{temp}} \\) using the current values of \\( u \\) and \\( v \\).\n         - Update \\( u \\) and \\( v \\) using the Explicit Euler formula:\n         - Apply boundary conditions to maintain \\( u = 1 \\) and \\( v = 1 \\) at the domain boundaries.\n    4. **Visualization:**\n       - Generate surface plots of \\( u \\) and \\( v \\) at selected time intervals to observe the evolution of the velocity fields.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for plotting and visualization.\n    - Save the final velocity fields \\( u \\) and \\( v \\) in `.npy` files.\n    - avoid use this fig.gca(projection='3d') need to use fig.add_subplot(111, projection='3d')\n\n    **Return only the Python code that implements this solution.**\n    ",
        "1D_Linear_Convection_explicit_euler": "\n    You are given the **one-dimensional linear convection equation**, which models wave propagation with convection and damping:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = \\epsilon \\frac{\\partial^2 u}{\\partial x^2}\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( c \\) is the convection speed\n    - \\( \\epsilon \\) is a damping factor.\n\n    ### **Computational Domain**\n    - Solve the equation in a **periodic domain**:  \n      \\[\n      x \\in (-5, 5)\n      \\]\n    - The **initial condition** is given by:  \n      \\[\n      u_0 = e^{-x^2}\n      \\]\n    - Consider two cases:  \n      - **Undamped case**: \\( \\epsilon = 0 \\)  \n      - **Damped case**: \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    ### **Numerical Method**\n    - Use the **Explicit Euler Method** for **time discretization**.  \n    - Apply **2nd-order central differences** for **spatial discretization** of the derivatives.  \n    - Ensure numerical stability by choosing an appropriate time step.\n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Spatial domain: \\( x \\in (-5,5) \\)  \n       - Number of grid points: \\( N_x = 101 \\)  \n       - Time step: \\( \\Delta t \\) determined using CFL condition  \n       - Convection speed: \\( c = 1 \\)  \n       - Damping factor: \\( \\epsilon = 0 \\) or \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    2. **Discretize the Domain:**\n       - Spatial grid: \\( x = \\{x_0, x_1, ..., x_{N_x-1}\\} \\)  \n       - Time steps: \\( t = \\{t_0, t_1, ..., t_{N_t-1}\\} \\)  \n\n    3. **Initialize Variables:**\n       - Set initial wave profile \\( u(x,0) = e^{-x^2} \\).  \n\n    4. **Time Integration using Explicit Euler Method:**\n       - For each time step:\n         - Compute the spatial derivatives using **central difference scheme**.  \n         - Update \\( u(x,t) \\) using the **Explicit Euler Method**.  \n         - Apply **periodic boundary conditions**.  \n\n    5. **Visualization:**\n       - Plot the **wave profile** at different time steps.  \n       - Compare the **damped** and **undamped** cases.  \n\n    ### **Expected Output**\n    The simulation should capture and visualize the following:  \n    - **Wave propagation over time**.  \n    - **Comparison between damped and undamped cases**.  \n    - **Final wave profile at \\( t = T \\)**.  \n\n    ### **Requirements**\n    - Use **NumPy** for numerical operations.  \n    - Use **Matplotlib** for visualization.  \n    - Save the computed solution in a `.npy` file.  \n\n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Navier_Stokes_Cavity": "\n    You are given the **two-dimensional incompressible Navier-Stokes equations**, which describe the motion of a viscous fluid in a square cavity:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} + v \\frac{\\partial u}{\\partial y} = -\\frac{1}{\\rho} \\frac{\\partial p}{\\partial x} + \\nu \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\n    \\]\n\n    \\[\n    \\frac{\\partial v}{\\partial t} + u \\frac{\\partial v}{\\partial x} + v \\frac{\\partial v}{\\partial y} = -\\frac{1}{\\rho} \\frac{\\partial p}{\\partial y} + \\nu \\left( \\frac{\\partial^2 v}{\\partial x^2} + \\frac{\\partial^2 v}{\\partial y^2} \\right)\n    \\]\n\n    \\[\n    \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = -\\rho \\left( \\frac{\\partial u}{\\partial x} \\frac{\\partial u}{\\partial x} + 2 \\frac{\\partial u}{\\partial y} \\frac{\\partial v}{\\partial x} + \\frac{\\partial v}{\\partial y} \\frac{\\partial v}{\\partial y} \\right)\n    \\]\n\n    ### **Objective**\n    Solve the **2D cavity flow problem** numerically using the **finite difference method (FDM)**.\n\n    ### **Numerical Method**\n    - Discretize the momentum and pressure equations using finite difference schemes.\n    - Solve for velocity components \\( u \\) and \\( v \\) using an explicit time-stepping method.\n    - Solve for pressure \\( p \\) using an iterative solver.\n\n    ### **Initial Condition**\n    The velocity and pressure fields are initialized to **zero** everywhere:\n\n    \\[\n    u, v, p = 0\n    \\]\n\n    ### **Boundary Conditions**\n    - **Top boundary (Lid-driven motion)**:  \n      - \\( u = 1 \\) at \\( y = 2 \\)  \n      - \\( v = 0 \\) at \\( y = 2 \\)\n    - **Other boundaries (no-slip walls)**:  \n      - \\( u = 0 \\), \\( v = 0 \\)  \n    - **Pressure boundary conditions**:\n      - \\( \\frac{\\partial p}{\\partial y} = 0 \\) at \\( y = 0 \\)  \n      - \\( p = 0 \\) at \\( y = 2 \\)  \n      - \\( \\frac{\\partial p}{\\partial x} = 0 \\) at \\( x = 0, 2 \\)\n\n    ### **Computational Domain and Parameters**\n    - Solve in a **square cavity** with:  \n      - \\( x \\in [0,2] \\), \\( y \\in [0,2] \\)\n    - Grid resolution:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 51\\)  \n      - Number of grid points in \\( y \\)-direction: \\( ny = 51\\)  \n    - Time-stepping:\n      - Number of time steps: \\( nt = 500\\)  \n      - Time step size: \\( \\Delta t = 0.001\\)  \n    ### **Fluid Properties**\n    - The fluid density is set to **\\( \\rho = 1 \\)**.\n    - The kinematic viscosity is set to **\\( \\nu = 0.1 \\)**.\n\n    ### **Tasks**\n    1. Implement the **finite difference method (FDM)** for solving the **2D incompressible Navier-Stokes equations**.\n    2. Use a **structured grid** with uniform spacing.\n    3. Iterate over time and solve for \\( u, v, p \\).\n    4. Visualize the **velocity field (quiver plot)** and **pressure distribution (contour plot)**.\n\n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Ensure **numerical stability** by choosing an appropriate time step based on the CFL condition.\n    - Save the computed velocity \\( u, v \\) and pressure \\( p \\) in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Inviscid_Burgers_MK": "\n    You are given the **two-dimensional inviscid Burgers' equation**, which governs nonlinear convection of a velocity field in two spatial dimensions:\n    \n    \\[\n    \\frac{\\partial \\mathbf{U}}{\\partial t} + \\mathbf{U} \\frac{\\partial \\mathbf{U}}{\\partial x} = 0\n    \\]\n    \n    where:\n    \n    \\[\n    \\mathbf{U} = \\begin{bmatrix} u \\\\ v \\end{bmatrix}, \\quad\n    \\mathbf{x} = \\begin{bmatrix} x \\\\ y \\end{bmatrix}\n    \\]\n    \n    This system consists of two coupled nonlinear PDEs:\n    \n    \\[\n    \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} + v \\frac{\\partial u}{\\partial y} = 0\n    \\]\n    \\[\n    \\frac{\\partial v}{\\partial t} + u \\frac{\\partial v}{\\partial x} + v \\frac{\\partial v}{\\partial y} = 0\n    \\]\n    \n    ### **Objective**\n    Solve this equation numerically using the **First-Order Upwind Method**.\n    \n    ### **Numerical Method**\n    - Use **forward differencing** for the time derivative.\n    - Use **backward differencing** for the spatial derivatives.\n    - The numerical scheme is given by:\n    \n      \\[\n      \\frac{u_{i,j}^{n+1} - u_{i,j}^{n}}{\\Delta t} + u_{i,j}^{n} \\frac{u_{i,j}^{n} - u_{i-1,j}^{n}}{\\Delta x} + v_{i,j}^{n} \\frac{u_{i,j}^{n} - u_{i,j-1}^{n}}{\\Delta y} = 0\n      \\]\n    \n      \\[\n      \\frac{v_{i,j}^{n+1} - v_{i,j}^{n}}{\\Delta t} + u_{i,j}^{n} \\frac{v_{i,j}^{n} - v_{i-1,j}^{n}}{\\Delta x} + v_{i,j}^{n} \\frac{v_{i,j}^{n} - v_{i,j-1}^{n}}{\\Delta y} = 0\n      \\]\n    ### **Initial Condition:**\n    The initial condition is defined using a **hat function**, where the velocity components \\( u(x,y) \\) and \\( v(x,y) \\) are initialized to **1** everywhere in the domain, \n    except in the region \\( 0.5 \\leq x \\leq 1 \\) and \\( 0.5 \\leq y \\leq 1 \\), where they are set to **2**.\n    \n    ### **Boundary Conditions:**\n    The velocity components \\( u(x,y) \\) and \\( v(x,y) \\) are set to **1** on all boundaries of the domain. \n    This represents **Dirichlet boundary conditions**, ensuring that the velocity remains fixed at 1 along the edges:\n    - **Top boundary** (\\( y = \\max \\)): \\( u = 1 \\), \\( v = 1 \\)\n    - **Bottom boundary** (\\( y = \\min \\)): \\( u = 1 \\), \\( v = 1 \\)\n    - **Left boundary** (\\( x = \\min \\)): \\( u = 1 \\), \\( v = 1 \\)\n    - **Right boundary** (\\( x = \\max \\)): \\( u = 1 \\), \\( v = 1 \\)\n    \n    ### **Computational Domain and Parameters:**\n    - The equation is solved over a **square domain** with spatial extent:\n      - \\( x \\in [0, 2] \\), \\( y \\in [0, 2] \\)\n    - The **grid resolution** is:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 151 \\)\n      - Number of grid points in \\( y \\)-direction: \\( ny = 151 \\)\n      - Spatial step sizes: \n        - \\( dx = \frac{L_x}{nx - 1} \\)\n        - \\( dy = \frac{L_y}{ny - 1} \\)\n    - **Time-stepping parameters:**\n      - Number of time steps: \\( nt = 300 \\)\n      - Stability parameter: \\( \\sigma = 0.2 \\)\n      - Time step:  \n        \\[\n        dt = \\sigma \\cdot \frac{\\min(dx, dy)}{2}\n        \\]\n    \n    \n    ### **Tasks**\n    1. Implement the F**MacCormack Method** for solving the **2D Inviscid Burgers' equation**.\n    2. Use a structured grid with uniform spacing.\n    4. Simulate the velocity field evolution over time.\n    5. Visualize the computed **velocity field** using quiver plots.\n    \n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Ensure **numerical stability** by choosing an appropriate time step based on the CFL condition.\n    - Save the final velocity field (u, v) in `.npy` format.\n    \n    **Return only the Python code that implements this solution.**\n",
        "1D_Diffusion": "You are given the **one-dimensional diffusion equation**, a fundamental PDE that models **diffusive transport**:\n\n\\[\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n\\]\n\nwhere:\n- \\( u(x,t) \\) represents the quantity being diffused (e.g., temperature, concentration),\n- \\( \\nu \\) is the diffusion coefficient,\n- \\( x \\) is the spatial coordinate,\n- \\( t \\) is time.\n\n### **Variable Declarations:**\n- Number of grid points in x: `nx = 41`\n- Number of time steps: `nt = 20`\n- Grid spacing: `dx = 2 / (nx - 1)`\n- Diffusion coefficient: `nu = 0.3`\n- sigma = 0.2\n- Time step: `dt = sigma * dx**2 / nu`\n\n### **Task:**\n1. **Numerically solve the diffusion equation** over a given spatial and temporal domain.\n2. Apply **Dirichlet boundary conditions**:\n   \\[\n   u(0) = 1, \\quad u(1) = 0\n   \\]\n3. Use the following **initial condition**:\n   - At \\( t = 0 \\), let \\( u(x, 0) = 2 \\) for \\( 0.5 \\leq x \\leq 1 \\), and \\( u = 1 \\) elsewhere.\n4. **Visualize the solution**:\n   - Generate plots showing how the field \\( u(x, t) \\) evolves over time.\n   - Show the final solution at \\( t = T \\).\n\n### **Requirements:**\n- Use an appropriate **finite difference scheme** for the numerical solution.\n- Ensure **stability and accuracy** by choosing an appropriate time step.\n- Save the computed solution in a `.npy` file.\n\n**Return only the Python code that implements this solution.**\n",
        "2D_Unsteady_Heat_Equation_ADI": "\n    You are given the **two-dimensional unsteady heat equation** with a source term:\n    \n    \\[\n    \\frac{\\partial T}{\\partial t} - \\alpha \\left( \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} \\right) = q(x, y, t).\n    \\]\n    \n    ### **Objective**\n    Solve the equation numerically using the **Alternating Direction Implicit (ADI) Method**.\n    \n    ### **Numerical Method**\n    - The ADI scheme solves the equation in **two steps**:\n      1. Solve implicitly in the **x-direction**, explicitly in the **y-direction**.\n      2. Solve implicitly in the **y-direction**, explicitly in the **x-direction**.\n    \n    - The intermediate step is given by:\n    \n      \\[\n      T_{i,j}^{n+1/2} = 0.5r (T_{i+1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i-1,j}^{n+1/2}) + 0.5\\beta^2 r (T_{i,j+1}^{n} - 2T_{i,j}^{n} + T_{i,j-1}^{n}) + T_{i,j}^{n} + 0.5 \\Delta t q\n      \\]\n    \n    - The second step solves for the next full time step:\n    \n      \\[\n      T_{i,j}^{n+1} = 0.5r (T_{i+1,j}^{n+1} - 2T_{i,j}^{n+1} + T_{i-1,j}^{n+1}) + 0.5\\beta^2 r (T_{i,j+1}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i,j-1}^{n+1/2}) + T_{i,j}^{n+1/2} + 0.5 \\Delta t q\n      \\]\n    \n    - The ADI scheme is **unconditionally stable** and allows larger time steps.\n    \n    ### **Computational Domain and Parameters**\n    - The equation is solved on a rectangular domain: \\( x, y \\in [-1,1] \\).\n    - Boundary conditions: **Fixed at 0°C on all sides**.\n    - Source term:\n    \n      \\[\n      q(x,y) = Q_0 \\exp\\left(-\\frac{x^2 + y^2}{2\\sigma^2} \\right)\n      \\]\n    \n    - \\( \\sigma = 0.1 \\), \\( Q_0 = 200°C/s \\).\n    \n    ### **Computational Domain and Parameters**\n    - Grid resolution: \\( nx = 41, ny = 41 \\) (41 points in the x and y directions).\n    - Maximum simulation time: \\( t_{max} = 3 \\) seconds.\n    - Thermal diffusivity coefficient: \\( \\alpha = 1 \\).\n    - Grid spacing relationships:\n      - \\( \\beta = \\frac{dx}{dy} \\) (ratio of grid spacing).\n      - \\( r = \\frac{r}{1 + \\beta^2} \\) (adjusted stability parameter).\n    - Time step size:\n      - \\( dt = r \\cdot \\frac{dx^2}{\\alpha} \\).\n      \n    ### **Tasks**\n    1. Implement the **ADI Method**.\n    2. Use a structured grid with uniform spacing.\n    3. Apply **Dirichlet boundary conditions**.\n    4. Visualize the temperature evolution.\n    \n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed solution in `.npy` format.\n    \n    **Return only the Python code that implements this solution.**\n    ",
        "1D_Linear_Convection_rk": "\n    You are given the **one-dimensional linear convection equation**, which models wave propagation with convection and damping:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = \\epsilon \\frac{\\partial^2 u}{\\partial x^2}\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( c \\) is the convection speed,\n    - \\( \\epsilon \\) is a damping factor.\n\n    ### **Computational Domain**\n    - Solve the equation in a **periodic domain**:  \n      \\[\n      x \\in (-5, 5)\n      \\]\n    - The **initial condition** is given by:  \n      \\[\n      u_0 = e^{-x^2}\n      \\]\n    - Consider two cases:  \n      - **Undamped case**: \\( \\epsilon = 0 \\)  \n      - **Damped case**: \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    ### **Numerical Method**\n    - Use the **4th-order Runge-Kutta (RK4) Method** for **time discretization**.  \n    - Apply **2nd-order central differences** for **spatial discretization** of the derivatives.  \n    - Ensure numerical stability by choosing an appropriate time step.  \n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Spatial domain: \\( x \\in (-5,5) \\)  \n       - Number of grid points: \\( N_x = 101 \\)  \n       - Time step: \\( \\Delta t \\) determined using CFL condition  \n       - Convection speed: \\( c = 1 \\)  \n       - Damping factor: \\( \\epsilon = 0 \\) or \\( \\epsilon = 5 \\times 10^{-4} \\)  \n\n    2. **Discretize the Domain:**\n       - Spatial grid: \\( x = \\{x_0, x_1, ..., x_{N_x-1}\\} \\)  \n       - Time steps: \\( t = \\{t_0, t_1, ..., t_{N_t-1}\\} \\)  \n\n    3. **Initialize Variables:**\n       - Set initial wave profile \\( u(x,0) = e^{-x^2} \\).  \n\n    4. **Time Integration using Runge-Kutta Method:**\n       - Compute four intermediate slopes:\n         - \\( k_1 = f(t_n, u^n) \\)\n         - \\( k_2 = f(t_n + \\frac{\\Delta t}{2}, u^n + \\frac{\\Delta t}{2} k_1) \\)\n         - \\( k_3 = f(t_n + \\frac{\\Delta t}{2}, u^n + \\frac{\\Delta t}{2} k_2) \\)\n         - \\( k_4 = f(t_n + \\Delta t, u^n + \\Delta t k_3) \\)\n       - Update the solution using:\n         \\[\n         u^{n+1} = u^n + \\frac{\\Delta t}{6} \\left[ k_1 + 2k_2 + 2k_3 + k_4 \\right]\n         \\]\n       - Apply **periodic boundary conditions**.  \n\n    5. **Visualization:**\n       - Plot the **wave profile** at different time steps.  \n       - Compare the **damped** and **undamped** cases.  \n\n    ### **Expected Output**\n    The simulation should capture and visualize the following:  \n    - **Wave propagation over time**.  \n    - **Comparison between damped and undamped cases**.  \n    - **Final wave profile at \\( t = T \\)**.  \n\n    ### **Requirements**\n    - Use **NumPy** for numerical operations.  \n    - Use **Matplotlib** for visualization.  \n    - Save the computed solution in a `.npy` file.  \n\n    **Return only the Python code that implements this solution.**\n    ",
        "1D_Nonlinear_Convection_Lax": "\n    You are given the **one-dimensional nonlinear convection equation**, a fundamental PDE that models **advection**:\n\n    \\[\n    \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0\n    \\]\n\n    where:\n    - \\( u(x,t) \\) represents the wave amplitude,\n    - \\( x \\) is the spatial coordinate,\n    - \\( t \\) is time.\n\n    ### **Computational Domain**\n    - Solve the equation in a periodic domain \\( x \\in [0, 2\\pi] \\)\n    - The initial condition is given by:\n      \\[\n      u(x,0) = \\sin(x) + 0.5 \\sin(0.5x)\n      \\]\n    - The domain has **periodic boundary conditions**.\n    \n    ### Choose parameters\n    - CFL number: `nu = 0.5`\n    - Time step: `dt = 0.01`\n    - Maximum number of time steps: `T = 500`\n    - Space step: `dx = dt / nu`\n\n    ### **Numerical Method**\n    - Use the **Lax Method**, which replaces the time-centered term with the average of adjacent nodes:\n      \\[\n      u^{n+1}_j = \\frac{u^n_{j+1} + u^n_{j-1}}{2} - \\frac{\\Delta t}{2\\Delta x} (F^n_{j+1} - F^n_{j-1})\n      \\]\n    - Choose an appropriate time step \\( \\Delta t = 0.1 \\) to ensure numerical stability.\n\n    ### **Tasks**\n    1. Implement the Lax method to update \\( u(x,t) \\).\n    2. Apply periodic boundary conditions.\n    3. Simulate wave propagation over time.\n    4. Plot the solution and observe numerical dissipation effects.\n\n    ### **Requirements**\n    - Use NumPy for numerical operations.\n    - Use Matplotlib to visualize the results.\n    - Save the computed solution in a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Unsteady_Heat_Equation_DF": "\n    You are given the **two-dimensional unsteady heat equation** with a source term:\n    \n    \\[\n    \\frac{\\partial T}{\\partial t} - \\alpha \\left( \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} \\right) = q(x, y, t).\n    \\]\n    \n    ### **Objective**\n    Solve the equation numerically using the **DuFort-Frankel Method**.\n    \n    ### **Numerical Method**\n    - Use a **centered difference** for the time derivative.\n    - Use a **central difference** for the spatial derivatives.\n    - The DuFort-Frankel scheme is given by:\n    \n      \\[\n      T_{i,j}^{n+1} = \\frac{2r (T_{i+1,j}^{n} + T_{i-1,j}^{n}) + 2\\beta^2 r (T_{i,j+1}^{n} + T_{i,j-1}^{n}) + T_{i,j}^{n-1} + 2 \\Delta t q}\n      {1 + 2r + 2\\beta^2 r}\n      \\]\n    \n    - The method is **unconditionally stable**.\n    \n    ### **Computational Domain and Parameters**\n    - The equation is solved on a rectangular domain: \\( x, y \\in [-1,1] \\).\n    - Boundary conditions: **Fixed at 0°C on all sides**.\n    - Source term:\n    \n      \\[\n      q(x,y) = Q_0 \\exp\\left(-\\frac{x^2 + y^2}{2\\sigma^2} \\right)\n      \\]\n    \n    - \\( \\sigma = 0.1 \\), \\( Q_0 = 200°C/s \\).\n    \n    ### **Computational Domain and Parameters**\n    - Grid resolution: \\( nx = 41, ny = 41 \\) (41 points in the x and y directions).\n    - Maximum simulation time: \\( t_{max} = 3 \\) seconds.\n    - Thermal diffusivity coefficient: \\( \\alpha = 1 \\).\n    - Grid spacing relationships:\n      - \\( \\beta = \\frac{dx}{dy} \\) (ratio of grid spacing).\n      - \\( r = \\frac{r}{1 + \\beta^2} \\) (adjusted stability parameter).\n    - Time step size:\n      - \\( dt = r \\cdot \\frac{dx^2}{\\alpha} \\).\n          \n    ### **Tasks**\n    1. Implement the **DuFort-Frankel Method**.\n    2. Use a structured grid with uniform spacing.\n    3. Apply **Dirichlet boundary conditions**.\n    4. Visualize the temperature evolution.\n    \n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed solution in `.npy` format.\n    \n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Convection": "\n    You are tasked with solving the **two-dimensional nonlinear convection equations**, which model the transport of quantities in a fluid flow.\n\n    ### **Governing Equations**\n    The 2D nonlinear convection equations are given by:\n\n    \\[\n    \begin{align*}\n    \frac{\\partial u}{\\partial t} + u \frac{\\partial u}{\\partial x} + v \frac{\\partial u}{\\partial y} &= 0 \\\n    \frac{\\partial v}{\\partial t} + u \frac{\\partial v}{\\partial x} + v \frac{\\partial v}{\\partial y} &= 0\n    \\end{align*}\n    \\]\n\n    where:\n    - \\( u(x,y,t) \\) and \\( v(x,y,t) \\) are the velocity components in the \\( x \\) and \\( y \\) directions, respectively.\n\n    ### **Computational Domain**\n    - **Spatial domain:** \\( x \\) and \\( y \\) both range from 0 to 2.\n    - **Grid parameters:**\n      - Number of grid points in each direction: \\( n_x = n_y = 101 \\).\n      - Grid spacing: \\( \\Delta x = \\Delta y = \frac{2}{n_x - 1} \\).\n    - **Temporal domain:**\n    - number of time steps: nt = 80\n    - sigma = 0.2\n    - dt = sigma * dx\n\n    ### **Initial and Boundary Conditions**\n    - **Initial condition:** Both \\( u \\) and \\( v \\) are initialized to 1 throughout the domain, except in the region \\( 0.5 \\leq x, y \\leq 1 \\), where they are set to 2.\n    - **Boundary conditions:** All boundaries are subject to Dirichlet conditions with \\( u = 1 \\) and \\( v = 1 \\).\n\n    ### **Numerical Method**\n    - **Time integration:** Utilize the **Explicit Euler Method**.\n    - **Spatial discretization:** Apply **first-order upwind differences** for the convection terms.\n\n    ### **Implementation Steps**\n    1. **Define Parameters:**\n       - Set the domain size, grid resolution, time step, and total simulation time.\n    2. **Initialize Variables:**\n       - Create 2D arrays for \\( u \\) and \\( v \\) with the specified initial conditions.\n    3. **Time Integration Loop:**\n       - For each time step until \\( t_{\text{final}} \\):\n         - Compute the temporary arrays \\( u_{\text{temp}} \\) and \\( v_{\text{temp}} \\) using the current values of \\( u \\) and \\( v \\).\n         - Update \\( u \\) and \\( v \\) using the Explicit Euler formula:\n           \\[\n           \begin{align*}\n           u^{n+1}_{i,j} &= u^n_{i,j} - \\Delta t \\left( u_{i,j} \frac{u_{i,j} - u_{i-1,j}}{\\Delta x} + v_{i,j} \frac{u_{i,j} - u_{i,j-1}}{\\Delta y} \right) \\\n           v^{n+1}_{i,j} &= v^n_{i,j} - \\Delta t \\left( u_{i,j} \frac{v_{i,j} - v_{i-1,j}}{\\Delta x} + v_{i,j} \frac{v_{i,j} - v_{i,j-1}}{\\Delta y} \right)\n           \\end{align*}\n           \\]\n         - Apply boundary conditions to maintain \\( u = 1 \\) and \\( v = 1 \\) at the domain boundaries.\n    4. **Visualization:**\n       - Generate surface plots of \\( u \\) and \\( v \\) at selected time intervals to observe the evolution of the velocity fields.\n\n    ### **Requirements**\n    - Use **NumPy** for numerical computations.\n    - Use **Matplotlib** for plotting and visualization.\n    - Save the final velocity fields \\( u \\) and \\( v \\) in `.npy` files.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Poisson_Equation": "\n    You are given the **two-dimensional Poisson equation**, which introduces a source term to the Laplace equation:\n\n    \\[\n    \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = b\n    \\]\n\n    Unlike the Laplace equation, the Poisson equation includes a finite source term that affects the solution, acting to \"relax\" the initial sources in the field.\n\n    ### **Objective**\n    Solve the **2D Poisson equation** numerically using an iterative finite-difference approach.\n\n    ### **Numerical Method**\n    - Discretize the equation using **second-order central differencing** for both spatial derivatives.\n    - The discretized form of the equation is:\n\n      \\[\n      \\frac{p_{i+1,j}^{n} - 2p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n} - 2p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta y^2} = b_{i,j}^{n}\n      \\]\n\n    - Rearranging for \\( p_{i,j}^{n} \\), the update formula is:\n\n      \\[\n      p_{i,j}^{n} = \\frac{(p_{i+1,j}^{n} + p_{i-1,j}^{n}) \\Delta y^2 + (p_{i,j+1}^{n} + p_{i,j-1}^{n}) \\Delta x^2 - b_{i,j}^{n} \\Delta x^2 \\Delta y^2}{2(\\Delta x^2 + \\Delta y^2)}\n      \\]\n\n    ### **Initial Condition:**\n    - Assume an **initial state** of \\( p = 0 \\) everywhere.\n\n    ### **Boundary Conditions:**\n    - **Dirichlet boundary conditions**:\n      - \\( p = 0 \\) at \\( x = 0, 2 \\) and \\( y = 0, 1 \\).\n\n    ### **Source Term (RHS \\( b_{i,j} \\)):**\n    - The source term consists of **two initial spikes** inside the domain:\n      - \\( b_{i,j} = 100 \\) at \\( i = \\frac{1}{4} nx, j = \\frac{1}{4} ny \\).\n      - \\( b_{i,j} = -100 \\) at \\( i = \\frac{3}{4} nx, j = \\frac{3}{4} ny \\).\n      - \\( b_{i,j} = 0 \\) elsewhere.\n\n    ### **Computational Domain and Parameters:**\n    - The equation is solved over a **rectangular grid** with:\n      - Number of grid points in \\( x \\)-direction: \\( nx = 50\\)\n      - Number of grid points in \\( y \\)-direction: \\( ny = 50\\)\n      - Spatial step sizes: \n        - \\( dx = \\frac{L_x}{nx - 1} \\)\n        - \\( dy = \\frac{L_y}{ny - 1} \\)\n\n    ### **Tasks**\n    1. Implement the **2D Poisson solver** using an iterative approach.\n    2. Discretize the domain using a structured grid with uniform spacing.\n    3. Apply the specified boundary and source conditions.\n    4. Iterate until convergence is reached.\n    5. Visualize the computed **pressure field** using contour plots.\n\n    ### **Requirements**\n    - Use **NumPy** for array computations.\n    - Use **Matplotlib** for visualization.\n    - Ensure **numerical stability** with appropriate stopping criteria.\n    - Save the final pressure field \\( p \\) in `.npy` format.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "2D_Steady_Heat_Equation_SOR": "\n    You are given the **steady two-dimensional heat equation**, which models heat distribution over a rectangular domain:\n\n    \\[\n    \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = 0\n    \\]\n\n    ### **Computational Domain**\n    The equation is solved in a **rectangular domain** with spatial coordinates:\n    - \\( x \\in [0, 5] \\), \\( y \\in [0, 4] \\)\n    \n    The domain is discretized using **finite difference methods** with a structured uniform grid:\n    - Grid spacing in the \\( x \\)-direction: \\( \\Delta x = 0.05 \\)\n    - Grid spacing in the \\( y \\)-direction: \\( \\Delta y = 0.05 \\)\n    \n    The number of grid points in each direction is computed as:\n    - Number of grid points in the \\( x \\)-direction: \\( n_x = \frac{5.0}{0.05} + 1 = 101 \\)\n    - Number of grid points in the \\( y \\)-direction: \\( n_y = \frac{4.0}{0.05} + 1 = 81 \\)\n    \n    Thus, the total grid consists of a uniform grid of **101 points** in the \\( x \\)-direction and **81 points** in the \\( y \\)-direction.\n\n    ### **Boundary Conditions**\n    The temperature values along the boundaries of the domain are fixed:\n    - **Left boundary (AB)**: \\( T = 10^\\circ C \\)\n    - **Top boundary (CD)**: \\( T = 0^\\circ C \\)\n    - **Right boundary (EF)**: \\( T = 40^\\circ C \\)\n    - **Bottom boundary (G)**: \\( T = 20^\\circ C \\)\n\n    ### **Numerical Methods**\n    Solve the steady-state heat equation usingthe following iterative methods:\n\n    Successive Over-Relaxation (SOR) Method**  \n    - A modified version of Gauss-Seidel with an **acceleration factor** \\( \\omega \\) to speed up convergence:\n      \\[\n      T_{i,j}^{k+1} = \\omega \\frac{T_{i+1,j}^{k} + T_{i-1,j}^{k} + \\beta^2 (T_{i,j+1}^{k+1} + T_{i,j-1}^{k+1})}{2(1 + \\beta^2)} + (1 - \\omega)T_{i,j}^{k}\n      \\]\n      where \\( 1 < \\omega < 2 \\) (For \\( \\omega = 1 \\), this reduces to the Gauss-Seidel method).\n\n    ### **Tasks**\n    1. Implement the selected iterative method (Jacobi, Gauss-Seidel, or SOR) for solving the **2D steady heat equation**.\n    2. Discretize the computational domain using a uniform structured grid.\n    3. Apply the given **Dirichlet boundary conditions**.\n    4. Iterate until convergence, using a stopping criterion based on **residual reduction**.\n    5. Visualize the **steady-state temperature distribution** as a contour plot.\n\n    ### **Requirements**\n    - Use **NumPy** for matrix computations.\n    - Use **Matplotlib** to generate contour plots of the temperature field.\n    - Save the final computed temperature field \\( T(x, y) \\) as a `.npy` file.\n\n    **Return only the Python code that implements this solution.**\n    ",
        "Fully_Developed_Turbulent_Channel_Flow_SST": "\n   You are tasked with solving a **fully-developed turbulent flow in a channel** using the **Reynolds-Averaged Navier-Stokes (RANS) equations** \n    and the **Menter Shear-Stress Transport (SST) turbulence model**. The goal is to numerically compute the velocity profile using the **finite difference method (FDM)** \n    and solve the resulting system of equations.\n    \n    ---\n    \n    ### **Governing Equations**\n    The RANS equation for this problem simplifies to:\n    \n    #### **Turbulent Kinetic Energy** \\( k \\):\n    \n    \\[\n    0 = P_k - \beta^* \rho k \\omega + \frac{d}{dy} \\left[ \\left( \\mu + \frac{\\mu_t}{\\sigma_k} \right) \frac{d k}{dy} \right]\n    \\]\n    \n    #### **Specific Turbulent Dissipation** \\( \\omega \\):\n    \n    \\[\n    0 = \frac{\rho P_k}{\\mu_t} - \beta \\omega^2 + \frac{d}{dy} \\left[ \\left( \\mu + \\mu_t \\omega \right) \frac{d \\omega}{dy} \right] + (1 - F_1) C_D k \\omega\n    \\]\n    \n    where:\n    - \\( P_k \\) is the turbulent production term.\n    - \\( \\mu_t \\) is the turbulent eddy viscosity.\n    - \\( F_1 \\) is a blending function.\n    - \\( C_D \\) is a constant.\n    \n    #### **Eddy Viscosity** \\( \\mu_t \\):\n    \n    \\[\n    \\mu_t = \rho k \\min \\left( \frac{1}{\\omega}, \frac{a_1}{\\|S\\| F_2} \right)\n    \\]\n    \n    where:\n    - \\( S \\) is the strain rate tensor.\n    - \\( F_2 \\) is another blending function.\n    - \\( a_1 \\) is a constant.\n    \n    ---\n    \n    ### **Tasks**\n    #### **1️⃣ Generate a Non-Uniform Mesh**\n    - Use a **MESH class** to compute **y-direction mesh points** and **finite difference matrices**:\n      - \\( n = 100 \\): Number of mesh points.\n      - \\( H = 2 \\): Channel height.\n      - **Cluster mesh points near the walls** using an appropriate stretching function.\n    - Implement the **MESH class**, including:\n      - \\( y \\) coordinates.\n      - First derivative matrix \\( d/dy \\).\n      - Second derivative matrix \\( d^2/dy^2 \\).\n    \n    #### **2️⃣ Compute Turbulent Kinetic Energy and Dissipation**\n    - Implement the **Menter SST model** to solve for \\( k \\) and \\( \\omega \\).\n    \n    #### **3️⃣ Discretize the Governing Equation Using Finite Difference Method**\n    - Use **central difference discretization** for \\( d/dy \\) and \\( d^2/dy^2 \\).\n    \n    - Formulate the **linear system** \\( A u = b \\).\n    \n    #### **4️⃣ Solve the Linear System**\n    - Solve the system using:\n      - **Direct solvers** (e.g., LU decomposition).\n      - **Under-relaxation iterative solvers** (if needed).\n    \n    #### **5️⃣ Plot the Velocity Profile**\n    - Plot the velocity distribution \\( u(y) \\).\n    - Compare the **turbulent velocity profile** to a **laminar parabolic profile**.\n    \n    ### **User-Defined Inputs**\n    - Reynolds number based on friction velocity: \\( Re_\\tau = 395 \\)\n    - Density: \\( \\rho = 1.0 \\)\n    - Dynamic viscosity: \\( \\mu = \\frac{1}{Re_\\tau} \\)\n    \n    ---\n    \n    ### **Requirements**\n    - Implement the solution in **Python**.\n    - Use **NumPy** for numerical operations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed velocity profile in `.npy` format.\n    - Structure the code modularly, including:\n      - A `Mesh` class for grid generation.\n      - A function to compute turbulent viscosity.\n      - A function to solve the linear system.\n    \n    ---\n    \n    **Return only the Python code that implements this solution.**\n    ",
        "Fully_Developed_Turbulent_Channel_Flow_V2F": "\n    You are tasked with solving a **fully-developed turbulent flow in a channel** using the **Reynolds-Averaged Navier-Stokes (RANS) equations** \n    and the **V2F turbulence model**. The goal is to numerically compute the velocity profile using the **finite difference method (FDM)** \n    and solve the resulting system of equations.\n    \n    ---\n    \n    ### **Governing Equations**\n    The RANS equation for this problem simplifies to:\n    \n    #### **Turbulent Kinetic Energy** \\( k \\):\n    \n    \\[\n    0 = P_k - \rho \\epsilon + \frac{d}{dy} \\left[ \\left( \\mu + \frac{\\mu_t}{\\sigma_k} \right) \frac{d k}{dy} \right]\n    \\]\n    \n    where \\( P_k \\) is the turbulent production term.\n    \n    #### **Turbulent Dissipation** \\( \\epsilon \\):\n    \n    \\[\n    0 = \frac{1}{T} \\left( C_{e1} P_k - C_{e2} \rho \\epsilon \right) + \frac{d}{dy} \\left[ \\left( \\mu + \frac{\\mu_t}{\\sigma_\\epsilon} \right) \frac{d \\epsilon}{dy} \right]\n    \\]\n    \n    #### **Wall-Normal Fluctuation Component** \\( v^2 \\):\n    \n    \\[\n    0 = \rho k f - 6 \rho v^2 \frac{\\epsilon}{k} + \frac{d}{dy} \\left[ \\left( \\mu + \frac{\\mu_t}{\\sigma_k} \right) \frac{d v^2}{dy} \right]\n    \\]\n    \n    #### **Elliptic Relaxation Equation** \\( f \\):\n    \n    \\[\n    L^2 \frac{d^2 f}{dy^2} - f = \frac{1}{T} \\left[ C_1 \\left( 6 - v^2 \right) - \frac{2}{3} \\left( C_1 - 1 \right) \right] - C_2 P_k\n    \\]\n    \n    where \\( L \\) is a characteristic length scale and \\( P_k \\) is the turbulent kinetic energy production term.\n    \n    #### **Eddy Viscosity** \\( \\mu_t \\):\n    \n    \\[\n    \\mu_t = C_\\mu \rho \\left( \frac{\\epsilon}{k} \right)^{1/2} T_t\n    \\]\n    \n    where:\n    - \\( C_\\mu \\) is a constant.\n    - \\( T_t \\) is the turbulent temperature.\n    \n    ---\n    \n    ### **Tasks**\n    #### **1️⃣ Generate a Non-Uniform Mesh**\n    - Use a **MESH class** to compute **y-direction mesh points** and **finite difference matrices**:\n      - \\( n = 100 \\): Number of mesh points.\n      - \\( H = 2 \\): Channel height.\n      - **Cluster mesh points near the walls** using an appropriate stretching function.\n    - Implement the **MESH class**, including:\n      - \\( y \\) coordinates.\n      - First derivative matrix \\( d/dy \\).\n      - Second derivative matrix \\( d^2/dy^2 \\).\n    \n    #### **2️⃣ Compute Turbulent Kinetic Energy and Dissipation**\n    - Implement the **V2F model** for computing \\( k \\), \\( \\epsilon \\), and \\( v^2 \\).\n    \n    #### **3️⃣ Discretize the Governing Equation Using Finite Difference Method**\n    - Use **central difference discretization** for \\( d/dy \\) and \\( d^2/dy^2 \\).\n    \n    - Formulate the **linear system** \\( A u = b \\).\n    \n    #### **4️⃣ Solve the Linear System**\n    - Solve the system using:\n      - **Direct solvers** (e.g., LU decomposition).\n      - **Under-relaxation iterative solvers** (if needed).\n    \n    #### **5️⃣ Plot the Velocity Profile**\n    - Plot the velocity distribution \\( u(y) \\).\n    - Compare the **turbulent velocity profile** to a **laminar parabolic profile**.\n    \n    ### **User-Defined Inputs**\n    - Reynolds number based on friction velocity: \\( Re_\\tau = 395 \\)\n    - Density: \\( \\rho = 1.0 \\)\n    - Dynamic viscosity: \\( \\mu = \\frac{1}{Re_\\tau} \\)\n    \n    ---\n    \n    ### **Requirements**\n    - Implement the solution in **Python**.\n    - Use **NumPy** for numerical operations.\n    - Use **Matplotlib** for visualization.\n    - Save the computed velocity profile in `.npy` format.\n    - Structure the code modularly, including:\n      - A `Mesh` class for grid generation.\n      - A function to compute turbulent viscosity.\n      - A function to solve the linear system.\n    \n    ---\n    \n    **Return only the Python code that implements this solution.**\n    "
    }
}
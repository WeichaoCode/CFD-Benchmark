#!/usr/bin/env python3
import numpy as np

# Domain parameters
Lx = 2.0
Ly = 1.0
nx = 41  # number of grid points in x
ny = 21  # number of grid points in y

dx = Lx / (nx - 1)
dy = Ly / (ny - 1)

# Create grid
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)

# Initialize pressure field and source term
p = np.zeros((ny, nx))
b = np.zeros((ny, nx))

# Set source term: b = 100 at (Lx/4, Ly/4) and b = -100 at (3Lx/4, 3Ly/4)
x1 = Lx / 4.0
y1 = Ly / 4.0
x2 = 3 * Lx / 4.0
y2 = 3 * Ly / 4.0

# Find the nearest grid indices for the specified coordinates
i1 = int(round(x1 / dx))
j1 = int(round(y1 / dy))
i2 = int(round(x2 / dx))
j2 = int(round(y2 / dy))
b[j1, i1] = 100.0
b[j2, i2] = -100.0

# Parameters for iterative solver
pn = np.empty_like(p)
error = 1.0
tolerance = 1e-6

# Precompute coefficients for the finite difference Laplacian
dx2 = dx * dx
dy2 = dy * dy
denom = 2*(dx2 + dy2)

# Solve the Poisson equation using the Gauss-Seidel method
while error > tolerance:
    pn[:] = p[:]
    for j in range(1, ny-1):
        for i in range(1, nx-1):
            p[j, i] = ((pn[j, i+1] + p[j, i-1]) * dy2 +
                       (pn[j+1, i] + p[j-1, i]) * dx2 -
                       b[j, i] * dx2 * dy2) / denom

    # Enforce Dirichlet boundary conditions: p = 0 at the boundaries
    p[0, :] = 0
    p[-1, :] = 0
    p[:, 0] = 0
    p[:, -1] = 0

    error = np.max(np.abs(p - pn))

# Save final solution in 'p.npy'
np.save("p.npy", p)
Sure, here is a Python implementation which should fulfill your requirements.

```python
import numpy as np
import matplotlib.pyplot as plt

def linear_convection(nx, L=2.0, c=1.0, dt=0.025, nt=20):
    dx = L / (nx - 1)
    
    # set up grid
    x = np.linspace(0, L, nx)
    u = np.ones(nx)
    
    # set initial condition
    mask = np.where(np.logical_and(x >= 0.5, x <= 1))
    u[mask] = 2

    # initialize a temporary array
    un = np.ones(nx)
    
    for n in range(nt):
        un = u.copy()
        for i in range(1, nx - 1):
            # apply FDM on the convection equation
            u[i] = un[i] - c * dt / dx * (un[i] - un[i-1])
            
    return u, x

# define grid size
nx = 81

for nt in [20, 50, 100]:
    u, x = linear_convection(nx, nt=nt)
    plt.plot(x, u, label="nt = {}".format(nt))

plt.xlabel('Grid Spacing [x]')
plt.ylabel('Wave Amplitude [u]')
plt.title('1D Linear Convection')
plt.legend()
plt.show()
```

In this code, we solve the 1D linear convection equation in Python using finite differences method and plot the wave evolution for different time steps. The model parameters (e.g., time steps, grid spacing, wave speed) can be changed as required. Make sure the CFL condition is met to avoid any numerical instability. Itâ€™s usually safer to put dt=0.025, but feel free to play with it.
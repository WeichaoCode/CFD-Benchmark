Below is the Python code to solve the given 2D Laplace equation using the finite difference method with the specified boundary conditions. The code uses the Jacobi iterative method to find the steady-state solution and saves the final solution as a `.npy` file.

```python
import numpy as np

# Parameters
nx, ny = 31, 31
dx = 2 / (nx - 1)
dy = 1 / (ny - 1)
tolerance = 1e-5
max_iterations = 10000

# Initialize the potential field
p = np.zeros((ny, nx))

# Boundary conditions
p[:, 0] = 0  # Left boundary
p[:, -1] = np.linspace(0, 1, ny)  # Right boundary

# Iterative solver using Jacobi method
def solve_laplace(p, dx, dy, tolerance, max_iterations):
    pn = np.empty_like(p)
    for it in range(max_iterations):
        pn[:] = p[:]
        # Update the potential field
        p[1:-1, 1:-1] = ((dy**2 * (pn[1:-1, 2:] + pn[1:-1, :-2]) +
                          dx**2 * (pn[2:, 1:-1] + pn[:-2, 1:-1])) /
                         (2 * (dx**2 + dy**2)))

        # Neumann boundary conditions (top and bottom)
        p[0, :] = p[1, :]  # Top boundary
        p[-1, :] = p[-2, :]  # Bottom boundary

        # Check for convergence
        if np.max(np.abs(p - pn)) < tolerance:
            print(f'Converged after {it} iterations')
            break
    else:
        print('Did not converge within the maximum number of iterations')
    return p

# Solve the PDE
p_final = solve_laplace(p, dx, dy, tolerance, max_iterations)

# Save the final solution
np.save('solution.npy', p_final)
```

### Explanation:
- **Initialization**: The potential field `p` is initialized to zero, and boundary conditions are applied.
- **Boundary Conditions**:
  - Left boundary (`x=0`): `p = 0`
  - Right boundary (`x=2`): `p = y`, which is linearly spaced from 0 to 1.
  - Top and bottom boundaries (`y=0` and `y=1`): Neumann condition, implemented by setting the boundary values equal to their adjacent interior values.
- **Jacobi Iterative Method**: The method iteratively updates the potential field using the 5-point stencil until convergence is achieved or the maximum number of iterations is reached.
- **Convergence Check**: The iteration stops when the maximum change between iterations is below the specified tolerance.
- **Output**: The final solution is saved as a `.npy` file using NumPy.

This code will solve the problem and save the final potential field as a 2D NumPy array in `solution.npy`.
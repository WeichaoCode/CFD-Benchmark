Here is a simple Python script that implements the given problem.

```Python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
H, ny = 1.0, 50      # Channel height and number of points
mu = 1.0e-3          # Kinematic viscosity
mu_t = 2.0e-3        # Eddy viscosity

# Discretization
dy = H / (ny - 1)
y = np.linspace(0.0, H, num=ny)

# Coefficient matrix
A = np.zeros((ny, ny))
np.fill_diagonal(A[:, 1:], mu + mu_t)
np.fill_diagonal(A[1:, :], -(2.0 * mu + mu_t))
np.fill_diagonal(A[:-1, 1:], mu + mu_t)
A *= (1.0 / dy**2)

# Right-hand side
b = -np.ones(ny)

# Boundary conditions
A[0, :] = 0.0
A[0, 0] = 1.0
b[0] = 0.0
A[-1, :] = 0.0
A[-1, -1] = 1.0
b[-1] = 0.0

# Solve for velocity
u = np.linalg.solve(A, b)

# Plot of velocity profile
plt.figure(figsize=(6.0, 8.0))
plt.grid()
plt.xlabel('u')
plt.ylabel('y')
plt.plot(u, y, color='C0', linestyle='-', linewidth=2)
plt.xlim(u.min(), u.max())
plt.show()
```

This script first defines the parameters and discretizes the vertical direction with the appropriate number of points (`ny`). A coefficient matrix `A` is built using the finite difference approximation. The `i`th row of `A` corresponds to the `i`th grid point, and the `j`th column corresponds to the `j`th grid point. The right-hand side vector `b` is a numpy array of size `ny` with all elements equal to `-1`. 

Boundary conditions are imposed as per given conditions. The function `numpy.linalg.solve` solves the linear system `Au = b` for velocity `u`. The velocity profile `u(y)` is plotted against `y`. The `plt.xlim()` function sets the x-axis limits according to the computed velocity profile. The resulting plot shows the fully-developed turbulent flow velocity profile in the channel. 

You'll need to adjust the parameters according to your specific problem e.g., the kinematic viscosity and the eddy viscosity. Mathematical functions to describe the eddy viscosity across the channel could also be used. The channel height `H` and the number of points `ny` are the other parameters you might want to tune.
Here is a Python code that implements the solution:

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm

# Define the grid parameters
nx, ny = 41, 41
dx = 2.0 / (nx - 1)
dy = 2.0 / (ny - 1)
beta = dx / dy
alpha = 1.0
r = 0.25 / (1 + beta**2)
dt = r * dx**2 / alpha
t_max = 3.0
nt = int(t_max / dt)

# Define the source term
sigma = 0.1
Q0 = 200.0
x = np.linspace(-1, 1, nx)
y = np.linspace(-1, 1, ny)
X, Y = np.meshgrid(x, y)
q = Q0 * np.exp(-(X**2 + Y**2) / (2 * sigma**2))

# Initialize the solution array
T = np.zeros((nx, ny))

# Time-stepping loop
for n in range(nt):
    Tn = T.copy()
    T[1:-1, 1:-1] = (r * (Tn[2:, 1:-1] - 2*Tn[1:-1, 1:-1] + Tn[:-2, 1:-1]) +
                     beta**2 * r * (Tn[1:-1, 2:] - 2*Tn[1:-1, 1:-1] + Tn[1:-1, :-2]) +
                     Tn[1:-1, 1:-1] + dt * q[1:-1, 1:-1])

# Save the solution in .npy format
np.save('solution.npy', T)

# Visualize the solution
plt.figure(figsize=(8, 6))
plt.contourf(X, Y, T, cmap=cm.viridis)
plt.colorbar(label='Temperature [Â°C]')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Temperature distribution at t = {:.2f} s'.format(t_max))
plt.show()
```

This code first defines the grid parameters and the source term. It then initializes the solution array and enters a time-stepping loop where the explicit method is applied. After the loop, the solution is saved in `.npy` format and visualized using a contour plot.
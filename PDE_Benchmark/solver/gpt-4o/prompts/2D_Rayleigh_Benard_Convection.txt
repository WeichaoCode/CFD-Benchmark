```python
import numpy as np
from scipy.fftpack import fft2, ifft2
from numpy.fft import fftfreq

# Parameters
Lx, Lz = 4.0, 1.0
Nx, Nz = 128, 64
dx, dz = Lx / Nx, Lz / Nz
x = np.linspace(0, Lx, Nx, endpoint=False)
z = np.linspace(0, Lz, Nz, endpoint=False)
X, Z = np.meshgrid(x, z, indexing='ij')

Ra = 2e6
Pr = 1.0
nu = (Ra / Pr) ** -0.5
kappa = (Ra * Pr) ** -0.5

dt = 0.01
t_final = 50.0
nt = int(t_final / dt)

# Initial conditions
u = np.zeros((Nx, Nz))
w = np.zeros((Nx, Nz))
b = Lz - Z + 0.01 * np.random.rand(Nx, Nz)

# Wavenumbers for spectral methods
kx = 2 * np.pi * fftfreq(Nx, d=dx)
kz = 2 * np.pi * fftfreq(Nz, d=dz)
KX, KZ = np.meshgrid(kx, kz, indexing='ij')
K2 = KX**2 + KZ**2
K2[0, 0] = 1.0  # Avoid division by zero

# Time-stepping loop
for n in range(nt):
    # Fourier transform of fields
    u_hat = fft2(u)
    w_hat = fft2(w)
    b_hat = fft2(b)

    # Compute nonlinear terms in physical space
    u_x = np.real(ifft2(1j * KX * u_hat))
    u_z = np.real(ifft2(1j * KZ * u_hat))
    w_x = np.real(ifft2(1j * KX * w_hat))
    w_z = np.real(ifft2(1j * KZ * w_hat))
    b_x = np.real(ifft2(1j * KX * b_hat))
    b_z = np.real(ifft2(1j * KZ * b_hat))

    # Nonlinear terms
    nonlinear_u = u * u_x + w * u_z
    nonlinear_w = u * w_x + w * w_z + b
    nonlinear_b = u * b_x + w * b_z

    # Fourier transform of nonlinear terms
    nonlinear_u_hat = fft2(nonlinear_u)
    nonlinear_w_hat = fft2(nonlinear_w)
    nonlinear_b_hat = fft2(nonlinear_b)

    # Update velocity and buoyancy in Fourier space
    u_hat_new = (u_hat - dt * (nonlinear_u_hat + 1j * KX * fft2(np.real(ifft2(1j * KX * u_hat)) + np.real(ifft2(1j * KZ * w_hat)))) - dt * nu * K2 * u_hat) / (1 + dt * nu * K2)
    w_hat_new = (w_hat - dt * (nonlinear_w_hat + 1j * KZ * fft2(np.real(ifft2(1j * KX * u_hat)) + np.real(ifft2(1j * KZ * w_hat)))) - dt * nu * K2 * w_hat) / (1 + dt * nu * K2)
    b_hat_new = (b_hat - dt * nonlinear_b_hat - dt * kappa * K2 * b_hat) / (1 + dt * kappa * K2)

    # Update fields in physical space
    u = np.real(ifft2(u_hat_new))
    w = np.real(ifft2(w_hat_new))
    b = np.real(ifft2(b_hat_new))

    # Apply boundary conditions
    u[:, 0] = u[:, -1] = 0
    w[:, 0] = w[:, -1] = 0
    b[:, 0] = Lz
    b[:, -1] = 0

    # Ensure numerical stability by clipping values
    u = np.clip(u, -1e3, 1e3)
    w = np.clip(w, -1e3, 1e3)
    b = np.clip(b, -1e3, 1e3)

# Save final results
np.save('u.npy', u)
np.save('w.npy', w)
np.save('b.npy', b)
```
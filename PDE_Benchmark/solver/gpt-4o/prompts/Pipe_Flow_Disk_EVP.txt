```python
import numpy as np
from scipy.sparse import diags, kron, eye, csc_matrix, lil_matrix
from scipy.sparse.linalg import eigs

# Parameters
Re = 1e4
s = 0  # Eigenvalue (temporal growth/decay rate)
k_z = 1  # Axial wave number

# Domain discretization
Nr = 100  # Number of radial points
Nphi = 100  # Number of azimuthal points
r = np.linspace(0, 1, Nr)
phi = np.linspace(0, 2 * np.pi, Nphi)
dr = r[1] - r[0]
dphi = phi[1] - phi[0]

# Background flow
w0 = 1 - r**2

# Construct differential operators
D2r = diags([1, -2, 1], [-1, 0, 1], shape=(Nr, Nr)) / dr**2
D2r = D2r.tolil()
D2r[0, 0] = D2r[-1, -1] = 1 / dr**2  # Dirichlet BC at r=0 and r=1

D2phi = diags([1, -2, 1], [-1, 0, 1], shape=(Nphi, Nphi)) / dphi**2
D2phi = D2phi.tolil()
D2phi[0, -1] = D2phi[-1, 0] = 1 / dphi**2  # Periodic BC in phi

# Laplacian operator in cylindrical coordinates
Laplacian = kron(eye(Nphi), D2r) + kron(D2phi, eye(Nr))

# Convert Laplacian to CSC format for efficient arithmetic operations
Laplacian = csc_matrix(Laplacian)

# Construct the linearized Navier-Stokes operator
A = lil_matrix((Nr * Nphi, Nr * Nphi), dtype=complex)
B = lil_matrix((Nr * Nphi, Nr * Nphi), dtype=complex)

# Fill the matrices A and B
for i in range(Nr):
    for j in range(Nphi):
        idx = i * Nphi + j
        A[idx, idx] = s + w0[i] * 1j * k_z
        B[idx, idx] = -1 / Re

# Convert A and B to CSC format for eigenvalue computation
A = A.tocsc()
B = B.tocsc()

# Add Laplacian and k_z^2 to B
B = B.dot(Laplacian) - (k_z**2 / Re) * eye(Nr * Nphi)

# Solve the eigenvalue problem
eigenvalues, eigenvectors = eigs(A + B, k=1, which='LR')

# Extract the most unstable mode
u_mode = eigenvectors[:, 0].real
w_mode = eigenvectors[:, 0].imag

# Reshape to 2D arrays
u_mode_2d = u_mode.reshape((Nr, Nphi))
w_mode_2d = w_mode.reshape((Nr, Nphi))

# Save the results
np.save('u_mode.npy', u_mode_2d)
np.save('w_mode.npy', w_mode_2d)
```
```python
import numpy as np

# Grid parameters - further reduced for speed
Nr = 40
Ntheta = 48
r_min, r_max = 0.5, 10.0
dr = (r_max - r_min) / (Nr-1)
dtheta = 2*np.pi / Ntheta
r = np.linspace(r_min, r_max, Nr)
theta = np.linspace(0, 2*np.pi-dtheta, Ntheta)
r_grid, theta_grid = np.meshgrid(r, theta)

# Parameters
nu = 0.005
v_inf = 1.0
dt = 0.005
t_final = 1.0  # Reduced simulation time
n_steps = int(t_final/dt)

# Initialize fields
psi = np.zeros((Ntheta, Nr))
omega = np.zeros((Ntheta, Nr))
ur = np.zeros((Ntheta, Nr))
utheta = np.zeros((Ntheta, Nr))

# Set initial and boundary conditions
y = r_max * np.sin(theta)
psi[:,-1] = v_inf * y + 20
psi[:,0] = 20

def solve_poisson(omega, psi, max_iter=10):
    for _ in range(max_iter):
        for i in range(1, Ntheta-1):
            for j in range(1, Nr-1):
                r_val = r[j]
                psi[i,j] = ((psi[i+1,j] + psi[i-1,j])/(dtheta**2) + 
                           (psi[i,j+1]*(1 + dr/(2*r_val)) + 
                            psi[i,j-1]*(1 - dr/(2*r_val)))/dr**2 + 
                           r_val*omega[i,j]) / (2/dtheta**2 + 2/dr**2)
        
        psi[0,:] = psi[-1,:]
        psi[-1,:] = psi[0,:]
        
    return psi

# Main time loop
for n in range(n_steps):
    # Solve Poisson equation
    psi = solve_poisson(omega, psi)
    
    # Calculate velocities with vectorized operations
    ur[1:-1,1:-1] = np.clip((psi[2:,1:-1] - psi[:-2,1:-1])/(2*dtheta*r[None,1:-1]), -10, 10)
    utheta[1:-1,1:-1] = np.clip(-(psi[1:-1,2:] - psi[1:-1,:-2])/(2*dr), -10, 10)
    
    # Update vorticity
    omega_new = omega.copy()
    
    # Interior points
    for i in range(1, Ntheta-1):
        for j in range(1, Nr-1):
            r_val = r[j]
            
            # Central differences for diffusion
            d_r = (omega[i,j+1] - 2*omega[i,j] + omega[i,j-1])/dr**2
            d_theta = (omega[i+1,j] - 2*omega[i,j] + omega[i-1,j])/(r_val**2 * dtheta**2)
            
            # Upwind differences for advection
            if ur[i,j] > 0:
                d_omega_dr = (omega[i,j] - omega[i,j-1])/dr
            else:
                d_omega_dr = (omega[i,j+1] - omega[i,j])/dr
                
            if utheta[i,j] > 0:
                d_omega_dtheta = (omega[i,j] - omega[i-1,j])/(r_val*dtheta)
            else:
                d_omega_dtheta = (omega[i+1,j] - omega[i,j])/(r_val*dtheta)
            
            omega_new[i,j] = omega[i,j] + dt*(
                nu*(d_r + d_theta) - 
                ur[i,j]*d_omega_dr - 
                utheta[i,j]*d_omega_dtheta
            )
    
    # Apply boundary conditions
    omega_new[:,0] = 2*(psi[:,0] - psi[:,1])/dr**2
    omega_new[:,-1] = 0
    omega_new[0,:] = omega_new[-1,:]
    
    # Update with clipping to prevent instabilities
    omega = np.clip(omega_new, -100, 100)

# Save final solutions
np.save('psi.npy', psi)
np.save('omega.npy', omega)
np.save('ur.npy', ur)
np.save('utheta.npy', utheta)
```
Below is the complete Python code to solve the given 2D PDE problem using the MacCormack method. The code will compute the solution at the final time step and save it as a `.npy` file.

```python
import numpy as np

# Define the domain and grid parameters
nx, ny = 151, 151
nt = 300
x = np.linspace(0, 2, nx)
y = np.linspace(0, 2, ny)
dx = x[1] - x[0]
dy = y[1] - y[0]
sigma = 0.2
dt = sigma * min(dx, dy) / 2

# Initialize the velocity fields
u = np.ones((ny, nx))
v = np.ones((ny, nx))

# Set initial conditions
u[int(0.5 / dy):int(1 / dy + 1), int(0.5 / dx):int(1 / dx + 1)] = 2
v[int(0.5 / dy):int(1 / dy + 1), int(0.5 / dx):int(1 / dx + 1)] = 2

# MacCormack method
for n in range(nt):
    # Predictor step
    u_star = u.copy()
    v_star = v.copy()
    
    u_star[1:-1, 1:-1] = (u[1:-1, 1:-1] - dt * (
        u[1:-1, 1:-1] * (u[1:-1, 1:-1] - u[1:-1, :-2]) / dx +
        v[1:-1, 1:-1] * (u[1:-1, 1:-1] - u[:-2, 1:-1]) / dy))
    
    v_star[1:-1, 1:-1] = (v[1:-1, 1:-1] - dt * (
        u[1:-1, 1:-1] * (v[1:-1, 1:-1] - v[1:-1, :-2]) / dx +
        v[1:-1, 1:-1] * (v[1:-1, 1:-1] - v[:-2, 1:-1]) / dy))
    
    # Corrector step
    u[1:-1, 1:-1] = 0.5 * (u[1:-1, 1:-1] + u_star[1:-1, 1:-1] - dt * (
        u_star[1:-1, 1:-1] * (u_star[2:, 1:-1] - u_star[1:-1, 1:-1]) / dx +
        v_star[1:-1, 1:-1] * (u_star[1:-1, 2:] - u_star[1:-1, 1:-1]) / dy))
    
    v[1:-1, 1:-1] = 0.5 * (v[1:-1, 1:-1] + v_star[1:-1, 1:-1] - dt * (
        u_star[1:-1, 1:-1] * (v_star[2:, 1:-1] - v_star[1:-1, 1:-1]) / dx +
        v_star[1:-1, 1:-1] * (v_star[1:-1, 2:] - v_star[1:-1, 1:-1]) / dy))
    
    # Apply Dirichlet boundary conditions
    u[:, 0] = 1
    u[:, -1] = 1
    u[0, :] = 1
    u[-1, :] = 1
    
    v[:, 0] = 1
    v[:, -1] = 1
    v[0, :] = 1
    v[-1, :] = 1

# Save the final solution
np.save('final_solution_u.npy', u)
np.save('final_solution_v.npy', v)
```

This code initializes the velocity fields `u` and `v` with the given initial conditions, applies the MacCormack method for time-stepping, and enforces the Dirichlet boundary conditions at each step. Finally, it saves the final solution for both `u` and `v` as `.npy` files.
#!/usr/bin/env python3
import numpy as np

# Parameters
nx = 41
ny = 41
Lx = 2.0
Ly = 2.0
dx = Lx / (nx - 1)
dy = Ly / (ny - 1)
nt = 500      # number of time steps
nit = 50      # number of iterations for pressure Poisson solver per time step
dt = 0.001    # time step size
rho = 1.0
nu = 0.1
F = 1.0

# Create grid
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)

# Initialize variables: u, v, p (2D arrays, shape: (ny, nx))
u = np.zeros((ny, nx))
v = np.zeros((ny, nx))
p = np.zeros((ny, nx))

# Time-stepping loop
for n in range(nt):
    un = u.copy()
    vn = v.copy()
    pn = p.copy()

    # Compute derivatives using central differences and periodic in x.
    # For u-equation
    u_x = (np.roll(un, -1, axis=1) - np.roll(un, 1, axis=1)) / (2 * dx)
    u_y = (np.roll(un, -1, axis=0) - np.roll(un, 1, axis=0)) / (2 * dy)
    v_x = (np.roll(vn, -1, axis=1) - np.roll(vn, 1, axis=1)) / (2 * dx)
    v_y = (np.roll(vn, -1, axis=0) - np.roll(vn, 1, axis=0)) / (2 * dy)
    
    # Second derivatives for diffusion terms (using periodicity in x; for y boundaries, use interior differences)
    u_xx = (np.roll(un, -1, axis=1) - 2 * un + np.roll(un, 1, axis=1)) / (dx**2)
    u_yy = (np.roll(un, -1, axis=0) - 2 * un + np.roll(un, 1, axis=0)) / (dy**2)
    v_xx = (np.roll(vn, -1, axis=1) - 2 * vn + np.roll(vn, 1, axis=1)) / (dx**2)
    v_yy = (np.roll(vn, -1, axis=0) - 2 * vn + np.roll(vn, 1, axis=0)) / (dy**2)
    
    # Update u and v using explicit time stepping
    u = un + dt * (
        - un * u_x
        - vn * u_y
        - (np.roll(pn, -1, axis=1) - pn) / dx  # pressure gradient in x (periodic)
        + nu * (u_xx + u_yy)
        + F
    )
    v = vn + dt * (
        - un * v_x
        - vn * v_y
        - (np.roll(pn, -1, axis=0) - pn) / dy  # pressure gradient in y
        + nu * (v_xx + v_yy)
    )
    
    # Enforce boundary conditions for velocities:
    # Periodic in x (already satisfied by np.roll for interior points)
    # No-slip in y: u = 0, v = 0 at y = 0 and y = Ly
    u[0, :] = 0
    u[-1, :] = 0
    v[0, :] = 0
    v[-1, :] = 0

    # Pressure Poisson equation: solve for p with Neumann BC in y and periodic in x
    # The right-hand side based on the velocity gradients:
    b = -rho * (
          ((np.roll(u, -1, axis=1) - np.roll(u, 1, axis=1)) / (2 * dx))**2
        + 2 * ((np.roll(u, -1, axis=0) - np.roll(u, 1, axis=0)) / (2 * dy)) * ((np.roll(v, -1, axis=1) - np.roll(v, 1, axis=1)) / (2 * dx))
        + ((np.roll(v, -1, axis=0) - np.roll(v, 1, axis=0)) / (2 * dy))**2
    )
    
    for it in range(nit):
        p_old = p.copy()
        # Update pressure using Jacobi iteration for interior nodes
        p[1:-1,1:-1] = (((p_old[1:-1,2:] + p_old[1:-1,0:-2]) * dy**2 +
                          (p_old[2:,1:-1] + p_old[0:-2,1:-1]) * dx**2 -
                          b[1:-1,1:-1] * dx**2 * dy**2)
                         / (2 * (dx**2 + dy**2)))
                         
        # Enforce periodic boundary conditions in x for pressure
        p[:, 0] = p[:, -2]
        p[:, -1] = p[:, 1]
        
        # Enforce Neumann BC in y: dp/dy = 0 at y = 0 and y = Ly
        p[0, :] = p[1, :]
        p[-1, :] = p[-2, :]
    
# Save final solutions as .npy files (2D arrays)
np.save("u.npy", u)
np.save("v.npy", v)
np.save("p.npy", p)
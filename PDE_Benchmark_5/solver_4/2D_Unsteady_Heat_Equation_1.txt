Sure, let's start by importing the necessary libraries:

```Python
import numpy as np
import matplotlib.pyplot as plt
```

Let's define our computational domain, boundary conditions, and source term:

```Python
# Physical parameters
alpha = 1      # Thermal diffusivity
Q_0 = 200      # Heat source strength
sigma = 0.1    # Controls radial decay of heat source

# Domain
x_range = [-1, 1]
y_range = [-1, 1]
gx = 51    # Number of grid points in x-direction
gy = 51    # Number of grid points in y-direction

# Boundary conditions
T_boundary = 0    # Fixed temperature boundary condition

# Grid spacing
dx = (x_range[1] - x_range[0]) / (gx - 1)
dy = (y_range[1] - y_range[0]) / (gy - 1)

# Time settings
dt = 0.01             # Time step
tfinal = 2.0          # Simulation time

# Define grid
x_grid = np.linspace(x_range[0], x_range[1], gx)
y_grid = np.linspace(y_range[0], y_range[1], gy)

# Temperature field
T = np.full((gy, gx), T_boundary)
```

This sets up the domain, grid, initial condition, and boundary conditions. Now we need a function to evaluate the source term:

```Python
def source(x, y, t):
  """Return heat source term at location (x, y) and time t."""
  return Q_0 * np.exp(- (x**2 + y**2) / (2*sigma**2))
```

Now let's start the main time-stepping loop. For each time step, we update the temperature field using the finite difference method:

```Python
# Time-stepping loop
t = 0
while t < tfinal:

  # Copy current temperature field
  T_old = T.copy()

  # Update interior points
  for j in range(1, gy-1):
    for i in range(1, gx-1):

      # Central difference formula
      Txx = (T_old[j, i-1] - 2*T_old[j, i] + T_old[j, i+1]) / dx**2
      Tyy = (T_old[j-1, i] - 2*T_old[j, i] + T_old[j+1, i]) / dy**2
      
      # Update temperature
      T[j, i] = T_old[j, i] + dt * alpha * (Txx + Tyy) + source(x_grid[i], y_grid[j], t)

  # Update time
  t = t + dt
  

# Plot the solution as contour plot
plt.figure(figsize=(6, 6))
plt.contourf(x_grid, y_grid, T, levels=12)
plt.colorbar()
plt.title('Temperature Distribution')
plt.xlabel('x')
plt.ylabel('y')
plt.show()
```

This code calculates the temperature field for each time step, using central differences in time and space. The 'i and j' loops calculate the solution over the internal points (those not touching the boundary). We use the '.copy()' function to make sure we're always updating based on the original values from the start of the timestep (i.e. we use an explicit method). 

Please note this is a simple 2D heat equation solver with explicit scheme and may not be efficient for larger problems or for problems with complex geometries and boundary conditions. For such cases, consideration of more efficient methods or using advanced libraries/packages would be necessary.
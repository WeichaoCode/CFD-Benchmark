Sure, here is a corrected and simplified Python code to solve 2D unsteady heat conduction within a rectangular domain. I've added comments section wise to clarify what the code is doing:

```python

import numpy as np
import matplotlib.pyplot as plt

# Constants 
alpha = 0.01
Q0 = 200
sigma = 0.1
L = 1
W = 1
T_boundary = 0.
t_final = 0.5
CFL = 0.1

# Grid
N = 21
x = np.linspace(-L, L, N)
y = np.linspace(-W, W, N)
dx = x[1] - x[0]
dy = y[1] - y[0]
X, Y = np.meshgrid(x, y, indexing='ij')

# Time parameters
dt = CFL * min(dx, dy)**2 / (4 * alpha)
Nt = int(t_final / dt)

# Source term
q = Q0 * np.exp(-(X**2 + Y**2) / (2 * sigma**2))

# Initialize solution: Temperature array
T = np.zeros((N, N), dtype=float)
T_new = np.zeros((N, N), dtype=float)

# Set boundary conditions
T[:,:] = T_boundary
T_new[:,:] = T_boundary

# Main time-stepping loop
for t in range(1, Nt+1):
    # Calculate new temperatures
    T_new[1:-1, 1:-1] = T[1:-1, 1:-1] + dt*(
        alpha * ((T[:-2, 1:-1] - 2*T[1:-1, 1:-1] + T[2:, 1:-1])/dx**2 + 
                  (T[1:-1, :-2] - 2*T[1:-1, 1:-1] + T[1:-1, 2:])/dy**2) + q[1:-1, 1:-1])

    # Copy new temperature field to old one
    T[:, :] = T_new[:, :]

# Plotting
plt.figure(figsize=(8,6))
plt.contourf(X,Y,T,100,cmap='jet')
plt.title('2D Unsteady Heat Conduction', fontsize=15)
plt.xlabel('x', fontsize=12)
plt.ylabel('y', fontsize=12)
plt.colorbar(label='Temperature')
plt.show()

```
The code starts by setting up all the parameters for the problem: the input constants, the grid (both in space and time), and the heat source. It then initializes the temperature field, sets the boundary condition and finally enters the main time stepping loop. Here, at each time step, it uses central difference for spatial discretization and an explicit scheme for time discretization to calculate the new temperature field. 

Note that 'CFL' is a safety factor ensuring our time step is small enough for our solution to be stable. After each time step, it copies the newly calculated temperature field to the old temperature field, and moves on to the next time step. It runs these time steps until it hits the final time.

Finally, it generates a contour plot to visualize the temperature distribution.
{
    "prompts": {
        "1D_Linear_Convection": "\n    Solve the **1D Linear Convection** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, t) = exp(-t) * sin(\u03c0x)\n    \n    Write a **Python solver** `solve_1d_linear_convection` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202u/\u2202t + c \u2202u/\u2202x = f(x, t)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "1D_Nonlinear_Convection": "\n    Solve the **1D Nonlinear Convection** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, t) = exp(-t) * sin(\u03c0x)\n    \n    Write a **Python solver** `solve_1d_nonlinear_convection` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202u/\u2202t + u \u2202u/\u2202x = f(x, t)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "1D_Burgers_Equation": "\n    Solve the **1D Burgers Equation** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, t) = exp(-t) * sin(\u03c0x)\n    \n    Write a **Python solver** `solve_1d_burgers_equation` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202u/\u2202t + u \u2202u/\u2202x = \u03bd \u2202\u00b2u/\u2202x\u00b2 + f(x, t)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "1D_Diffusion": "\n    Solve the **1D Diffusion** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, t) = exp(-t) * sin(\u03c0x)\n    \n    Write a **Python solver** `solve_1d_diffusion` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202u/\u2202t = \u03bd \u2202\u00b2u/\u2202x\u00b2 + f(x, t)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "1D_Wave_Equation": "\n    Solve the **1D Wave Equation** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, t) = exp(-t) * sin(\u03c0x) * cos(t)\n    \n    Write a **Python solver** `solve_1d_wave_equation` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202\u00b2u/\u2202t\u00b2 = c\u00b2 \u2202\u00b2u/\u2202x\u00b2 + f(x, t)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "1D_Euler_Equations": "\n    Solve the **1D Euler Equations** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: \u03c1(x, t) = exp(-t) * sin(\u03c0x), u(x, t) = exp(-t) * cos(\u03c0x), p(x, t) = exp(-t) * (1 + sin(\u03c0x))\n    \n    Write a **Python solver** `solve_1d_euler_equations` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202\u03c1/\u2202t + \u2202(\u03c1u)/\u2202x = 0, \u2202(\u03c1u)/\u2202t + \u2202(\u03c1u\u00b2 + p)/\u2202x = 0, \u2202E/\u2202t + \u2202((E + p)u)/\u2202x = 0\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "1D_Kuramoto_Sivashinsky": "\n    Solve the **1D Kuramoto Sivashinsky** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, t) = exp(-t) * sin(\u03c0x)\n    \n    Write a **Python solver** `solve_1d_kuramoto_sivashinsky` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202u/\u2202t + \u2202\u00b2u/\u2202x\u00b2 + \u2202\u2074u/\u2202x\u2074 + (1/2)(\u2202u/\u2202x)\u00b2 = f(x, t)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "1D_Korteweg_de_Vries": "\n    Solve the **1D Korteweg de Vries** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, t) = exp(-t) * sin(\u03c0x)\n    \n    Write a **Python solver** `solve_1d_korteweg_de_vries` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202u/\u2202t + 6u \u2202u/\u2202x + \u2202\u00b3u/\u2202x\u00b3 = f(x, t)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "2D_Linear_Convection": "\n    Solve the **2D Linear Convection** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y)\n    \n    Write a **Python solver** `solve_2d_linear_convection` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202u/\u2202t + c_x \u2202u/\u2202x + c_y \u2202u/\u2202y = f(x, y, t)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "2D_Nonlinear_Convection": "\n    Solve the **2D Nonlinear Convection** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y), v(x, y, t) = exp(-t) * cos(\u03c0x) * cos(\u03c0y)\n    \n    Write a **Python solver** `solve_2d_nonlinear_convection` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202u/\u2202t + u \u2202u/\u2202x + v \u2202u/\u2202y = f(x, y, t), \u2202v/\u2202t + u \u2202v/\u2202x + v \u2202v/\u2202y = f_v(x, y, t)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "2D_Burgers_Equation": "\n    Solve the **2D Burgers Equation** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y), v(x, y, t) = exp(-t) * cos(\u03c0x) * cos(\u03c0y)\n    \n    Write a **Python solver** `solve_2d_burgers_equation` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202u/\u2202t + u \u2202u/\u2202x + v \u2202u/\u2202y = \u03bd (\u2202\u00b2u/\u2202x\u00b2 + \u2202\u00b2u/\u2202y\u00b2) + f_u(x, y, t), \u2202v/\u2202t + u \u2202v/\u2202x + v \u2202v/\u2202y = \u03bd (\u2202\u00b2v/\u2202x\u00b2 + \u2202\u00b2v/\u2202y\u00b2) + f_v(x, y, t)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "2D_Diffusion": "\n    Solve the **2D Diffusion** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y)\n    \n    Write a **Python solver** `solve_2d_diffusion` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202u/\u2202t = \u03b1 (\u2202\u00b2u/\u2202x\u00b2 + \u2202\u00b2u/\u2202y\u00b2) + f(x, y, t)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "2D_Wave_Equation": "\n    Solve the **2D Wave Equation** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y) * cos(t)\n    \n    Write a **Python solver** `solve_2d_wave_equation` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202\u00b2u/\u2202t\u00b2 = c\u00b2 (\u2202\u00b2u/\u2202x\u00b2 + \u2202\u00b2u/\u2202y\u00b2) + f(x, y, t)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "2D_Euler_Equations": "\n    Solve the **2D Euler Equations** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: \u03c1(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y), u(x, y, t) = exp(-t) * sin(\u03c0x) * cos(\u03c0y), v(x, y, t) = exp(-t) * cos(\u03c0x) * sin(\u03c0y), p(x, y, t) = exp(-t) * (1 + sin(\u03c0x) * sin(\u03c0y))\n    \n    Write a **Python solver** `solve_2d_euler_equations` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202\u03c1/\u2202t + \u2202(\u03c1u)/\u2202x + \u2202(\u03c1v)/\u2202y = 0, \u2202(\u03c1u)/\u2202t + \u2202(\u03c1u\u00b2 + p)/\u2202x + \u2202(\u03c1uv)/\u2202y = 0, \u2202(\u03c1v)/\u2202t + \u2202(\u03c1uv)/\u2202x + \u2202(\u03c1v\u00b2 + p)/\u2202y = 0, \u2202E/\u2202t + \u2202((E + p)u)/\u2202x + \u2202((E + p)v)/\u2202y = 0\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    ",
        "2D_Navier_Stokes": "\n    Solve the **2D Navier Stokes** using the given **Manufactured Solution (MMS)**:\n    \n        MMS: u(x, y, t) = exp(-t) * sin(\u03c0x) * sin(\u03c0y), v(x, y, t) = exp(-t) * cos(\u03c0x) * cos(\u03c0y), p(x, y, t) = exp(-t) * cos(\u03c0x) * cos(\u03c0y)\n    \n    Write a **Python solver** `solve_2d_navier_stokes` using an appropriate **Finite Difference Method (FDM)** to solve the PDE:\n    \n        \u2202u/\u2202t + u \u2202u/\u2202x + v \u2202u/\u2202y = -1/\u03c1 \u2202p/\u2202x + \u03bd (\u2202\u00b2u/\u2202x\u00b2 + \u2202\u00b2u/\u2202y\u00b2), \u2202v/\u2202t + u \u2202v/\u2202x + v \u2202v/\u2202y = -1/\u03c1 \u2202p/\u2202y + \u03bd (\u2202\u00b2v/\u2202x\u00b2 + \u2202\u00b2v/\u2202y\u00b2), \u2202\u00b2p/\u2202x\u00b2 + \u2202\u00b2p/\u2202y\u00b2 = -\u03c1 (\u2202u/\u2202x \u2202u/\u2202x + 2 \u2202u/\u2202y \u2202v/\u2202x + \u2202v/\u2202y \u2202v/\u2202y)\n    \n    Ensure numerical **stability** by choosing a suitable **time step** and **grid resolution**.\n    Hint 1:\n    - Use central differences for second derivatives  \n    - Use upwind schemes for advection to prevent numerical oscillations.\n    - Use an implicit scheme for stability when solving diffusion-dominated problems.\n    - If uncertain, search online for examples of Python solvers for similar PDEs and adapt the best numerical scheme.\n    \n    Hint 2: your can write the code follow the following steps\n    - step 1: define PARAMETERS, like grid points, time steps, final time, domain size and other parameters\n    - step 2: check CFL CONDITION, you can also use other method to ensure stable\n    - step 3: compute source term from MMS solution\n    - step 4: compute the initial and boundary conditions from MMS\n    - step 5: solve the PDE using FINITE DIFFERENCE\n    - step 6: compute exact solution for comparison\n    - step 7: error ana,lysis and plot numerical, exact solution and error.\n    "
    }
}
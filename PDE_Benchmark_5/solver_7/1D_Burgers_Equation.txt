The problem seems to be how the finite difference schemes are implemented on the equation, particularly in the dimensional consistency of the discretized scheme.

We can try to fix the error by correcting the index ranges for the discretization scheme.

Consider the proposed Python implementation:

```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
L = 2*np.pi
T = 1.0
nx = 100
nt = 100
nu = 0.07
dx = L / (nx - 1)
sigma = 0.1
dt = sigma * dx**2 / nu 

def initial_condition(nx, nu, dx):
    # Initializing the velocity profile according to the given initial condition
    x = np.linspace(0, L, nx)
    phi = np.exp(-x**2/(4*nu)) + np.exp(-(x-L)**2/(4*nu))
    d_phi = -0.5*x/nu*phi
    u = -2*nu * (d_phi / phi) + 4
    return u

def compute(u, nx, nt, nu, dt, dx):
    # Iteration via finite difference
    for n in range(nt):
        un = np.copy(u)
        for i in range(1, nx - 1):
            u[i] = un[i] + dt * (nu * (un[i+1] - 2*un[i] + un[i-1]) / dx**2 - un[i] * (un[i] - un[i-1]) / dx)
        u[0] = un[0] + dt * (nu * (un[1] - 2*un[0] + un[-2]) / dx**2 - un[0] * (un[0] - un[-1]) / dx)
        u[-1] = u[0]  
        
    return u

u = initial_condition(nx, nu, dx)

u = compute(u, nx, nt, nu, dt, dx)

# Plotting
x = np.linspace(0, L, nx)
plt.plot(x, u, label='Numerical solution')
plt.legend()
plt.xlabel('x')
plt.ylabel('u')
plt.grid(True)
plt.show()
```

This Python program uses a slightly different numerical scheme: it loops over each point in the spatial domain (excluding boundaries) and separately handles the boundary conditions. Also, for the first and last point in the space, we consider 1 point from the opposite side due to the periodic boundary condition. The initial condition function has also been rewritten according to the given problem definition.
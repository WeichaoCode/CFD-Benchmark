```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
Lx, Ly = 2.0, 1.0
nx, ny = 31, 31
dx = Lx / (nx - 1)
dy = Ly / (ny - 1)
tolerance = 1e-6
max_iterations = 10000

# Initialize potential array
p = np.zeros((ny, nx))

# Apply Dirichlet boundary conditions
# Left boundary (x=0): p = 0 (already zero)
# Right boundary (x=2): p = y
y = np.linspace(0, Ly, ny)
p[:, -1] = y

# Function to perform Gauss-Seidel iteration
def gauss_seidel(p, dx, dy, nx, ny, tolerance, max_iterations):
    delta = 1.0
    iteration = 0
    while delta > tolerance and iteration < max_iterations:
        delta = 0.0
        for j in range(1, ny-1):
            for i in range(1, nx-1):
                # Skip Dirichlet boundary on the right
                if i == nx-1:
                    continue
                # Compute neighboring points
                p_old = p[j, i]
                # Neumann boundary conditions on top and bottom
                if j == 0:
                    p_jm1 = p[j+1, i]  # p[j-1, i] = p[j+1, i]
                else:
                    p_jm1 = p[j-1, i]
                if j == ny-1:
                    p_jp1 = p[j-1, i]  # p[j+1, i] = p[j-1, i]
                else:
                    p_jp1 = p[j+1, i]
                
                # Update p[j, i] using the five-point stencil
                p_new = (dy**2 * (p[j, i+1] + p[j, i-1]) + dx**2 * (p_jp1 + p_jm1)) / (2 * (dx**2 + dy**2))
                
                # Compute the maximum change
                delta = max(delta, abs(p_new - p_old))
                
                # Update the potential
                p[j, i] = p_new
        iteration += 1
        if iteration % 100 == 0:
            print(f"Iteration {iteration}: max delta = {delta:.6f}")
    print(f"Converged after {iteration} iterations with max delta = {delta:.6f}")
    return p

# Perform the iterative solver
p = gauss_seidel(p, dx, dy, nx, ny, tolerance, max_iterations)

# Apply Neumann boundary conditions after iteration
# Top boundary (y=Ly)
p[-1, :] = p[-2, :]
# Bottom boundary (y=0)
p[0, :] = p[1, :]

# Create meshgrid for plotting
x = np.linspace(0, Lx, nx)
X, Y = np.meshgrid(x, y)

# Analytical solution
def analytical_solution(X, Y, terms=101):
    p_analytical = X / 4.0
    for n in range(1, terms, 2):  # only odd terms
        bn = (4 / (n * np.pi))**2 * np.sinh(n * np.pi * Lx) / np.sinh(2 * n * np.pi)
        p_analytical -= bn * np.cos(n * np.pi * Y)
    return p_analytical

p_analytical = analytical_solution(X, Y, terms=101)

# Plot numerical and analytical solutions
plt.figure(figsize=(12, 5))

# Numerical solution
plt.subplot(1, 2, 1)
cont1 = plt.contourf(X, Y, p, 20, cmap='viridis')
plt.colorbar(cont1)
plt.title('Numerical Solution')
plt.xlabel('x')
plt.ylabel('y')

# Analytical solution
plt.subplot(1, 2, 2)
cont2 = plt.contourf(X, Y, p_analytical, 20, cmap='viridis')
plt.colorbar(cont2)
plt.title('Analytical Solution')
plt.xlabel('x')
plt.ylabel('y')

plt.tight_layout()
plt.show()

# Save the numerical solution
np.save('p_solution.npy', p)
```